commit 42aa6c719dee2388096e376688f67fcb3ab78745
Author: BhanuprakashCH10 <cs23b012@iittp.ac.in>
Date:   Wed Jan 28 17:01:25 2026 +0530

    Initial commit

diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..1678b2d
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,4 @@
+BasedOnStyle: Google
+IndentWidth: 4
+TabWidth: 4
+SortIncludes: false
diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
new file mode 100644
index 0000000..7f62dc7
--- /dev/null
+++ b/.github/workflows/build.yml
@@ -0,0 +1,23 @@
+name: build
+on: [push, pull_request]
+jobs:
+  lint:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v1
+    - name: install clang-format
+      run: sudo apt-get install -y clang-format
+    - name: Lint with clang-format
+      run: find code/ -iname *.h -o -iname *.cc -o -iname *.c | xargs clang-format --dry-run --Werror
+  build:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v1
+    - name: Install building tools
+      run: bash install_building_tools.sh
+    - name: Build nachos
+      run: bash build_nachos.sh
+    - name: Build transfer COFF format to NOFF format
+      run: bash coff2noff.sh
+    - name: Build and run tests
+      run: bash build_test.sh
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..19c3b5f
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,12 @@
+*.o
+*.coff
+code/build.linux/DISK_0
+code/build.linux/nachos
+coff2noff/coff2noff.x86Linux
+code/test/*
+!code/test/*.c
+!code/test/input.txt
+!code/test/script
+!code/test/Makefile
+code/DISK_0
+.vscode/
diff --git a/COPYRIGHT b/COPYRIGHT
new file mode 100644
index 0000000..0892ced
--- /dev/null
+++ b/COPYRIGHT
@@ -0,0 +1,18 @@
+Copyright (c) 1992-1993 The Regents of the University of California.
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose, without fee, and without written agreement is
+hereby granted, provided that the above copyright notice and the following
+two paragraphs appear in all copies of this software.
+
+IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
+OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
+CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
+PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..dfcc531
--- /dev/null
+++ b/README.md
@@ -0,0 +1,32 @@
+# Nachos-project
+Not Another Completely Heuristic Operating System
+
+This is our course-work for the OS course in HCMUS.
+
+Nashos version: 4.0
+
+## Installation
+
+To install: run `bash full_install.sh`. In case of error, you might want to run the installation step by step via:
+```bash
+# Install building tools like make, g++
+bash install_building_tools.sh
+
+# Build the nachos
+bash build_nachos.sh
+
+# Build the coff2noff translator
+bash coff2noff.sh
+
+# Build & run tests in code/test folder
+bash build_test.sh
+```
+
+You can read the full building instruction [here](https://www.fit.hcmus.edu.vn/~ntquan/os/setup_nachos.html) if you want to (believe me, you don't want to read it :) ).
+
+
+## CI/CD
+
+I've set up the GitHub workflow, it will automatically build & test the nachos when you make a commit.
+
+Please make sure that you passed all the workflows before creating a pull request.
diff --git a/build_nachos.sh b/build_nachos.sh
new file mode 100755
index 0000000..3c06804
--- /dev/null
+++ b/build_nachos.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+set -e
+
+cd code/build.linux
+make depend
+make
+
+# Test
diff --git a/build_test.sh b/build_test.sh
new file mode 100644
index 0000000..3f5cfbc
--- /dev/null
+++ b/build_test.sh
@@ -0,0 +1,77 @@
+#!/bin/bash
+set -e
+
+cd code/test
+make
+
+../build.linux/nachos -x halt
+../build.linux/nachos -x test_syscall
+
+echo "123" | ../build.linux/nachos -x num_io | grep -q "123Machine halting!"
+echo "0" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "-0" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "-01" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "000001" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "-1" | ../build.linux/nachos -x num_io | grep -q "\-1Machine halting!"
+echo "-2147483648" | ../build.linux/nachos -x num_io | grep -q "\-2147483648Machine halting!"
+echo "-2147483649" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "2147483647" | ../build.linux/nachos -x num_io | grep -q "2147483647Machine halting!"
+echo "2147483648" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "3000000000" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+echo "-3000000000" | ../build.linux/nachos -x num_io | grep -q "0Machine halting!"
+
+
+# # Read @ and make sure the output has @
+echo "@" | ../build.linux/nachos -x char_io | grep -q "@Machine halting!"
+../build.linux/nachos -x random
+
+echo "3 123" | ../build.linux/nachos -x str_io | grep -q "123Machine halting!"
+echo "1 123" | ../build.linux/nachos -x str_io | grep -q "1Machine halting!"
+echo "256" | ../build.linux/nachos -x str_io -d u 2>&1 >/dev/null | grep -q "String length exceeds 255"
+# Print 255 'a's to stdout
+echo "255 "$(head -c 255 < /dev/zero | tr '\0' 'a') | \
+    ../build.linux/nachos -x str_io | \
+    grep -q $(head -c 255 < /dev/zero | tr '\0' 'a')"Machine halting!"
+
+../build.linux/nachos -x ascii | grep -q "33 !"
+../build.linux/nachos -x ascii | grep -q "126 ~"
+echo "5 3 4 1 5 2 1" | ../build.linux/nachos -x bubblesort | grep -q '1 2 3 4 5 Machine halting!'
+echo "5 3 4 1 5 2 2" | ../build.linux/nachos -x bubblesort | grep -q '5 4 3 2 1 Machine halting!'
+echo "5 -3 4 1 -5 2 1" | ../build.linux/nachos -x bubblesort | grep -q '\-5 \-3 1 2 4 Machine halting!'
+echo "a 5 3 4 1 5 2 1" | ../build.linux/nachos -x bubblesort | grep -q 'Sorted array: Machine halting!'
+echo "-5 5 3 4 1 5 2 1" | ../build.linux/nachos -x bubblesort | grep -q 'n has to be an integer between 1 and 100 (inclusive), please try again'
+echo "101 5 3 4 1 5 2 1" | ../build.linux/nachos -x bubblesort | grep -q 'n has to be an integer between 1 and 100 (inclusive), please try again'
+echo "5 3 4 1 5 2 3 1" | ../build.linux/nachos -x bubblesort | grep -q 'Wrong input, please try again'
+echo "5 a 4 1 5 2 1" | ../build.linux/nachos -x bubblesort | grep -q '0 1 2 4 5 Machine halting!'
+
+../build.linux/nachos -x help | grep -q "\- The program will print out the sorted array and then exit"
+
+echo "0" | ../build.linux/nachos -x create_file | grep -q 'Create file failed'
+echo "a" | ../build.linux/nachos -x create_file | grep -q 'Create file failed'
+
+echo "7 abc.txt" | ../build.linux/nachos -x create_file
+test -f "abc.txt"
+
+mkdir -p "xyz"
+echo "11 xyz/abc.txt" | ../build.linux/nachos -x create_file
+test -f "xyz/abc.txt"
+
+echo "random text to write to file" > "abc.txt"
+echo "" > "abc1.txt"
+echo "random text to write to file" > "abc2.txt"
+printf "random text to write to file\nrandom text to write to file\n" > "abc3.txt"
+
+echo "random text to read from console" | ../build.linux/nachos -x readwrite | grep -q 'random text to read from console'
+
+diff -q abc.txt abc1.txt
+diff -q abc2.txt abc3.txt
+
+printf "123" | ../build.linux/nachos -x exec | grep -q '123'
+
+../build.linux/nachos -x test_sem | grep -q 'testSemaphore passed'
+
+echo "5" > "input.txt"
+# run in 5 seconds and check if the output is correct
+timeout 5 ../build.linux/nachos -x main | grep -q 'Done'
+
+echo "Success!"
diff --git a/code/README b/code/README
new file mode 100644
index 0000000..cabd10b
--- /dev/null
+++ b/code/README
@@ -0,0 +1,12 @@
+Building Instructions:
+ * got to the directory build.<host>, where <host> is your working OS
+ * do a "make depend" to build depenencies (DO IT!)
+ * do a "make" to build NachOS
+
+Usage:
+see "nachos -u" for all command line options
+
+Building and starting user-level programs in NachOS:
+ * use Mips cross-compiler to build and link coff-binaries
+ * use coff2noff to translate the binaries to the NachOS-format
+ * start binary with nachos -x <path_to_file/file>
\ No newline at end of file
diff --git a/code/build.cygwin/Makefile b/code/build.cygwin/Makefile
new file mode 100644
index 0000000..be6b97b
--- /dev/null
+++ b/code/build.cygwin/Makefile
@@ -0,0 +1,367 @@
+# Copyright (c) 1992-1996 The Regents of the University of California.
+# All rights reserved.  See copyright.h for copyright notice and limitation 
+# of liability and disclaimer of warranty provisions.
+#
+# This is a GNU Makefile.  It must be used with the GNU make program.
+# At UW, the GNU make program is /software/gnu/bin/make.
+# In many other places it is known as "gmake".
+# You may wish to include /software/gnu/bin/ early in your command
+# search path, so that you will be using GNU make when you type "make".
+#
+# About this Makefile:
+# --------------------
+#
+#  This Makefile is used to build the Nachos system, which includes
+#   the MIPS machine simulation and a simple operating system.
+#
+#  There is a separate Makefile, in the "test" directory, that is
+#   used to build the Nachos test programs (which run on the
+#   simulated machine).
+#
+#  There are several "build" directories, one for each type
+#   of machine in the MFCF computing environment
+#   (build.solaris, build.sunos, and build.ultrix), as well
+#   as a build directory for Linux (build.linux) and a generic
+#   build directory (build.other) for those who wish to try
+#   building Nachos on other platforms.
+#
+#  This Makefile appears to be located in all of the build directories.
+#  If you edit it in one directory, the copies in all of the other
+#  directories appear to change as well.  This is the desired behaviour,
+#  since this file is machine independent.  (The file actually lives
+#  in build.solaris, with symbolic links from the other build directories.)
+#
+#  The platform-dependent parts of make's instructions are located
+#  in the file Makefile.dep.
+#  There is a different Makefile.dep in each build directory.
+#
+#  If you are in the MFCF environment, you should not have to edit
+#  the Makefile.dep files by hand.  Any changes to the make instructions
+#  can be made in this file (see the instructions below) - they will
+#  apply no matter where you build Nachos.
+#  If you are not in the MFCF environment, e.g., if you are trying
+#  to build Nachos on Linux at home, you will probably need
+#  to edit Makefile.dep (in the appropriate build directory) to
+#  customize the make procedure to your environment.
+#
+# How to build Nachos for the first time:
+# ---------------------------------------
+#
+#   (1) Make sure than you are in the build directory for the
+#	type of machine you are logged in to (the "host" machine):
+#
+#	host type	examples		build directory
+# 	-----------	-----------		----------------
+#
+#	sparc/SunOS	cayley,napier,		build.sunos
+#	(SunOS 4.1.3)	descartes
+#
+#	sparc/Solaris	picard.math,		build.solaris
+#	(SunOS 5.x)	hermite.math,
+#			markov.math,
+#			hypatia.math,
+#			hume.math
+#
+#	mips/ULTRIX	cantor.math		build.ultrix
+#	(ULTRIX 4.2)	noether.math
+#
+#	If you are not sure what type of machine you are on,
+#	try the command "uname -a".  
+#
+#   (2) Type "make depend"
+#		- this computes file dependencies and records them
+#			at the end of the file Makefile.dep in 
+#			your build directory.  Have a look...
+#
+#   (3) Type "make nachos"  (or just "make").
+#               - make echos the commands it is executing, so that
+#			you can observe its progress.  When the
+#			build is finished, you should have an
+#			executable "nachos" in the build directory.
+#
+#   (4) There is no 4th step.  You are done.  Try running "./nachos -u".
+#
+#
+# How to Re-build Nachos after you have changed the code:
+#--------------------------------------------------------
+#
+#     - The Nachos source code is located in the code subdirectories:
+#	  threads, userprog, filesys, network, and lib.  You may
+#         change the files in any of these directories, and you can
+#         add new files and/or remove files. The "machine" subdirectory
+#	  contains the hardware simulation (which is also part of
+#	  Nachos.  You may look at it, but
+#	  you may not change it, except as noted in machine/machine.h
+#     - When you want to re-make Nachos, always do it in the
+#	  "build" directory that is appropriate for the machine
+#	  type that you are running on.  
+#	DO NOT TRY TO MAKE NACHOS IN THE SOURCE CODE DIRECTORIES.
+#
+#     - IF all you have done is changed C++ code in existing files
+#	(since the last time you made Nachos in this build directory),
+#	THEN all you need to do to re-make Nachos is to type
+#
+#		"make nachos"
+#
+#	in the build directory.
+#
+#     - IF you have done any of the following since the last build in
+#	  this directory:
+#		added new .cc files or new .h files
+#		added or deleted #include's from existing files
+#	THEN
+#		you must do
+#		"make depend"
+#		followed by
+#		"make nachos"
+#
+#	in the build directory.
+#
+#       Note that is is always safe to do "make depend" followed by
+# 	"make nachos", so if you are not sure what changes you have
+#	made, do "make depend".
+#
+#     - IF you have added new files (.cc or .h) since the last build,
+#	you should edit this Makefile before running "make depend"
+# 	and "make nachos".
+
+#	For new .h files, simply update the appropriate "_H" list below.
+#       For example, if you create a file called
+#       "bigfile.h" in the filesys subdirectory, you should add
+#       "../filesys/bigfile.h" to FILESYS_H, which is defined below
+
+#	For new .cc files, update the appropriate "_C" and "_O" lists.
+#       For example, if you create a file called "filetable.cc" in
+#	the directory "userprog", you should add
+#	"../userprog/filetable.cc" to USERPROG_C,
+#       and you should add "filetable.o" to USERPROG_O.
+#       Note that the entry in the "_C" list includes the subdirectory
+#	name, while the entry on the "_O" list does not.
+#
+#  Some Important Notes:
+#  ---------------------
+#
+#       *  You can clean up all of the .o and other files left behind
+#	   by make by typeing "make clean" in the build directory.
+#	*  You can clean up .o and other files, as well as the nachos
+#	   executable, DISK, core, SOCKET, and other files by typing
+#	   make "distclean"
+#
+#	These are good ways to save space, but the next build that
+#	you do after cleaning will take longer than usual, since
+#	much of the stuff you cleaned will need to be rebuilt.
+#
+#       *  When you build Nachos on an ULTRIX machine (in build.ultrix),
+#	   you will get lots of warning messages like this:
+#
+#	openfile.o: does not have gp tables for all it's sectons
+#
+#	   from the loader.  Ignore them.  Or better yet, figure out
+#	   how to make them go away.
+#
+#  The Most Important Note:
+#  -----------------------
+#
+#	* If "make" is behaving strangely and you cannot figure out
+#	why, you should REBUILD the program FROM SCRATCH.
+#	Yes, it is slow.
+#	But, there are lots of little things that can go wrong, especially
+#	with all of these different types of machines available.
+#	Rebuilding from scratch at least gives you a known starting
+#	place.  To rebuild from scratch, go to the appropriate
+#	build directory and do:
+#	
+#		make distclean
+#		make depend
+#		make nachos
+#
+################################################################
+#  READ THIS:   CONFIGURING NACHOS
+#
+# Change DEFINES (below) to
+#   DEFINES = -DUSE_TLB -DFILESYS_STUB
+# if you want the simulated machine to use its TLB
+#
+# If you want to use the real Nachos file system (based on
+# the simulated disk), rather than the stub, remove
+# the -DFILESYS_STUB from DEFINES.
+#
+# There is a a fix to the MIPS simulator to enable it to properly
+# handle unaligned data access.  This fix is enabled by the addition
+# of "-DSIM_FIX" to the DEFINES.  This should be enabled by default
+# and eventually will not require the symbol definition
+################################################################
+DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX
+
+
+#####################################################################
+#
+# You might want to play with the CFLAGS, but if you use -O it may
+# break the thread system.  You might want to use -fno-inline if
+# you need to call some inline functions from the debugger.
+
+CFLAGS = -g -Wall -fwritable-strings $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED
+LDFLAGS =
+
+#####################################################################
+CPP= cpp
+CC = g++
+LD = g++
+AS = as
+RM = rm
+
+INCPATH = -I../network -I../filesys -I../userprog -I../threads -I../machine -I../lib
+
+PROGRAM = nachos
+
+#
+# Edit these lists as if you add files to the source directories.
+# See the instructions at the top of the file for more information.
+#
+
+LIB_H = ../lib/bitmap.h\
+	../lib/copyright.h\
+	../lib/debug.h\
+	../lib/hash.h\
+	../lib/libtest.h\
+	../lib/list.h\
+	../lib/sysdep.h\
+	../lib/utility.h
+
+LIB_C = ../lib/bitmap.cc\
+	../lib/debug.cc\
+	../lib/hash.cc\
+	../lib/libtest.cc\
+	../lib/list.cc\
+	../lib/sysdep.cc
+
+LIB_O = bitmap.o debug.o libtest.o sysdep.o
+
+
+MACHINE_H = ../machine/callback.h\
+	../machine/interrupt.h\
+	../machine/stats.h\
+	../machine/timer.h\
+	../machine/console.h\
+	../machine/machine.h\
+	../machine/mipssim.h\
+	../machine/translate.h\
+	../machine/network.h\
+	../machine/disk.h
+
+MACHINE_C = ../machine/interrupt.cc\
+	../machine/stats.cc\
+	../machine/timer.cc\
+	../machine/console.cc\
+	../machine/machine.cc\
+	../machine/mipssim.cc\
+	../machine/translate.cc\
+	../machine/network.cc\
+	../machine/disk.cc
+
+MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\
+	translate.o network.o disk.o
+
+THREAD_H = ../threads/alarm.h\
+	../threads/kernel.h\
+	../threads/main.h\
+	../threads/scheduler.h\
+	../threads/switch.h\
+	../threads/synch.h\
+	../threads/synchlist.h\
+	../threads/thread.h
+
+THREAD_C = ../threads/alarm.cc\
+	../threads/kernel.cc\
+	../threads/main.cc\
+	../threads/scheduler.cc\
+	../threads/synch.cc\
+	../threads/synchlist.cc\
+	../threads/thread.cc
+
+THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o
+
+USERPROG_H = ../userprog/addrspace.h\
+	../userprog/syscall.h\
+	../userprog/synchconsole.h\
+	../userprog/noff.h
+
+USERPROG_C = ../userprog/addrspace.cc\
+	../userprog/exception.cc\
+	../userprog/synchconsole.cc
+
+USERPROG_O = addrspace.o exception.o synchconsole.o
+
+FILESYS_H =../filesys/directory.h \
+	../filesys/filehdr.h\
+	../filesys/filesys.h \
+	../filesys/openfile.h\
+	../filesys/pbitmap.h\
+	../filesys/synchdisk.h
+
+FILESYS_C =../filesys/directory.cc\
+	../filesys/filehdr.cc\
+	../filesys/filesys.cc\
+	../filesys/pbitmap.cc\
+	../filesys/openfile.cc\
+	../filesys/synchdisk.cc\
+
+FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o
+
+NETWORK_H = ../network/post.h
+
+NETWORK_C = ../network/post.cc
+
+NETWORK_O = post.o
+
+##################################################################
+#  You probably don't want to change anything below this point in
+#  the file unless you are comfortable with GNU make and know what
+#  you are doing...
+##################################################################
+
+THREAD_S = ../threads/switch.s
+
+HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)
+CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)
+
+C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)
+
+S_OFILES = switch.o
+OFILES = $(C_OFILES) $(S_OFILES)
+
+$(PROGRAM): $(OFILES)
+	$(LD) $(OFILES) $(LDFLAGS) -o $(PROGRAM)
+
+$(C_OFILES): %.o:
+	$(CC) $(CFLAGS) -c $<
+
+switch.o: ../threads/switch.s
+	$(CPP) $(CPP_AS_FLAGS) -P $(INCPATH) $(HOSTCFLAGS) ../threads/switch.s > swtch.s
+	$(AS) -o switch.o swtch.s
+
+depend: $(CFILES) $(HFILES)
+	$(CC) $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED -M $(CFILES) > makedep
+	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@echo 'q' >>eddep
+	ed - Makefile.dep < eddep
+	rm eddep makedep 
+	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile.dep
+	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile.dep
+	@echo '# see make depend above' >> Makefile.dep
+
+clean:
+	$(RM) -f $(OFILES)
+	$(RM) -f swtch.s
+	$(RM) -f *.s *.ii
+
+distclean: clean
+	$(RM) -f $(PROGRAM)
+	$(RM) -f $(PROGRAM).exe
+	$(RM) -f DISK_?
+	$(RM) -f core
+	$(RM) -f SOCKET_?
+
+include Makefile.dep
diff --git a/code/build.cygwin/Makefile.dep b/code/build.cygwin/Makefile.dep
new file mode 100644
index 0000000..c3f81d4
--- /dev/null
+++ b/code/build.cygwin/Makefile.dep
@@ -0,0 +1,544 @@
+##################################################################
+#  Machine Dependencies - this file is included automatically
+#     into the main Makefile
+#
+# This file contains definitions below for x86 running Linux
+# It has *not* been tested!
+##################################################################
+
+HOSTCFLAGS = -Dx86 -DLINUX -DCYGWIN
+
+#-----------------------------------------------------------------
+# Do not put anything below this point - it will be destroyed by
+# "make depend"
+#
+# DO NOT DELETE THIS LINE -- make depend uses it
+# DEPENDENCIES MUST END AT END OF FILE
+bitmap.o: ../lib/bitmap.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/bitmap.h
+debug.o: ../lib/debug.cc ../lib/copyright.h ../lib/utility.h \
+ ../lib/debug.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h
+hash.o: ../lib/hash.cc ../lib/copyright.h
+libtest.o: ../lib/libtest.cc ../lib/copyright.h ../lib/libtest.h \
+ ../lib/bitmap.h ../lib/utility.h ../lib/list.h ../lib/debug.h \
+ ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/list.cc ../lib/hash.h ../lib/hash.cc
+list.o: ../lib/list.cc ../lib/copyright.h
+sysdep.o: ../lib/sysdep.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h /usr/include/unistd.h /usr/include/sys/unistd.h \
+ /usr/include/getopt.h /usr/include/sys/time.h \
+ /usr/include/sys/select.h /usr/include/time.h \
+ /usr/include/machine/time.h /usr/include/sys/file.h \
+ /usr/include/fcntl.h /usr/include/sys/fcntl.h /usr/include/sys/stat.h \
+ /usr/include/cygwin/stat.h /usr/include/sys/socket.h \
+ /usr/include/features.h /usr/include/cygwin/socket.h \
+ /usr/include/asm/socket.h /usr/include/cygwin/if.h \
+ /usr/include/cygwin/sockios.h /usr/include/cygwin/uio.h \
+ /usr/include/sys/un.h /usr/include/signal.h /usr/include/sys/signal.h
+interrupt.o: ../machine/interrupt.cc ../lib/copyright.h \
+ ../machine/interrupt.h ../lib/list.h ../lib/debug.h ../lib/utility.h \
+ ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/list.cc ../machine/callback.h \
+ ../threads/main.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+stats.o: ../machine/stats.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/stats.h
+timer.o: ../machine/timer.cc ../lib/copyright.h ../machine/timer.h \
+ ../lib/utility.h ../machine/callback.h ../threads/main.h \
+ ../lib/debug.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h
+console.o: ../machine/console.cc ../lib/copyright.h \
+ ../machine/console.h ../lib/utility.h ../machine/callback.h \
+ ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+machine.o: ../machine/machine.cc ../lib/copyright.h \
+ ../machine/machine.h ../lib/utility.h ../machine/translate.h \
+ ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/scheduler.h ../lib/list.h ../lib/list.cc \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h
+mipssim.o: ../machine/mipssim.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/machine.h ../machine/translate.h \
+ ../machine/mipssim.h ../threads/main.h ../threads/kernel.h \
+ ../threads/thread.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+translate.o: ../machine/translate.cc ../lib/copyright.h \
+ ../threads/main.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h
+network.o: ../machine/network.cc ../lib/copyright.h \
+ ../machine/network.h ../lib/utility.h ../machine/callback.h \
+ ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+disk.o: ../machine/disk.cc ../lib/copyright.h ../machine/disk.h \
+ ../lib/utility.h ../machine/callback.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/main.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/scheduler.h ../lib/list.h ../lib/list.cc \
+ ../machine/interrupt.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h
+alarm.o: ../threads/alarm.cc ../lib/copyright.h ../threads/alarm.h \
+ ../lib/utility.h ../machine/callback.h ../machine/timer.h \
+ ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/stats.h
+kernel.o: ../threads/kernel.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/main.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/scheduler.h ../lib/list.h ../lib/list.cc \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../threads/synch.h \
+ ../threads/synchlist.h ../threads/synchlist.cc ../lib/libtest.h \
+ ../userprog/synchconsole.h ../machine/console.h \
+ ../filesys/synchdisk.h ../machine/disk.h ../network/post.h \
+ ../machine/network.h
+main.o: ../threads/main.cc ../lib/copyright.h ../threads/main.h \
+ ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h
+scheduler.o: ../threads/scheduler.cc ../lib/copyright.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../threads/main.h ../threads/kernel.h \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h
+synch.o: ../threads/synch.cc ../lib/copyright.h ../threads/synch.h \
+ ../threads/thread.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../lib/list.h ../lib/debug.h ../lib/list.cc ../threads/main.h \
+ ../threads/kernel.h ../threads/scheduler.h ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h
+synchlist.o: ../threads/synchlist.cc ../lib/copyright.h \
+ ../threads/synchlist.h ../lib/list.h ../lib/debug.h ../lib/utility.h \
+ ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/list.cc ../threads/synch.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/main.h ../threads/kernel.h ../threads/scheduler.h \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../threads/synchlist.cc
+thread.o: ../threads/thread.cc ../lib/copyright.h ../threads/thread.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/switch.h ../threads/synch.h ../lib/list.h ../lib/debug.h \
+ ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+addrspace.o: ../userprog/addrspace.cc ../lib/copyright.h \
+ ../threads/main.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../userprog/noff.h
+exception.o: ../userprog/exception.cc ../lib/copyright.h \
+ ../threads/main.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../threads/kernel.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../userprog/syscall.h ../userprog/errno.h \
+ ../userprog/ksyscall.h
+synchconsole.o: ../userprog/synchconsole.cc ../lib/copyright.h \
+ ../userprog/synchconsole.h ../lib/utility.h ../machine/callback.h \
+ ../machine/console.h ../threads/synch.h ../threads/thread.h \
+ ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../lib/list.h ../lib/debug.h ../lib/list.cc ../threads/main.h \
+ ../threads/kernel.h ../threads/scheduler.h ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+directory.o: ../filesys/directory.cc ../lib/copyright.h \
+ ../lib/utility.h ../filesys/filehdr.h ../machine/disk.h \
+ ../machine/callback.h ../filesys/pbitmap.h ../lib/bitmap.h \
+ ../filesys/openfile.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../filesys/directory.h
+filehdr.o: ../filesys/filehdr.cc ../lib/copyright.h \
+ ../filesys/filehdr.h ../machine/disk.h ../lib/utility.h \
+ ../machine/callback.h ../filesys/pbitmap.h ../lib/bitmap.h \
+ ../filesys/openfile.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/debug.h ../filesys/synchdisk.h \
+ ../threads/synch.h ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../lib/list.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h
+filesys.o: ../filesys/filesys.cc
+pbitmap.o: ../filesys/pbitmap.cc ../lib/copyright.h \
+ ../filesys/pbitmap.h ../lib/bitmap.h ../lib/utility.h \
+ ../filesys/openfile.h ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h
+openfile.o: ../filesys/openfile.cc
+synchdisk.o: ../filesys/synchdisk.cc ../lib/copyright.h \
+ ../filesys/synchdisk.h ../machine/disk.h ../lib/utility.h \
+ ../machine/callback.h ../threads/synch.h ../threads/thread.h \
+ ../lib/sysdep.h /usr/include/g++-3/iostream.h \
+ /usr/include/g++-3/streambuf.h /usr/include/g++-3/libio.h \
+ /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../lib/list.h ../lib/debug.h ../lib/list.cc ../threads/main.h \
+ ../threads/kernel.h ../threads/scheduler.h ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h
+post.o: ../network/post.cc ../lib/copyright.h ../network/post.h \
+ ../lib/utility.h ../machine/callback.h ../machine/network.h \
+ ../threads/synchlist.h ../lib/list.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/g++-3/iostream.h /usr/include/g++-3/streambuf.h \
+ /usr/include/g++-3/libio.h /usr/include/_G_config.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stddef.h \
+ /usr/include/sys/cdefs.h /usr/include/stdlib.h /usr/include/_ansi.h \
+ /usr/include/sys/config.h /usr/include/sys/reent.h \
+ /usr/include/sys/_types.h /usr/include/machine/stdlib.h \
+ /usr/include/alloca.h /usr/include/stdio.h \
+ /usr/lib/gcc-lib/i686-pc-cygwin/2.95.3-5/include/stdarg.h \
+ /usr/include/sys/types.h /usr/include/machine/types.h \
+ /usr/include/sys/features.h /usr/include/cygwin/types.h \
+ /usr/include/sys/sysmacros.h /usr/include/sys/stdio.h \
+ /usr/include/string.h ../lib/list.cc ../threads/synch.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../threads/main.h ../threads/kernel.h ../threads/scheduler.h \
+ ../machine/interrupt.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../threads/synchlist.cc
+# DEPENDENCIES MUST END AT END OF FILE
+# IF YOU PUT STUFF HERE IT WILL GO AWAY
+# see make depend above
diff --git a/code/build.linux/Makefile b/code/build.linux/Makefile
new file mode 100644
index 0000000..3def870
--- /dev/null
+++ b/code/build.linux/Makefile
@@ -0,0 +1,380 @@
+# Copyright (c) 1992-1996 The Regents of the University of California.
+# All rights reserved.  See copyright.h for copyright notice and limitation 
+# of liability and disclaimer of warranty provisions.
+#
+# This is a GNU Makefile.  It must be used with the GNU make program.
+# At UW, the GNU make program is /software/gnu/bin/make.
+# In many other places it is known as "gmake".
+# You may wish to include /software/gnu/bin/ early in your command
+# search path, so that you will be using GNU make when you type "make".
+#
+# About this Makefile:
+# --------------------
+#
+#  This Makefile is used to build the Nachos system, which includes
+#   the MIPS machine simulation and a simple operating system.
+#
+#  There is a separate Makefile, in the "test" directory, that is
+#   used to build the Nachos test programs (which run on the
+#   simulated machine).
+#
+#  There are several "build" directories, one for each type
+#   of machine in the MFCF computing environment
+#   (build.solaris, build.sunos, and build.ultrix), as well
+#   as a build directory for Linux (build.linux) and a generic
+#   build directory (build.other) for those who wish to try
+#   building Nachos on other platforms.
+#
+#  This Makefile appears to be located in all of the build directories.
+#  If you edit it in one directory, the copies in all of the other
+#  directories appear to change as well.  This is the desired behaviour,
+#  since this file is machine independent.  (The file actually lives
+#  in build.solaris, with symbolic links from the other build directories.)
+#
+#  The platform-dependent parts of make's instructions are located
+#  in the file Makefile.dep.
+#  There is a different Makefile.dep in each build directory.
+#
+#  If you are in the MFCF environment, you should not have to edit
+#  the Makefile.dep files by hand.  Any changes to the make instructions
+#  can be made in this file (see the instructions below) - they will
+#  apply no matter where you build Nachos.
+#  If you are not in the MFCF environment, e.g., if you are trying
+#  to build Nachos on Linux at home, you will probably need
+#  to edit Makefile.dep (in the appropriate build directory) to
+#  customize the make procedure to your environment.
+#
+# How to build Nachos for the first time:
+# ---------------------------------------
+#
+#   (1) Make sure than you are in the build directory for the
+#	type of machine you are logged in to (the "host" machine):
+#
+#	host type	examples		build directory
+# 	-----------	-----------		----------------
+#
+#	sparc/SunOS	cayley,napier,		build.sunos
+#	(SunOS 4.1.3)	descartes
+#
+#	sparc/Solaris	picard.math,		build.solaris
+#	(SunOS 5.x)	hermite.math,
+#			markov.math,
+#			hypatia.math,
+#			hume.math
+#
+#	mips/ULTRIX	cantor.math		build.ultrix
+#	(ULTRIX 4.2)	noether.math
+#
+#	If you are not sure what type of machine you are on,
+#	try the command "uname -a".  
+#
+#   (2) Type "make depend"
+#		- this computes file dependencies and records them
+#			at the end of the file Makefile.dep in 
+#			your build directory.  Have a look...
+#
+#   (3) Type "make nachos"  (or just "make").
+#               - make echos the commands it is executing, so that
+#			you can observe its progress.  When the
+#			build is finished, you should have an
+#			executable "nachos" in the build directory.
+#
+#   (4) There is no 4th step.  You are done.  Try running "./nachos -u".
+#
+#
+# How to Re-build Nachos after you have changed the code:
+#--------------------------------------------------------
+#
+#     - The Nachos source code is located in the code subdirectories:
+#	  threads, userprog, filesys, network, and lib.  You may
+#         change the files in any of these directories, and you can
+#         add new files and/or remove files. The "machine" subdirectory
+#	  contains the hardware simulation (which is also part of
+#	  Nachos.  You may look at it, but
+#	  you may not change it, except as noted in machine/machine.h
+#     - When you want to re-make Nachos, always do it in the
+#	  "build" directory that is appropriate for the machine
+#	  type that you are running on.  
+#	DO NOT TRY TO MAKE NACHOS IN THE SOURCE CODE DIRECTORIES.
+#
+#     - IF all you have done is changed C++ code in existing files
+#	(since the last time you made Nachos in this build directory),
+#	THEN all you need to do to re-make Nachos is to type
+#
+#		"make nachos"
+#
+#	in the build directory.
+#
+#     - IF you have done any of the following since the last build in
+#	  this directory:
+#		added new .cc files or new .h files
+#		added or deleted #include's from existing files
+#	THEN
+#		you must do
+#		"make depend"
+#		followed by
+#		"make nachos"
+#
+#	in the build directory.
+#
+#       Note that is is always safe to do "make depend" followed by
+# 	"make nachos", so if you are not sure what changes you have
+#	made, do "make depend".
+#
+#     - IF you have added new files (.cc or .h) since the last build,
+#	you should edit this Makefile before running "make depend"
+# 	and "make nachos".
+
+#	For new .h files, simply update the appropriate "_H" list below.
+#       For example, if you create a file called
+#       "bigfile.h" in the filesys subdirectory, you should add
+#       "../filesys/bigfile.h" to FILESYS_H, which is defined below
+
+#	For new .cc files, update the appropriate "_C" and "_O" lists.
+#       For example, if you create a file called "filetable.cc" in
+#	the directory "userprog", you should add
+#	"../userprog/filetable.cc" to USERPROG_C,
+#       and you should add "filetable.o" to USERPROG_O.
+#       Note that the entry in the "_C" list includes the subdirectory
+#	name, while the entry on the "_O" list does not.
+#
+#  Some Important Notes:
+#  ---------------------
+#
+#       *  You can clean up all of the .o and other files left behind
+#	   by make by typeing "make clean" in the build directory.
+#	*  You can clean up .o and other files, as well as the nachos
+#	   executable, DISK, core, SOCKET, and other files by typing
+#	   make "distclean"
+#
+#	These are good ways to save space, but the next build that
+#	you do after cleaning will take longer than usual, since
+#	much of the stuff you cleaned will need to be rebuilt.
+#
+#       *  When you build Nachos on an ULTRIX machine (in build.ultrix),
+#	   you will get lots of warning messages like this:
+#
+#	openfile.o: does not have gp tables for all it's sectons
+#
+#	   from the loader.  Ignore them.  Or better yet, figure out
+#	   how to make them go away.
+#
+#  The Most Important Note:
+#  -----------------------
+#
+#	* If "make" is behaving strangely and you cannot figure out
+#	why, you should REBUILD the program FROM SCRATCH.
+#	Yes, it is slow.
+#	But, there are lots of little things that can go wrong, especially
+#	with all of these different types of machines available.
+#	Rebuilding from scratch at least gives you a known starting
+#	place.  To rebuild from scratch, go to the appropriate
+#	build directory and do:
+#	
+#		make distclean
+#		make depend
+#		make nachos
+#
+################################################################
+#  READ THIS:   CONFIGURING NACHOS
+#
+# Change DEFINES (below) to
+#   DEFINES = -DUSE_TLB -DFILESYS_STUB
+# if you want the simulated machine to use its TLB
+#
+# If you want to use the real Nachos file system (based on
+# the simulated disk), rather than the stub, remove
+# the -DFILESYS_STUB from DEFINES.
+#
+# There is a a fix to the MIPS simulator to enable it to properly
+# handle unaligned data access.  This fix is enabled by the addition
+# of "-DSIM_FIX" to the DEFINES.  This should be enabled by default
+# and eventually will not require the symbol definition
+################################################################
+DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX
+
+
+#####################################################################
+#
+# You might want to play with the CFLAGS, but if you use -O it may
+# break the thread system.  You might want to use -fno-inline if
+# you need to call some inline functions from the debugger.
+
+CFLAGS = -g -Wall $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED -m32
+LDFLAGS = -m32
+CPP_AS_FLAGS= -m32
+
+#####################################################################
+CPP=/lib/cpp
+CC = g++
+LD = g++
+AS = as
+RM = /bin/rm
+
+INCPATH = -I../network -I../filesys -I../userprog -I../threads -I../machine -I../lib -I-
+
+PROGRAM = nachos
+
+#
+# Edit these lists as if you add files to the source directories.
+# See the instructions at the top of the file for more information.
+#
+
+LIB_H = ../lib/bitmap.h\
+	../lib/copyright.h\
+	../lib/debug.h\
+	../lib/hash.h\
+	../lib/libtest.h\
+	../lib/list.h\
+	../lib/sysdep.h\
+	../lib/utility.h
+
+LIB_C = ../lib/bitmap.cc\
+	../lib/debug.cc\
+	../lib/hash.cc\
+	../lib/libtest.cc\
+	../lib/list.cc\
+	../lib/sysdep.cc
+
+LIB_O = bitmap.o debug.o libtest.o sysdep.o
+
+
+MACHINE_H = ../machine/callback.h\
+	../machine/interrupt.h\
+	../machine/stats.h\
+	../machine/timer.h\
+	../machine/console.h\
+	../machine/machine.h\
+	../machine/mipssim.h\
+	../machine/translate.h\
+	../machine/network.h\
+	../machine/disk.h
+
+MACHINE_C = ../machine/interrupt.cc\
+	../machine/stats.cc\
+	../machine/timer.cc\
+	../machine/console.cc\
+	../machine/machine.cc\
+	../machine/mipssim.cc\
+	../machine/translate.cc\
+	../machine/network.cc\
+	../machine/disk.cc
+
+MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\
+	translate.o network.o disk.o
+
+THREAD_H = ../threads/alarm.h\
+	../threads/kernel.h\
+	../threads/main.h\
+	../threads/scheduler.h\
+	../threads/switch.h\
+	../threads/synch.h\
+	../threads/synchlist.h\
+	../threads/thread.h\
+	../threads/ptable.h\
+	../threads/pcb.h\
+	../threads/stable.h\
+	../threads/sem.h\
+
+THREAD_C = ../threads/alarm.cc\
+	../threads/kernel.cc\
+	../threads/main.cc\
+	../threads/scheduler.cc\
+	../threads/synch.cc\
+	../threads/synchlist.cc\
+	../threads/thread.cc\
+	../threads/ptable.cc\
+	../threads/pcb.cc\
+	../threads/stable.cc\
+	../threads/sem.cc\
+
+THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o ptable.o pcb.o stable.o sem.o
+
+USERPROG_H = ../userprog/addrspace.h\
+	../userprog/syscall.h\
+	../userprog/synchconsole.h\
+	../userprog/noff.h
+
+USERPROG_C = ../userprog/addrspace.cc\
+	../userprog/exception.cc\
+	../userprog/synchconsole.cc
+
+USERPROG_O = addrspace.o exception.o synchconsole.o
+
+FILESYS_H =../filesys/directory.h \
+	../filesys/filehdr.h\
+	../filesys/filesys.h \
+	../filesys/openfile.h\
+	../filesys/pbitmap.h\
+	../filesys/synchdisk.h
+
+FILESYS_C =../filesys/directory.cc\
+	../filesys/filehdr.cc\
+	../filesys/filesys.cc\
+	../filesys/pbitmap.cc\
+	../filesys/openfile.cc\
+	../filesys/synchdisk.cc\
+
+FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o
+
+NETWORK_H = ../network/post.h
+
+NETWORK_C = ../network/post.cc
+
+NETWORK_O = post.o
+
+##################################################################
+#  You probably don't want to change anything below this point in
+#  the file unless you are comfortable with GNU make and know what
+#  you are doing...
+##################################################################
+
+THREAD_S = ../threads/switch.s
+
+HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)
+CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)
+
+C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)
+
+S_OFILES = switch.o
+OFILES = $(C_OFILES) $(S_OFILES)
+
+$(PROGRAM): $(OFILES)
+	$(LD) $(OFILES) $(LDFLAGS) -o $(PROGRAM)
+
+$(C_OFILES): %.o:
+	$(CC) $(CFLAGS) -c $<
+
+switch.o: ../threads/switch.S
+	$(CC) $(CPP_AS_FLAGS) -P $(INCPATH) $(HOSTCFLAGS) -c ../threads/switch.S
+
+depend: $(CFILES) $(HFILES)
+	$(CC) $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED -M $(CFILES) > makedep
+	@echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@echo 'q' >>eddep
+	ed - Makefile.dep < eddep
+	rm eddep makedep 
+	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile.dep
+	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile.dep
+	@echo '# see make depend above' >> Makefile.dep
+
+clean:
+	$(RM) -f $(OFILES)
+
+distclean: clean
+	$(RM) -f $(PROGRAM)
+	$(RM) -f DISK_?
+	$(RM) -f core
+	$(RM) -f SOCKET_?
+	@echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >eddep
+	@echo 'w' >>eddep
+	@echo 'q' >>eddep
+	ed - Makefile.dep < eddep
+	rm eddep 
+	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile.dep
+	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile.dep
+	@echo '# see make depend above' >> Makefile.dep
+
+include Makefile.dep
diff --git a/code/build.linux/Makefile.dep b/code/build.linux/Makefile.dep
new file mode 100644
index 0000000..d7bc40f
--- /dev/null
+++ b/code/build.linux/Makefile.dep
@@ -0,0 +1,5303 @@
+##################################################################
+#  Machine Dependencies - this file is included automatically
+#     into the main Makefile
+#
+# This file contains definitions below for x86 running Linux
+# It has *not* been tested!
+##################################################################
+
+HOSTCFLAGS = -Dx86 -DLINUX
+
+#-----------------------------------------------------------------
+# Do not put anything below this point - it will be destroyed by
+# "make depend"
+#
+# DO NOT DELETE THIS LINE -- make depend uses it
+bitmap.o: ../lib/bitmap.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/bitmap.h
+debug.o: ../lib/debug.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../lib/utility.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h
+hash.o: ../lib/hash.cc /usr/include/stdc-predef.h ../lib/copyright.h
+libtest.o: ../lib/libtest.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/libtest.h ../lib/bitmap.h ../lib/utility.h \
+ ../lib/list.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/list.cc \
+ ../lib/hash.h ../lib/hash.cc
+list.o: ../lib/list.cc /usr/include/stdc-predef.h ../lib/copyright.h
+sysdep.o: ../lib/sysdep.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h /usr/include/unistd.h \
+ /usr/include/x86_64-linux-gnu/bits/posix_opt.h \
+ /usr/include/x86_64-linux-gnu/bits/environments.h \
+ /usr/include/x86_64-linux-gnu/bits/confname.h \
+ /usr/include/x86_64-linux-gnu/bits/getopt_posix.h \
+ /usr/include/x86_64-linux-gnu/bits/getopt_core.h \
+ /usr/include/x86_64-linux-gnu/bits/unistd_ext.h \
+ /usr/include/linux/close_range.h \
+ /usr/include/x86_64-linux-gnu/sys/time.h \
+ /usr/include/x86_64-linux-gnu/sys/file.h /usr/include/fcntl.h \
+ /usr/include/x86_64-linux-gnu/bits/fcntl.h \
+ /usr/include/x86_64-linux-gnu/bits/fcntl-linux.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h \
+ /usr/include/linux/falloc.h /usr/include/x86_64-linux-gnu/bits/stat.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_stat.h \
+ /usr/include/x86_64-linux-gnu/sys/socket.h \
+ /usr/include/x86_64-linux-gnu/bits/socket.h \
+ /usr/include/x86_64-linux-gnu/bits/socket_type.h \
+ /usr/include/x86_64-linux-gnu/bits/sockaddr.h \
+ /usr/include/x86_64-linux-gnu/asm/socket.h \
+ /usr/include/asm-generic/socket.h /usr/include/linux/posix_types.h \
+ /usr/include/linux/stddef.h \
+ /usr/include/x86_64-linux-gnu/asm/posix_types.h \
+ /usr/include/x86_64-linux-gnu/asm/posix_types_64.h \
+ /usr/include/asm-generic/posix_types.h \
+ /usr/include/x86_64-linux-gnu/asm/bitsperlong.h \
+ /usr/include/asm-generic/bitsperlong.h \
+ /usr/include/x86_64-linux-gnu/asm/sockios.h \
+ /usr/include/asm-generic/sockios.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_osockaddr.h \
+ /usr/include/x86_64-linux-gnu/sys/un.h /usr/include/signal.h \
+ /usr/include/x86_64-linux-gnu/bits/signum-generic.h \
+ /usr/include/x86_64-linux-gnu/bits/signum-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h \
+ /usr/include/x86_64-linux-gnu/bits/siginfo-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/siginfo-consts.h \
+ /usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigval_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h \
+ /usr/include/x86_64-linux-gnu/bits/sigevent-consts.h \
+ /usr/include/x86_64-linux-gnu/bits/sigaction.h \
+ /usr/include/x86_64-linux-gnu/bits/sigcontext.h \
+ /usr/include/x86_64-linux-gnu/bits/types/stack_t.h \
+ /usr/include/x86_64-linux-gnu/sys/ucontext.h \
+ /usr/include/x86_64-linux-gnu/bits/sigstack.h \
+ /usr/include/x86_64-linux-gnu/bits/sigstksz.h \
+ /usr/include/x86_64-linux-gnu/bits/ss_flags.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h \
+ /usr/include/x86_64-linux-gnu/bits/sigthread.h \
+ /usr/include/x86_64-linux-gnu/bits/signal_ext.h
+interrupt.o: ../machine/interrupt.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../machine/interrupt.h ../lib/list.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/list.cc \
+ ../machine/callback.h ../threads/main.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+stats.o: ../machine/stats.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/stats.h
+timer.o: ../machine/timer.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../machine/timer.h ../lib/utility.h \
+ ../machine/callback.h ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../lib/bitmap.h ../threads/stable.h ../threads/sem.h \
+ ../threads/ptable.h ../threads/pcb.h
+console.o: ../machine/console.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../machine/console.h ../lib/utility.h \
+ ../machine/callback.h ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+machine.o: ../machine/machine.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../machine/machine.h ../lib/utility.h \
+ ../machine/translate.h ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../lib/bitmap.h ../threads/stable.h ../threads/sem.h \
+ ../threads/ptable.h ../threads/pcb.h
+mipssim.o: ../machine/mipssim.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../machine/mipssim.h ../threads/main.h \
+ ../threads/kernel.h ../threads/thread.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/openfile.h ../filesys/filetable.h \
+ ../threads/scheduler.h ../lib/list.h ../lib/list.cc \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+translate.o: ../machine/translate.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/main.h ../lib/debug.h ../lib/utility.h \
+ ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+network.o: ../machine/network.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../machine/network.h ../lib/utility.h \
+ ../machine/callback.h ../threads/main.h ../lib/debug.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+disk.o: ../machine/disk.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../machine/disk.h ../lib/utility.h ../machine/callback.h ../lib/debug.h \
+ ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/main.h \
+ ../threads/kernel.h ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+alarm.o: ../threads/alarm.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/alarm.h ../lib/utility.h \
+ ../machine/callback.h ../machine/timer.h ../threads/main.h \
+ ../lib/debug.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/stats.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+kernel.o: ../threads/kernel.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/main.h \
+ ../threads/kernel.h ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../lib/bitmap.h ../threads/stable.h ../threads/sem.h \
+ ../threads/ptable.h ../threads/pcb.h ../threads/synch.h \
+ ../threads/synchlist.h ../threads/synchlist.cc ../lib/libtest.h \
+ ../userprog/synchconsole.h ../machine/console.h ../filesys/synchdisk.h \
+ ../machine/disk.h ../network/post.h ../machine/network.h
+main.o: ../threads/main.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../threads/main.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+scheduler.o: ../threads/scheduler.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/debug.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/scheduler.h \
+ ../lib/list.h ../lib/list.cc ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/main.h \
+ ../threads/kernel.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+synch.o: ../threads/synch.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/synch.h ../threads/thread.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+synchlist.o: ../threads/synchlist.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/synchlist.h ../lib/list.h ../lib/debug.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/list.cc \
+ ../threads/synch.h ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/main.h \
+ ../threads/kernel.h ../threads/scheduler.h ../machine/interrupt.h \
+ ../machine/callback.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../lib/bitmap.h ../threads/stable.h ../threads/sem.h \
+ ../threads/ptable.h ../threads/pcb.h ../threads/synchlist.cc
+thread.o: ../threads/thread.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/thread.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/switch.h \
+ ../threads/synch.h ../lib/list.h ../lib/debug.h ../lib/list.cc \
+ ../threads/main.h ../threads/kernel.h ../threads/scheduler.h \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+ptable.o: ../threads/ptable.cc /usr/include/stdc-predef.h \
+ ../threads/synch.h ../lib/copyright.h ../threads/thread.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+pcb.o: ../threads/pcb.cc /usr/include/stdc-predef.h ../threads/synch.h \
+ ../lib/copyright.h ../threads/thread.h ../lib/utility.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+stable.o: ../threads/stable.cc /usr/include/stdc-predef.h \
+ ../threads/synch.h ../lib/copyright.h ../threads/thread.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+sem.o: ../threads/sem.cc /usr/include/stdc-predef.h ../threads/sem.h \
+ ../threads/synch.h ../lib/copyright.h ../threads/thread.h \
+ ../lib/utility.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/ptable.h ../threads/pcb.h
+addrspace.o: ../userprog/addrspace.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/main.h ../lib/debug.h ../lib/utility.h \
+ ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h ../userprog/noff.h ../threads/synch.h
+exception.o: ../userprog/exception.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../threads/main.h ../lib/debug.h ../lib/utility.h \
+ ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../threads/kernel.h \
+ ../threads/thread.h ../machine/machine.h ../machine/translate.h \
+ ../userprog/addrspace.h ../filesys/filesys.h ../filesys/openfile.h \
+ ../filesys/filetable.h ../threads/scheduler.h ../lib/list.h \
+ ../lib/list.cc ../machine/interrupt.h ../machine/callback.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h ../userprog/syscall.h ../userprog/errno.h \
+ ../userprog/ksyscall.h ../userprog/synchconsole.h ../machine/console.h \
+ ../threads/synch.h ../userprog/ksyscallhelper.h
+synchconsole.o: ../userprog/synchconsole.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../userprog/synchconsole.h ../lib/utility.h \
+ ../machine/callback.h ../machine/console.h ../threads/synch.h \
+ ../threads/thread.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+directory.o: ../filesys/directory.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/utility.h ../filesys/filehdr.h \
+ ../machine/disk.h ../machine/callback.h ../filesys/pbitmap.h \
+ ../lib/bitmap.h ../filesys/openfile.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../filesys/directory.h
+filehdr.o: ../filesys/filehdr.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../filesys/filehdr.h ../machine/disk.h \
+ ../lib/utility.h ../machine/callback.h ../filesys/pbitmap.h \
+ ../lib/bitmap.h ../filesys/openfile.h ../lib/sysdep.h \
+ /usr/include/c++/13/iostream /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/debug.h \
+ ../filesys/synchdisk.h ../threads/synch.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../filesys/filesys.h ../filesys/filetable.h ../lib/list.h ../lib/list.cc \
+ ../threads/main.h ../threads/kernel.h ../threads/scheduler.h \
+ ../machine/interrupt.h ../machine/stats.h ../threads/alarm.h \
+ ../machine/timer.h ../threads/stable.h ../threads/sem.h \
+ ../threads/ptable.h ../threads/pcb.h
+filesys.o: ../filesys/filesys.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../filesys/openfile.h \
+ ../lib/utility.h ../filesys/filetable.h ../filesys/filesys.h \
+ ../threads/kernel.h ../lib/debug.h ../threads/thread.h \
+ ../machine/machine.h ../machine/translate.h ../userprog/addrspace.h \
+ ../threads/scheduler.h ../lib/list.h ../lib/list.cc \
+ ../machine/interrupt.h ../machine/callback.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h ../threads/main.h
+pbitmap.o: ../filesys/pbitmap.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../filesys/pbitmap.h ../lib/bitmap.h ../lib/utility.h \
+ ../filesys/openfile.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h
+openfile.o: ../filesys/openfile.cc /usr/include/stdc-predef.h
+synchdisk.o: ../filesys/synchdisk.cc /usr/include/stdc-predef.h \
+ ../lib/copyright.h ../filesys/synchdisk.h ../machine/disk.h \
+ ../lib/utility.h ../machine/callback.h ../threads/synch.h \
+ ../threads/thread.h ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../lib/list.h \
+ ../lib/debug.h ../lib/list.cc ../threads/main.h ../threads/kernel.h \
+ ../threads/scheduler.h ../machine/interrupt.h ../machine/stats.h \
+ ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h
+post.o: ../network/post.cc /usr/include/stdc-predef.h ../lib/copyright.h \
+ ../network/post.h ../lib/utility.h ../machine/callback.h \
+ ../machine/network.h ../threads/synchlist.h ../lib/list.h ../lib/debug.h \
+ ../lib/sysdep.h /usr/include/c++/13/iostream \
+ /usr/include/c++/13/bits/requires_hosted.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++config.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/os_defines.h \
+ /usr/include/features.h /usr/include/features-time64.h \
+ /usr/include/x86_64-linux-gnu/bits/wordsize.h \
+ /usr/include/x86_64-linux-gnu/bits/timesize.h \
+ /usr/include/x86_64-linux-gnu/sys/cdefs.h \
+ /usr/include/x86_64-linux-gnu/bits/long-double.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs.h \
+ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/cpu_defines.h \
+ /usr/include/c++/13/pstl/pstl_config.h /usr/include/c++/13/ostream \
+ /usr/include/c++/13/ios /usr/include/c++/13/iosfwd \
+ /usr/include/c++/13/bits/stringfwd.h \
+ /usr/include/c++/13/bits/memoryfwd.h /usr/include/c++/13/bits/postypes.h \
+ /usr/include/c++/13/cwchar /usr/include/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn.h \
+ /usr/include/x86_64-linux-gnu/bits/floatn-common.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stddef.h \
+ /usr/lib/gcc/x86_64-linux-gnu/13/include/stdarg.h \
+ /usr/include/x86_64-linux-gnu/bits/wchar.h \
+ /usr/include/x86_64-linux-gnu/bits/types/wint_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/locale_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__locale_t.h \
+ /usr/include/c++/13/exception /usr/include/c++/13/bits/exception.h \
+ /usr/include/c++/13/bits/exception_ptr.h \
+ /usr/include/c++/13/bits/exception_defines.h \
+ /usr/include/c++/13/bits/cxxabi_init_exception.h \
+ /usr/include/c++/13/typeinfo /usr/include/c++/13/bits/hash_bytes.h \
+ /usr/include/c++/13/new /usr/include/c++/13/bits/move.h \
+ /usr/include/c++/13/type_traits \
+ /usr/include/c++/13/bits/nested_exception.h \
+ /usr/include/c++/13/bits/char_traits.h \
+ /usr/include/c++/13/bits/localefwd.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++locale.h \
+ /usr/include/c++/13/clocale /usr/include/locale.h \
+ /usr/include/x86_64-linux-gnu/bits/locale.h /usr/include/c++/13/cctype \
+ /usr/include/ctype.h /usr/include/x86_64-linux-gnu/bits/types.h \
+ /usr/include/x86_64-linux-gnu/bits/typesizes.h \
+ /usr/include/x86_64-linux-gnu/bits/time64.h \
+ /usr/include/x86_64-linux-gnu/bits/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/endianness.h \
+ /usr/include/c++/13/bits/ios_base.h /usr/include/c++/13/ext/atomicity.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/time_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h \
+ /usr/include/x86_64-linux-gnu/bits/sched.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_sched_param.h \
+ /usr/include/x86_64-linux-gnu/bits/cpu-set.h /usr/include/time.h \
+ /usr/include/x86_64-linux-gnu/bits/time.h \
+ /usr/include/x86_64-linux-gnu/bits/timex.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clock_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_tm.h \
+ /usr/include/x86_64-linux-gnu/bits/types/clockid_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/timer_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h \
+ /usr/include/x86_64-linux-gnu/bits/thread-shared-types.h \
+ /usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h \
+ /usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_mutex.h \
+ /usr/include/x86_64-linux-gnu/bits/struct_rwlock.h \
+ /usr/include/x86_64-linux-gnu/bits/setjmp.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h \
+ /usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/atomic_word.h \
+ /usr/include/x86_64-linux-gnu/sys/single_threaded.h \
+ /usr/include/c++/13/bits/locale_classes.h /usr/include/c++/13/string \
+ /usr/include/c++/13/bits/allocator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/c++allocator.h \
+ /usr/include/c++/13/bits/new_allocator.h \
+ /usr/include/c++/13/bits/functexcept.h \
+ /usr/include/c++/13/bits/cpp_type_traits.h \
+ /usr/include/c++/13/bits/ostream_insert.h \
+ /usr/include/c++/13/bits/cxxabi_forced.h \
+ /usr/include/c++/13/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/13/bits/concept_check.h \
+ /usr/include/c++/13/debug/assertions.h \
+ /usr/include/c++/13/bits/stl_iterator_base_types.h \
+ /usr/include/c++/13/bits/stl_iterator.h \
+ /usr/include/c++/13/ext/type_traits.h \
+ /usr/include/c++/13/bits/ptr_traits.h \
+ /usr/include/c++/13/bits/stl_function.h \
+ /usr/include/c++/13/backward/binders.h \
+ /usr/include/c++/13/ext/numeric_traits.h \
+ /usr/include/c++/13/bits/stl_algobase.h \
+ /usr/include/c++/13/bits/stl_pair.h /usr/include/c++/13/bits/utility.h \
+ /usr/include/c++/13/debug/debug.h \
+ /usr/include/c++/13/bits/predefined_ops.h /usr/include/c++/13/bit \
+ /usr/include/c++/13/bits/refwrap.h /usr/include/c++/13/bits/invoke.h \
+ /usr/include/c++/13/bits/range_access.h \
+ /usr/include/c++/13/initializer_list \
+ /usr/include/c++/13/bits/basic_string.h \
+ /usr/include/c++/13/ext/alloc_traits.h \
+ /usr/include/c++/13/bits/alloc_traits.h \
+ /usr/include/c++/13/bits/stl_construct.h /usr/include/c++/13/string_view \
+ /usr/include/c++/13/bits/functional_hash.h \
+ /usr/include/c++/13/bits/string_view.tcc \
+ /usr/include/c++/13/ext/string_conversions.h /usr/include/c++/13/cstdlib \
+ /usr/include/stdlib.h /usr/include/x86_64-linux-gnu/bits/waitflags.h \
+ /usr/include/x86_64-linux-gnu/bits/waitstatus.h \
+ /usr/include/x86_64-linux-gnu/sys/types.h \
+ /usr/include/x86_64-linux-gnu/bits/stdint-intn.h /usr/include/endian.h \
+ /usr/include/x86_64-linux-gnu/bits/byteswap.h \
+ /usr/include/x86_64-linux-gnu/bits/uintn-identity.h \
+ /usr/include/x86_64-linux-gnu/sys/select.h \
+ /usr/include/x86_64-linux-gnu/bits/select.h \
+ /usr/include/x86_64-linux-gnu/bits/types/sigset_t.h \
+ /usr/include/alloca.h /usr/include/x86_64-linux-gnu/bits/stdlib-float.h \
+ /usr/include/c++/13/bits/std_abs.h /usr/include/c++/13/cstdio \
+ /usr/include/stdio.h /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \
+ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \
+ /usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h \
+ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \
+ /usr/include/c++/13/cerrno /usr/include/errno.h \
+ /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/x86_64-linux-gnu/asm/errno.h \
+ /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+ /usr/include/x86_64-linux-gnu/bits/types/error_t.h \
+ /usr/include/c++/13/bits/charconv.h \
+ /usr/include/c++/13/bits/basic_string.tcc \
+ /usr/include/c++/13/bits/memory_resource.h /usr/include/c++/13/cstddef \
+ /usr/include/c++/13/bits/uses_allocator.h \
+ /usr/include/c++/13/bits/uses_allocator_args.h /usr/include/c++/13/tuple \
+ /usr/include/c++/13/bits/locale_classes.tcc \
+ /usr/include/c++/13/system_error \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/error_constants.h \
+ /usr/include/c++/13/stdexcept /usr/include/c++/13/streambuf \
+ /usr/include/c++/13/bits/streambuf.tcc \
+ /usr/include/c++/13/bits/basic_ios.h \
+ /usr/include/c++/13/bits/locale_facets.h /usr/include/c++/13/cwctype \
+ /usr/include/wctype.h /usr/include/x86_64-linux-gnu/bits/wctype-wchar.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_base.h \
+ /usr/include/c++/13/bits/streambuf_iterator.h \
+ /usr/include/x86_64-linux-gnu/c++/13/bits/ctype_inline.h \
+ /usr/include/c++/13/bits/locale_facets.tcc \
+ /usr/include/c++/13/bits/basic_ios.tcc \
+ /usr/include/c++/13/bits/ostream.tcc /usr/include/c++/13/istream \
+ /usr/include/c++/13/bits/istream.tcc /usr/include/c++/13/stdlib.h \
+ /usr/include/string.h /usr/include/strings.h ../lib/list.cc \
+ ../threads/synch.h ../threads/thread.h ../machine/machine.h \
+ ../machine/translate.h ../userprog/addrspace.h ../filesys/filesys.h \
+ ../filesys/openfile.h ../filesys/filetable.h ../threads/main.h \
+ ../threads/kernel.h ../threads/scheduler.h ../machine/interrupt.h \
+ ../machine/stats.h ../threads/alarm.h ../machine/timer.h ../lib/bitmap.h \
+ ../threads/stable.h ../threads/sem.h ../threads/ptable.h \
+ ../threads/pcb.h ../threads/synchlist.cc
+# DEPENDENCIES MUST END AT END OF FILE
+# IF YOU PUT STUFF HERE IT WILL GO AWAY
+# see make depend above
diff --git a/code/build.macosx/Makefile b/code/build.macosx/Makefile
new file mode 100644
index 0000000..c058fd7
--- /dev/null
+++ b/code/build.macosx/Makefile
@@ -0,0 +1,365 @@
+# Copyright (c) 1992-1996 The Regents of the University of California.
+# All rights reserved.  See copyright.h for copyright notice and limitation 
+# of liability and disclaimer of warranty provisions.
+#
+# This is a GNU Makefile.  It must be used with the GNU make program.
+# At UW, the GNU make program is /software/gnu/bin/make.
+# In many other places it is known as "gmake".
+# You may wish to include /software/gnu/bin/ early in your command
+# search path, so that you will be using GNU make when you type "make".
+#
+# About this Makefile:
+# --------------------
+#
+#  This Makefile is used to build the Nachos system, which includes
+#   the MIPS machine simulation and a simple operating system.
+#
+#  There is a separate Makefile, in the "test" directory, that is
+#   used to build the Nachos test programs (which run on the
+#   simulated machine).
+#
+#  There are several "build" directories, one for each type
+#   of machine in the MFCF computing environment
+#   (build.solaris, build.sunos, and build.ultrix), as well
+#   as a build directory for Linux (build.linux) and a generic
+#   build directory (build.other) for those who wish to try
+#   building Nachos on other platforms.
+#
+#  This Makefile appears to be located in all of the build directories.
+#  If you edit it in one directory, the copies in all of the other
+#  directories appear to change as well.  This is the desired behaviour,
+#  since this file is machine independent.  (The file actually lives
+#  in build.solaris, with symbolic links from the other build directories.)
+#
+#  The platform-dependent parts of make's instructions are located
+#  in the file Makefile.dep.
+#  There is a different Makefile.dep in each build directory.
+#
+#  If you are in the MFCF environment, you should not have to edit
+#  the Makefile.dep files by hand.  Any changes to the make instructions
+#  can be made in this file (see the instructions below) - they will
+#  apply no matter where you build Nachos.
+#  If you are not in the MFCF environment, e.g., if you are trying
+#  to build Nachos on Linux at home, you will probably need
+#  to edit Makefile.dep (in the appropriate build directory) to
+#  customize the make procedure to your environment.
+#
+# How to build Nachos for the first time:
+# ---------------------------------------
+#
+#   (1) Make sure than you are in the build directory for the
+#	type of machine you are logged in to (the "host" machine):
+#
+#	host type	examples		build directory
+# 	-----------	-----------		----------------
+#
+#	sparc/SunOS	cayley,napier,		build.sunos
+#	(SunOS 4.1.3)	descartes
+#
+#	sparc/Solaris	picard.math,		build.solaris
+#	(SunOS 5.x)	hermite.math,
+#			markov.math,
+#			hypatia.math,
+#			hume.math
+#
+#	mips/ULTRIX	cantor.math		build.ultrix
+#	(ULTRIX 4.2)	noether.math
+#
+#	If you are not sure what type of machine you are on,
+#	try the command "uname -a".  
+#
+#   (2) Type "make depend"
+#		- this computes file dependencies and records them
+#			at the end of the file Makefile.dep in 
+#			your build directory.  Have a look...
+#
+#   (3) Type "make nachos"  (or just "make").
+#               - make echos the commands it is executing, so that
+#			you can observe its progress.  When the
+#			build is finished, you should have an
+#			executable "nachos" in the build directory.
+#
+#   (4) There is no 4th step.  You are done.  Try running "./nachos -u".
+#
+#
+# How to Re-build Nachos after you have changed the code:
+#--------------------------------------------------------
+#
+#     - The Nachos source code is located in the code subdirectories:
+#	  threads, userprog, filesys, network, and lib.  You may
+#         change the files in any of these directories, and you can
+#         add new files and/or remove files. The "machine" subdirectory
+#	  contains the hardware simulation (which is also part of
+#	  Nachos.  You may look at it, but
+#	  you may not change it, except as noted in machine/machine.h
+#     - When you want to re-make Nachos, always do it in the
+#	  "build" directory that is appropriate for the machine
+#	  type that you are running on.  
+#	DO NOT TRY TO MAKE NACHOS IN THE SOURCE CODE DIRECTORIES.
+#
+#     - IF all you have done is changed C++ code in existing files
+#	(since the last time you made Nachos in this build directory),
+#	THEN all you need to do to re-make Nachos is to type
+#
+#		"make nachos"
+#
+#	in the build directory.
+#
+#     - IF you have done any of the following since the last build in
+#	  this directory:
+#		added new .cc files or new .h files
+#		added or deleted #include's from existing files
+#	THEN
+#		you must do
+#		"make depend"
+#		followed by
+#		"make nachos"
+#
+#	in the build directory.
+#
+#       Note that is is always safe to do "make depend" followed by
+# 	"make nachos", so if you are not sure what changes you have
+#	made, do "make depend".
+#
+#     - IF you have added new files (.cc or .h) since the last build,
+#	you should edit this Makefile before running "make depend"
+# 	and "make nachos".
+
+#	For new .h files, simply update the appropriate "_H" list below.
+#       For example, if you create a file called
+#       "bigfile.h" in the filesys subdirectory, you should add
+#       "../filesys/bigfile.h" to FILESYS_H, which is defined below
+
+#	For new .cc files, update the appropriate "_C" and "_O" lists.
+#       For example, if you create a file called "filetable.cc" in
+#	the directory "userprog", you should add
+#	"../userprog/filetable.cc" to USERPROG_C,
+#       and you should add "filetable.o" to USERPROG_O.
+#       Note that the entry in the "_C" list includes the subdirectory
+#	name, while the entry on the "_O" list does not.
+#
+#  Some Important Notes:
+#  ---------------------
+#
+#       *  You can clean up all of the .o and other files left behind
+#	   by make by typeing "make clean" in the build directory.
+#	*  You can clean up .o and other files, as well as the nachos
+#	   executable, DISK, core, SOCKET, and other files by typing
+#	   make "distclean"
+#
+#	These are good ways to save space, but the next build that
+#	you do after cleaning will take longer than usual, since
+#	much of the stuff you cleaned will need to be rebuilt.
+#
+#       *  When you build Nachos on an ULTRIX machine (in build.ultrix),
+#	   you will get lots of warning messages like this:
+#
+#	openfile.o: does not have gp tables for all it's sectons
+#
+#	   from the loader.  Ignore them.  Or better yet, figure out
+#	   how to make them go away.
+#
+#  The Most Important Note:
+#  -----------------------
+#
+#	* If "make" is behaving strangely and you cannot figure out
+#	why, you should REBUILD the program FROM SCRATCH.
+#	Yes, it is slow.
+#	But, there are lots of little things that can go wrong, especially
+#	with all of these different types of machines available.
+#	Rebuilding from scratch at least gives you a known starting
+#	place.  To rebuild from scratch, go to the appropriate
+#	build directory and do:
+#	
+#		make distclean
+#		make depend
+#		make nachos
+#
+################################################################
+#  READ THIS:   CONFIGURING NACHOS
+#
+# Change DEFINES (below) to
+#   DEFINES = -DUSE_TLB -DFILESYS_STUB
+# if you want the simulated machine to use its TLB
+#
+# If you want to use the real Nachos file system (based on
+# the simulated disk), rather than the stub, remove
+# the -DFILESYS_STUB from DEFINES.
+#
+# There is a a fix to the MIPS simulator to enable it to properly
+# handle unaligned data access.  This fix is enabled by the addition
+# of "-DSIM_FIX" to the DEFINES.  This should be enabled by default
+# and eventually will not require the symbol definition
+################################################################
+DEFINES =  -DFILESYS_STUB -DRDATA -DSIM_FIX
+
+
+#####################################################################
+#
+# You might want to play with the CFLAGS, but if you use -O it may
+# break the thread system.  You might want to use -fno-inline if
+# you need to call some inline functions from the debugger.
+
+CFLAGS = -g -Wall -fwritable-strings $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED
+LDFLAGS =
+
+#####################################################################
+CPP=/lib/cpp
+CC = g++
+LD = g++
+AS = as
+RM = /bin/rm
+
+INCPATH = -I../network -I../filesys -I../userprog -I../threads -I../machine -I../lib
+
+PROGRAM = nachos
+
+#
+# Edit these lists as if you add files to the source directories.
+# See the instructions at the top of the file for more information.
+#
+
+LIB_H = ../lib/bitmap.h\
+	../lib/copyright.h\
+	../lib/debug.h\
+	../lib/hash.h\
+	../lib/libtest.h\
+	../lib/list.h\
+	../lib/sysdep.h\
+	../lib/utility.h
+
+LIB_C = ../lib/bitmap.cc\
+	../lib/debug.cc\
+	../lib/hash.cc\
+	../lib/libtest.cc\
+	../lib/list.cc\
+	../lib/sysdep.cc
+
+LIB_O = bitmap.o debug.o libtest.o sysdep.o
+
+
+MACHINE_H = ../machine/callback.h\
+	../machine/interrupt.h\
+	../machine/stats.h\
+	../machine/timer.h\
+	../machine/console.h\
+	../machine/machine.h\
+	../machine/mipssim.h\
+	../machine/translate.h\
+	../machine/network.h\
+	../machine/disk.h
+
+MACHINE_C = ../machine/interrupt.cc\
+	../machine/stats.cc\
+	../machine/timer.cc\
+	../machine/console.cc\
+	../machine/machine.cc\
+	../machine/mipssim.cc\
+	../machine/translate.cc\
+	../machine/network.cc\
+	../machine/disk.cc
+
+MACHINE_O = interrupt.o stats.o timer.o console.o machine.o mipssim.o\
+	translate.o network.o disk.o
+
+THREAD_H = ../threads/alarm.h\
+	../threads/kernel.h\
+	../threads/main.h\
+	../threads/scheduler.h\
+	../threads/switch.h\
+	../threads/synch.h\
+	../threads/synchlist.h\
+	../threads/thread.h
+
+THREAD_C = ../threads/alarm.cc\
+	../threads/kernel.cc\
+	../threads/main.cc\
+	../threads/scheduler.cc\
+	../threads/synch.cc\
+	../threads/synchlist.cc\
+	../threads/thread.cc
+
+THREAD_O = alarm.o kernel.o main.o scheduler.o synch.o thread.o
+
+USERPROG_H = ../userprog/addrspace.h\
+	../userprog/syscall.h\
+	../userprog/synchconsole.h\
+	../userprog/noff.h
+
+USERPROG_C = ../userprog/addrspace.cc\
+	../userprog/exception.cc\
+	../userprog/synchconsole.cc
+
+USERPROG_O = addrspace.o exception.o synchconsole.o
+
+FILESYS_H =../filesys/directory.h \
+	../filesys/filehdr.h\
+	../filesys/filesys.h \
+	../filesys/openfile.h\
+	../filesys/pbitmap.h\
+	../filesys/synchdisk.h
+
+FILESYS_C =../filesys/directory.cc\
+	../filesys/filehdr.cc\
+	../filesys/filesys.cc\
+	../filesys/pbitmap.cc\
+	../filesys/openfile.cc\
+	../filesys/synchdisk.cc\
+
+FILESYS_O =directory.o filehdr.o filesys.o pbitmap.o openfile.o synchdisk.o
+
+NETWORK_H = ../network/post.h
+
+NETWORK_C = ../network/post.cc
+
+NETWORK_O = post.o
+
+##################################################################
+#  You probably don't want to change anything below this point in
+#  the file unless you are comfortable with GNU make and know what
+#  you are doing...
+##################################################################
+
+THREAD_S = ../threads/switch.s
+
+HFILES = $(LIB_H) $(MACHINE_H) $(THREAD_H) $(USERPROG_H) $(FILESYS_H) $(NETWORK_H)
+CFILES = $(LIB_C) $(MACHINE_C) $(THREAD_C) $(USERPROG_C) $(FILESYS_C) $(NETWORK_C)
+
+C_OFILES = $(LIB_O) $(MACHINE_O) $(THREAD_O) $(USERPROG_O) $(FILESYS_O) $(NETWORK_O)
+
+S_OFILES = switch.o
+OFILES = $(C_OFILES) $(S_OFILES)
+
+$(PROGRAM): $(OFILES)
+	$(LD) $(OFILES) $(LDFLAGS) -o $(PROGRAM)
+
+$(C_OFILES): %.o:
+	$(CC) $(CFLAGS) -c $<
+
+switch.o: ../threads/switch.s
+	$(CPP) $(CPP_AS_FLAGS) -P $(INCPATH) $(HOSTCFLAGS) ../threads/switch.s > swtch.s
+	$(AS) -o switch.o swtch.s
+
+depend: $(CFILES) $(HFILES)
+	$(CC) $(INCPATH) $(DEFINES) $(HOSTCFLAGS) -DCHANGED -M $(CFILES) > makedep
+	@echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@echo 'q' >>eddep
+	ed - Makefile.dep < eddep
+	rm eddep makedep 
+	@echo '# DEPENDENCIES MUST END AT END OF FILE' >> Makefile.dep
+	@echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >> Makefile.dep
+	@echo '# see make depend above' >> Makefile.dep
+
+clean:
+	$(RM) -f $(OFILES)
+	$(RM) -f swtch.s
+
+distclean: clean
+	$(RM) -f $(PROGRAM)
+	$(RM) -f DISK_?
+	$(RM) -f core
+	$(RM) -f SOCKET_?
+
+include Makefile.dep
diff --git a/code/build.macosx/Makefile.dep b/code/build.macosx/Makefile.dep
new file mode 100644
index 0000000..952a39f
--- /dev/null
+++ b/code/build.macosx/Makefile.dep
@@ -0,0 +1,18 @@
+##################################################################
+#  Machine Dependencies - this file is included automatically
+#     into the main Makefile
+#
+##################################################################
+
+HOSTCFLAGS = -DHOST_IS_BIG_ENDIAN -DPowerPC -DBSD -DAIX -DApplePowerPC
+CPP_AS_FLAGS = -D_ASM
+CPP = cpp
+
+#-----------------------------------------------------------------
+# Do not put anything below this point - it will be destroyed by
+# "make depend"
+#
+# DO NOT DELETE THIS LINE -- make depend uses it
+# DEPENDENCIES MUST END AT END OF FILE
+# IF YOU PUT STUFF HERE IT WILL GO AWAY
+# see make depend above
diff --git a/code/filesys/directory.cc b/code/filesys/directory.cc
new file mode 100644
index 0000000..e653774
--- /dev/null
+++ b/code/filesys/directory.cc
@@ -0,0 +1,171 @@
+// directory.cc
+//	Routines to manage a directory of file names.
+//
+//	The directory is a table of fixed length entries; each
+//	entry represents a single file, and contains the file name,
+//	and the location of the file header on disk.  The fixed size
+//	of each directory entry means that we have the restriction
+//	of a fixed maximum size for file names.
+//
+//	The constructor initializes an empty directory of a certain size;
+//	we use ReadFrom/WriteBack to fetch the contents of the directory
+//	from disk, and to write back any modifications back to disk.
+//
+//	Also, this implementation has the restriction that the size
+//	of the directory cannot expand.  In other words, once all the
+//	entries in the directory are used, no more files can be created.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "utility.h"
+#include "filehdr.h"
+#include "directory.h"
+
+//----------------------------------------------------------------------
+// Directory::Directory
+// 	Initialize a directory; initially, the directory is completely
+//	empty.  If the disk is being formatted, an empty directory
+//	is all we need, but otherwise, we need to call FetchFrom in order
+//	to initialize it from disk.
+//
+//	"size" is the number of entries in the directory
+//----------------------------------------------------------------------
+
+Directory::Directory(int size) {
+    table = new DirectoryEntry[size];
+    tableSize = size;
+    for (int i = 0; i < tableSize; i++) table[i].inUse = FALSE;
+}
+
+//----------------------------------------------------------------------
+// Directory::~Directory
+// 	De-allocate directory data structure.
+//----------------------------------------------------------------------
+
+Directory::~Directory() { delete[] table; }
+
+//----------------------------------------------------------------------
+// Directory::FetchFrom
+// 	Read the contents of the directory from disk.
+//
+//	"file" -- file containing the directory contents
+//----------------------------------------------------------------------
+
+void Directory::FetchFrom(OpenFile *file) {
+    (void)file->ReadAt((char *)table, tableSize * sizeof(DirectoryEntry), 0);
+}
+
+//----------------------------------------------------------------------
+// Directory::WriteBack
+// 	Write any modifications to the directory back to disk
+//
+//	"file" -- file to contain the new directory contents
+//----------------------------------------------------------------------
+
+void Directory::WriteBack(OpenFile *file) {
+    (void)file->WriteAt((char *)table, tableSize * sizeof(DirectoryEntry), 0);
+}
+
+//----------------------------------------------------------------------
+// Directory::FindIndex
+// 	Look up file name in directory, and return its location in the table of
+//	directory entries.  Return -1 if the name isn't in the directory.
+//
+//	"name" -- the file name to look up
+//----------------------------------------------------------------------
+
+int Directory::FindIndex(char *name) {
+    for (int i = 0; i < tableSize; i++)
+        if (table[i].inUse && !strncmp(table[i].name, name, FileNameMaxLen))
+            return i;
+    return -1;  // name not in directory
+}
+
+//----------------------------------------------------------------------
+// Directory::Find
+// 	Look up file name in directory, and return the disk sector number
+//	where the file's header is stored. Return -1 if the name isn't
+//	in the directory.
+//
+//	"name" -- the file name to look up
+//----------------------------------------------------------------------
+
+int Directory::Find(char *name) {
+    int i = FindIndex(name);
+
+    if (i != -1) return table[i].sector;
+    return -1;
+}
+
+//----------------------------------------------------------------------
+// Directory::Add
+// 	Add a file into the directory.  Return TRUE if successful;
+//	return FALSE if the file name is already in the directory, or if
+//	the directory is completely full, and has no more space for
+//	additional file names.
+//
+//	"name" -- the name of the file being added
+//	"newSector" -- the disk sector containing the added file's header
+//----------------------------------------------------------------------
+
+bool Directory::Add(char *name, int newSector) {
+    if (FindIndex(name) != -1) return FALSE;
+
+    for (int i = 0; i < tableSize; i++)
+        if (!table[i].inUse) {
+            table[i].inUse = TRUE;
+            strncpy(table[i].name, name, FileNameMaxLen);
+            table[i].sector = newSector;
+            return TRUE;
+        }
+    return FALSE;  // no space.  Fix when we have extensible files.
+}
+
+//----------------------------------------------------------------------
+// Directory::Remove
+// 	Remove a file name from the directory.  Return TRUE if successful;
+//	return FALSE if the file isn't in the directory.
+//
+//	"name" -- the file name to be removed
+//----------------------------------------------------------------------
+
+bool Directory::Remove(char *name) {
+    int i = FindIndex(name);
+
+    if (i == -1) return FALSE;  // name not in directory
+    table[i].inUse = FALSE;
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// Directory::List
+// 	List all the file names in the directory.
+//----------------------------------------------------------------------
+
+void Directory::List() {
+    for (int i = 0; i < tableSize; i++)
+        if (table[i].inUse) printf("%s\n", table[i].name);
+}
+
+//----------------------------------------------------------------------
+// Directory::Print
+// 	List all the file names in the directory, their FileHeader locations,
+//	and the contents of each file.  For debugging.
+//----------------------------------------------------------------------
+
+void Directory::Print() {
+    FileHeader *hdr = new FileHeader;
+
+    printf("Directory contents:\n");
+    for (int i = 0; i < tableSize; i++)
+        if (table[i].inUse) {
+            printf("Name: %s, Sector: %d\n", table[i].name, table[i].sector);
+            hdr->FetchFrom(table[i].sector);
+            hdr->Print();
+        }
+    printf("\n");
+    delete hdr;
+}
diff --git a/code/filesys/directory.h b/code/filesys/directory.h
new file mode 100644
index 0000000..1b13aeb
--- /dev/null
+++ b/code/filesys/directory.h
@@ -0,0 +1,84 @@
+// directory.h
+//	Data structures to manage a UNIX-like directory of file names.
+//
+//      A directory is a table of pairs: <file name, sector #>,
+//	giving the name of each file in the directory, and
+//	where to find its file header (the data structure describing
+//	where to find the file's data blocks) on disk.
+//
+//      We assume mutual exclusion is provided by the caller.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+
+#ifndef DIRECTORY_H
+#define DIRECTORY_H
+
+#include "openfile.h"
+
+#define FileNameMaxLen \
+    9  // for simplicity, we assume
+       // file names are <= 9 characters long
+
+// The following class defines a "directory entry", representing a file
+// in the directory.  Each entry gives the name of the file, and where
+// the file's header is to be found on disk.
+//
+// Internal data structures kept public so that Directory operations can
+// access them directly.
+
+class DirectoryEntry {
+   public:
+    bool inUse;                     // Is this directory entry in use?
+    int sector;                     // Location on disk to find the
+                                    //   FileHeader for this file
+    char name[FileNameMaxLen + 1];  // Text name for file, with +1 for
+                                    // the trailing '\0'
+};
+
+// The following class defines a UNIX-like "directory".  Each entry in
+// the directory describes a file, and where to find it on disk.
+//
+// The directory data structure can be stored in memory, or on disk.
+// When it is on disk, it is stored as a regular Nachos file.
+//
+// The constructor initializes a directory structure in memory; the
+// FetchFrom/WriteBack operations shuffle the directory information
+// from/to disk.
+
+class Directory {
+   public:
+    Directory(int size);  // Initialize an empty directory
+                          // with space for "size" files
+    ~Directory();         // De-allocate the directory
+
+    void FetchFrom(OpenFile *file);  // Init directory contents from disk
+    void WriteBack(OpenFile *file);  // Write modifications to
+                                     // directory contents back to disk
+
+    int Find(char *name);  // Find the sector number of the
+                           // FileHeader for file: "name"
+
+    bool Add(char *name, int newSector);  // Add a file name into the directory
+
+    bool Remove(char *name);  // Remove a file from the directory
+
+    void List();   // Print the names of all the files
+                   //  in the directory
+    void Print();  // Verbose print of the contents
+                   //  of the directory -- all the file
+                   //  names and their contents.
+
+   private:
+    int tableSize;          // Number of directory entries
+    DirectoryEntry *table;  // Table of pairs:
+                            // <file name, file header location>
+
+    int FindIndex(char *name);  // Find the index into the directory
+                                //  table corresponding to "name"
+};
+
+#endif  // DIRECTORY_H
diff --git a/code/filesys/filehdr.cc b/code/filesys/filehdr.cc
new file mode 100644
index 0000000..b66ea57
--- /dev/null
+++ b/code/filesys/filehdr.cc
@@ -0,0 +1,138 @@
+// filehdr.cc
+//	Routines for managing the disk file header (in UNIX, this
+//	would be called the i-node).
+//
+//	The file header is used to locate where on disk the
+//	file's data is stored.  We implement this as a fixed size
+//	table of pointers -- each entry in the table points to the
+//	disk sector containing that portion of the file data
+//	(in other words, there are no indirect or doubly indirect
+//	blocks). The table size is chosen so that the file header
+//	will be just big enough to fit in one disk sector,
+//
+//      Unlike in a real system, we do not keep track of file permissions,
+//	ownership, last modification date, etc., in the file header.
+//
+//	A file header can be initialized in two ways:
+//	   for a new file, by modifying the in-memory data structure
+//	     to point to the newly allocated data blocks
+//	   for a file already on disk, by reading the file header from disk
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+
+#include "filehdr.h"
+#include "debug.h"
+#include "synchdisk.h"
+#include "main.h"
+
+//----------------------------------------------------------------------
+// FileHeader::Allocate
+// 	Initialize a fresh file header for a newly created file.
+//	Allocate data blocks for the file out of the map of free disk blocks.
+//	Return FALSE if there are not enough free blocks to accomodate
+//	the new file.
+//
+//	"freeMap" is the bit map of free disk sectors
+//	"fileSize" is the bit map of free disk sectors
+//----------------------------------------------------------------------
+
+bool FileHeader::Allocate(PersistentBitmap *freeMap, int fileSize) {
+    numBytes = fileSize;
+    numSectors = divRoundUp(fileSize, SectorSize);
+    if (freeMap->NumClear() < numSectors) return FALSE;  // not enough space
+
+    for (int i = 0; i < numSectors; i++) {
+        dataSectors[i] = freeMap->FindAndSet();
+        // since we checked that there was enough free space,
+        // we expect this to succeed
+        ASSERT(dataSectors[i] >= 0);
+    }
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// FileHeader::Deallocate
+// 	De-allocate all the space allocated for data blocks for this file.
+//
+//	"freeMap" is the bit map of free disk sectors
+//----------------------------------------------------------------------
+
+void FileHeader::Deallocate(PersistentBitmap *freeMap) {
+    for (int i = 0; i < numSectors; i++) {
+        ASSERT(freeMap->Test((int)dataSectors[i]));  // ought to be marked!
+        freeMap->Clear((int)dataSectors[i]);
+    }
+}
+
+//----------------------------------------------------------------------
+// FileHeader::FetchFrom
+// 	Fetch contents of file header from disk.
+//
+//	"sector" is the disk sector containing the file header
+//----------------------------------------------------------------------
+
+void FileHeader::FetchFrom(int sector) {
+    kernel->synchDisk->ReadSector(sector, (char *)this);
+}
+
+//----------------------------------------------------------------------
+// FileHeader::WriteBack
+// 	Write the modified contents of the file header back to disk.
+//
+//	"sector" is the disk sector to contain the file header
+//----------------------------------------------------------------------
+
+void FileHeader::WriteBack(int sector) {
+    kernel->synchDisk->WriteSector(sector, (char *)this);
+}
+
+//----------------------------------------------------------------------
+// FileHeader::ByteToSector
+// 	Return which disk sector is storing a particular byte within the file.
+//      This is essentially a translation from a virtual address (the
+//	offset in the file) to a physical address (the sector where the
+//	data at the offset is stored).
+//
+//	"offset" is the location within the file of the byte in question
+//----------------------------------------------------------------------
+
+int FileHeader::ByteToSector(int offset) {
+    return (dataSectors[offset / SectorSize]);
+}
+
+//----------------------------------------------------------------------
+// FileHeader::FileLength
+// 	Return the number of bytes in the file.
+//----------------------------------------------------------------------
+
+int FileHeader::FileLength() { return numBytes; }
+
+//----------------------------------------------------------------------
+// FileHeader::Print
+// 	Print the contents of the file header, and the contents of all
+//	the data blocks pointed to by the file header.
+//----------------------------------------------------------------------
+
+void FileHeader::Print() {
+    int i, j, k;
+    char *data = new char[SectorSize];
+
+    printf("FileHeader contents.  File size: %d.  File blocks:\n", numBytes);
+    for (i = 0; i < numSectors; i++) printf("%d ", dataSectors[i]);
+    printf("\nFile contents:\n");
+    for (i = k = 0; i < numSectors; i++) {
+        kernel->synchDisk->ReadSector(dataSectors[i], data);
+        for (j = 0; (j < SectorSize) && (k < numBytes); j++, k++) {
+            if ('\040' <= data[j] && data[j] <= '\176')  // isprint(data[j])
+                printf("%c", data[j]);
+            else
+                printf("\\%x", (unsigned char)data[j]);
+        }
+        printf("\n");
+    }
+    delete[] data;
+}
diff --git a/code/filesys/filehdr.h b/code/filesys/filehdr.h
new file mode 100644
index 0000000..415fa3a
--- /dev/null
+++ b/code/filesys/filehdr.h
@@ -0,0 +1,67 @@
+// filehdr.h
+//	Data structures for managing a disk file header.
+//
+//	A file header describes where on disk to find the data in a file,
+//	along with other information about the file (for instance, its
+//	length, owner, etc.)
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+
+#ifndef FILEHDR_H
+#define FILEHDR_H
+
+#include "disk.h"
+#include "pbitmap.h"
+
+#define NumDirect ((SectorSize - 2 * sizeof(int)) / sizeof(int))
+#define MaxFileSize (NumDirect * SectorSize)
+
+// The following class defines the Nachos "file header" (in UNIX terms,
+// the "i-node"), describing where on disk to find all of the data in the file.
+// The file header is organized as a simple table of pointers to
+// data blocks.
+//
+// The file header data structure can be stored in memory or on disk.
+// When it is on disk, it is stored in a single sector -- this means
+// that we assume the size of this data structure to be the same
+// as one disk sector.  Without indirect addressing, this
+// limits the maximum file length to just under 4K bytes.
+//
+// There is no constructor; rather the file header can be initialized
+// by allocating blocks for the file (if it is a new file), or by
+// reading it from disk.
+
+class FileHeader {
+   public:
+    bool Allocate(PersistentBitmap *bitMap,
+                  int fileSize);                // Initialize a file header,
+                                                //  including allocating space
+                                                //  on disk for the file data
+    void Deallocate(PersistentBitmap *bitMap);  // De-allocate this file's
+                                                //  data blocks
+
+    void FetchFrom(int sectorNumber);  // Initialize file header from disk
+    void WriteBack(int sectorNumber);  // Write modifications to file header
+                                       //  back to disk
+
+    int ByteToSector(int offset);  // Convert a byte offset into the file
+                                   // to the disk sector containing
+                                   // the byte
+
+    int FileLength();  // Return the length of the file
+                       // in bytes
+
+    void Print();  // Print the contents of the file.
+
+   private:
+    int numBytes;                // Number of bytes in the file
+    int numSectors;              // Number of data sectors in the file
+    int dataSectors[NumDirect];  // Disk sector numbers for each data
+                                 // block in the file
+};
+
+#endif  // FILEHDR_H
diff --git a/code/filesys/filesys.cc b/code/filesys/filesys.cc
new file mode 100644
index 0000000..413622e
--- /dev/null
+++ b/code/filesys/filesys.cc
@@ -0,0 +1,348 @@
+// filesys.cc
+//	Routines to manage the overall operation of the file system.
+//	Implements routines to map from textual file names to files.
+//
+//	Each file in the file system has:
+//	   A file header, stored in a sector on disk
+//		(the size of the file header data structure is arranged
+//		to be precisely the size of 1 disk sector)
+//	   A number of data blocks
+//	   An entry in the file system directory
+//
+// 	The file system consists of several data structures:
+//	   A bitmap of free disk sectors (cf. bitmap.h)
+//	   A directory of file names and file headers
+//
+//      Both the bitmap and the directory are represented as normal
+//	files.  Their file headers are located in specific sectors
+//	(sector 0 and sector 1), so that the file system can find them
+//	on bootup.
+//
+//	The file system assumes that the bitmap and directory files are
+//	kept "open" continuously while Nachos is running.
+//
+//	For those operations (such as Create, Remove) that modify the
+//	directory and/or bitmap, if the operation succeeds, the changes
+//	are written immediately back to disk (the two files are kept
+//	open during all this time).  If the operation fails, and we have
+//	modified part of the directory and/or bitmap, we simply discard
+//	the changed version, without writing it back to disk.
+//
+// 	Our implementation at this point has the following restrictions:
+//
+//	   there is no synchronization for concurrent accesses
+//	   files have a fixed size, set when the file is created
+//	   files cannot be bigger than about 3KB in size
+//	   there is no hierarchical directory structure, and only a limited
+//	     number of files can be added to the system
+//	   there is no attempt to make the system robust to failures
+//	    (if Nachos exits in the middle of an operation that modifies
+//	    the file system, it may corrupt the disk)
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+#ifndef FILESYS_STUB
+
+#include "copyright.h"
+#include "debug.h"
+#include "disk.h"
+#include "pbitmap.h"
+#include "directory.h"
+#include "filehdr.h"
+#include "filesys.h"
+
+// Sectors containing the file headers for the bitmap of free sectors,
+// and the directory of files.  These file headers are placed in well-known
+// sectors, so that they can be located on boot-up.
+#define FreeMapSector 0
+#define DirectorySector 1
+
+// Initial file sizes for the bitmap and directory; until the file system
+// supports extensible files, the directory size sets the maximum number
+// of files that can be loaded onto the disk.
+#define FreeMapFileSize (NumSectors / BitsInByte)
+#define NumDirEntries 10
+#define DirectoryFileSize (sizeof(DirectoryEntry) * NumDirEntries)
+
+//----------------------------------------------------------------------
+// FileSystem::FileSystem
+// 	Initialize the file system.  If format = TRUE, the disk has
+//	nothing on it, and we need to initialize the disk to contain
+//	an empty directory, and a bitmap of free sectors (with almost but
+//	not all of the sectors marked as free).
+//
+//	If format = FALSE, we just have to open the files
+//	representing the bitmap and the directory.
+//
+//	"format" -- should we initialize the disk?
+//----------------------------------------------------------------------
+
+FileSystem::FileSystem(bool format) {
+    DEBUG(dbgFile, "Initializing the file system.");
+    if (format) {
+        PersistentBitmap *freeMap = new PersistentBitmap(NumSectors);
+        Directory *directory = new Directory(NumDirEntries);
+        FileHeader *mapHdr = new FileHeader;
+        FileHeader *dirHdr = new FileHeader;
+
+        DEBUG(dbgFile, "Formatting the file system.");
+
+        // First, allocate space for FileHeaders for the directory and bitmap
+        // (make sure no one else grabs these!)
+        freeMap->Mark(FreeMapSector);
+        freeMap->Mark(DirectorySector);
+
+        // Second, allocate space for the data blocks containing the contents
+        // of the directory and bitmap files.  There better be enough space!
+
+        ASSERT(mapHdr->Allocate(freeMap, FreeMapFileSize));
+        ASSERT(dirHdr->Allocate(freeMap, DirectoryFileSize));
+
+        // Flush the bitmap and directory FileHeaders back to disk
+        // We need to do this before we can "Open" the file, since open
+        // reads the file header off of disk (and currently the disk has garbage
+        // on it!).
+
+        DEBUG(dbgFile, "Writing headers back to disk.");
+        mapHdr->WriteBack(FreeMapSector);
+        dirHdr->WriteBack(DirectorySector);
+
+        // OK to open the bitmap and directory files now
+        // The file system operations assume these two files are left open
+        // while Nachos is running.
+
+        freeMapFile = new OpenFile(FreeMapSector);
+        directoryFile = new OpenFile(DirectorySector);
+
+        // Once we have the files "open", we can write the initial version
+        // of each file back to disk.  The directory at this point is completely
+        // empty; but the bitmap has been changed to reflect the fact that
+        // sectors on the disk have been allocated for the file headers and
+        // to hold the file data for the directory and bitmap.
+
+        DEBUG(dbgFile, "Writing bitmap and directory back to disk.");
+        freeMap->WriteBack(freeMapFile);  // flush changes to disk
+        directory->WriteBack(directoryFile);
+
+        if (debug->IsEnabled('f')) {
+            freeMap->Print();
+            directory->Print();
+        }
+        delete freeMap;
+        delete directory;
+        delete mapHdr;
+        delete dirHdr;
+    } else {
+        // if we are not formatting the disk, just open the files representing
+        // the bitmap and directory; these are left open while Nachos is running
+        freeMapFile = new OpenFile(FreeMapSector);
+        directoryFile = new OpenFile(DirectorySector);
+    }
+}
+
+//----------------------------------------------------------------------
+// FileSystem::Create
+// 	Create a file in the Nachos file system (similar to UNIX create).
+//	Since we can't increase the size of files dynamically, we have
+//	to give Create the initial size of the file.
+//
+//	The steps to create a file are:
+//	  Make sure the file doesn't already exist
+//        Allocate a sector for the file header
+// 	  Allocate space on disk for the data blocks for the file
+//	  Add the name to the directory
+//	  Store the new file header on disk
+//	  Flush the changes to the bitmap and the directory back to disk
+//
+//	Return TRUE if everything goes ok, otherwise, return FALSE.
+//
+// 	Create fails if:
+//   		file is already in directory
+//	 	no free space for file header
+//	 	no free entry for file in directory
+//	 	no free space for data blocks for the file
+//
+// 	Note that this implementation assumes there is no concurrent access
+//	to the file system!
+//
+//	"name" -- name of file to be created
+//	"initialSize" -- size of file to be created
+//----------------------------------------------------------------------
+
+bool FileSystem::Create(char *name, int initialSize) {
+    Directory *directory;
+    PersistentBitmap *freeMap;
+    FileHeader *hdr;
+    int sector;
+    bool success;
+
+    DEBUG(dbgFile, "Creating file " << name << " size " << initialSize);
+
+    directory = new Directory(NumDirEntries);
+    directory->FetchFrom(directoryFile);
+
+    if (directory->Find(name) != -1)
+        success = FALSE;  // file is already in directory
+    else {
+        freeMap = new PersistentBitmap(freeMapFile, NumSectors);
+        sector =
+            freeMap->FindAndSet();  // find a sector to hold the file header
+        if (sector == -1)
+            success = FALSE;  // no free block for file header
+        else if (!directory->Add(name, sector))
+            success = FALSE;  // no space in directory
+        else {
+            hdr = new FileHeader;
+            if (!hdr->Allocate(freeMap, initialSize))
+                success = FALSE;  // no space on disk for data
+            else {
+                success = TRUE;
+                // everthing worked, flush all changes back to disk
+                hdr->WriteBack(sector);
+                directory->WriteBack(directoryFile);
+                freeMap->WriteBack(freeMapFile);
+            }
+            delete hdr;
+        }
+        delete freeMap;
+    }
+    delete directory;
+    return success;
+}
+
+//----------------------------------------------------------------------
+// FileSystem::Open
+// 	Open a file for reading and writing.
+//	To open a file:
+//	  Find the location of the file's header, using the directory
+//	  Bring the header into memory
+//
+//	"name" -- the text name of the file to be opened
+//----------------------------------------------------------------------
+
+OpenFile *FileSystem::Open(char *name) {
+    Directory *directory = new Directory(NumDirEntries);
+    OpenFile *openFile = NULL;
+    int sector;
+
+    DEBUG(dbgFile, "Opening file" << name);
+    directory->FetchFrom(directoryFile);
+    sector = directory->Find(name);
+    if (sector >= 0)
+        openFile = new OpenFile(sector);  // name was found in directory
+    delete directory;
+    return openFile;  // return NULL if not found
+}
+
+//----------------------------------------------------------------------
+// FileSystem::Remove
+// 	Delete a file from the file system.  This requires:
+//	    Remove it from the directory
+//	    Delete the space for its header
+//	    Delete the space for its data blocks
+//	    Write changes to directory, bitmap back to disk
+//
+//	Return TRUE if the file was deleted, FALSE if the file wasn't
+//	in the file system.
+//
+//	"name" -- the text name of the file to be removed
+//----------------------------------------------------------------------
+
+bool FileSystem::Remove(char *name) {
+    Directory *directory;
+    PersistentBitmap *freeMap;
+    FileHeader *fileHdr;
+    int sector;
+
+    directory = new Directory(NumDirEntries);
+    directory->FetchFrom(directoryFile);
+    sector = directory->Find(name);
+    if (sector == -1) {
+        delete directory;
+        return FALSE;  // file not found
+    }
+    fileHdr = new FileHeader;
+    fileHdr->FetchFrom(sector);
+
+    freeMap = new PersistentBitmap(freeMapFile, NumSectors);
+
+    fileHdr->Deallocate(freeMap);  // remove data blocks
+    freeMap->Clear(sector);        // remove header block
+    directory->Remove(name);
+
+    freeMap->WriteBack(freeMapFile);      // flush to disk
+    directory->WriteBack(directoryFile);  // flush to disk
+    delete fileHdr;
+    delete directory;
+    delete freeMap;
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// FileSystem::List
+// 	List all the files in the file system directory.
+//----------------------------------------------------------------------
+
+void FileSystem::List() {
+    Directory *directory = new Directory(NumDirEntries);
+
+    directory->FetchFrom(directoryFile);
+    directory->List();
+    delete directory;
+}
+
+//----------------------------------------------------------------------
+// FileSystem::Print
+// 	Print everything about the file system:
+//	  the contents of the bitmap
+//	  the contents of the directory
+//	  for each file in the directory,
+//	      the contents of the file header
+//	      the data in the file
+//----------------------------------------------------------------------
+
+void FileSystem::Print() {
+    FileHeader *bitHdr = new FileHeader;
+    FileHeader *dirHdr = new FileHeader;
+    PersistentBitmap *freeMap = new PersistentBitmap(freeMapFile, NumSectors);
+    Directory *directory = new Directory(NumDirEntries);
+
+    printf("Bit map file header:\n");
+    bitHdr->FetchFrom(FreeMapSector);
+    bitHdr->Print();
+
+    printf("Directory file header:\n");
+    dirHdr->FetchFrom(DirectorySector);
+    dirHdr->Print();
+
+    freeMap->Print();
+
+    directory->FetchFrom(directoryFile);
+    directory->Print();
+
+    delete bitHdr;
+    delete dirHdr;
+    delete freeMap;
+    delete directory;
+}
+
+#else  // FILESYS_STUB
+#include "copyright.h"
+#include "sysdep.h"
+#include "openfile.h"
+#include "filetable.h"
+#include "filesys.h"
+#include "kernel.h"
+#include "main.h"
+
+OpenFile *FileSystem::Open(char *name) {
+    int fileDescriptor = OpenForReadWrite(name, FALSE);
+
+    if (fileDescriptor == -1) return NULL;
+    return new OpenFile(fileDescriptor);
+}
+
+int FileSystem::FileTableIndex() { return kernel->currentThread->processID; };
+
+#endif  // FILESYS_STUB
diff --git a/code/filesys/filesys.h b/code/filesys/filesys.h
new file mode 100644
index 0000000..a8c5fe4
--- /dev/null
+++ b/code/filesys/filesys.h
@@ -0,0 +1,133 @@
+// filesys.h
+//	Data structures to represent the Nachos file system.
+//
+//	A file system is a set of files stored on disk, organized
+//	into directories.  Operations on the file system have to
+//	do with "naming" -- creating, opening, and deleting files,
+//	given a textual file name.  Operations on an individual
+//	"open" file (read, write, close) are to be found in the OpenFile
+//	class (openfile.h).
+//
+//	We define two separate implementations of the file system.
+//	The "STUB" version just re-defines the Nachos file system
+//	operations as operations on the native UNIX file system on the machine
+//	running the Nachos simulation.
+//
+//	The other version is a "real" file system, built on top of
+//	a disk simulator.  The disk is simulated using the native UNIX
+//	file system (in a file named "DISK").
+//
+//	In the "real" implementation, there are two key data structures used
+//	in the file system.  There is a single "root" directory, listing
+//	all of the files in the file system; unlike UNIX, the baseline
+//	system does not provide a hierarchical directory structure.
+//	In addition, there is a bitmap for allocating
+//	disk sectors.  Both the root directory and the bitmap are themselves
+//	stored as files in the Nachos file system -- this causes an interesting
+//	bootstrap problem when the simulated disk is initialized.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef FS_H
+#define FS_H
+
+#include "copyright.h"
+#include "sysdep.h"
+#include "openfile.h"
+#include "filetable.h"
+
+#define MAX_PROCESS 10
+
+#ifdef FILESYS_STUB  // Temporarily implement file system calls as
+// calls to UNIX, until the real file system
+// implementation is available
+class FileSystem {
+   public:
+    FileTable **fileTable;
+
+    FileSystem() {
+        fileTable = new FileTable *[MAX_PROCESS];
+        for (int i = 0; i < MAX_PROCESS; i++) {
+            fileTable[i] = new FileTable;
+        }
+    }
+
+    ~FileSystem() {
+        for (int i = 0; i < MAX_PROCESS; i++) {
+            delete fileTable[i];
+        }
+        delete[] fileTable;
+    }
+
+    bool Create(char *name) {
+        int fileDescriptor = OpenForWrite(name);
+
+        if (fileDescriptor == -1) return FALSE;
+        Close(fileDescriptor);
+        return TRUE;
+    }
+
+    OpenFile *Open(char *name);
+
+    int FileTableIndex();
+
+    void Renew(int id) {
+        for (int i = 0; i < FILE_MAX; i++) {
+            fileTable[id]->Remove(i);
+        }
+    }
+
+    int Open(char *name, int openMode) {
+        return fileTable[FileTableIndex()]->Insert(name, openMode);
+    }
+
+    int Close(int id) { return fileTable[FileTableIndex()]->Remove(id); }
+
+    int Read(char *buffer, int charCount, int id) {
+        return fileTable[FileTableIndex()]->Read(buffer, charCount, id);
+    }
+
+    int Write(char *buffer, int charCount, int id) {
+        return fileTable[FileTableIndex()]->Write(buffer, charCount, id);
+    }
+
+    int Seek(int position, int id) {
+        return fileTable[FileTableIndex()]->Seek(position, id);
+    }
+
+    bool Remove(char *name) { return Unlink(name) == 0; }
+};
+
+#else  // FILESYS
+class FileSystem {
+   public:
+    FileSystem(bool format);  // Initialize the file system.
+                              // Must be called *after* "synchDisk"
+                              // has been initialized.
+                              // If "format", there is nothing on
+                              // the disk, so initialize the directory
+                              // and the bitmap of free blocks.
+
+    bool Create(char* name, int initialSize);
+    // Create a file (UNIX creat)
+
+    OpenFile* Open(char* name);  // Open a file (UNIX open)
+
+    bool Remove(char* name);  // Delete a file (UNIX unlink)
+
+    void List();  // List all the files in the file system
+
+    void Print();  // List all the files and their contents
+
+   private:
+    OpenFile* freeMapFile;    // Bit map of free disk blocks,
+                              // represented as a file
+    OpenFile* directoryFile;  // "Root" directory -- list of
+                              // file names, represented as a file
+};
+
+#endif  // FILESYS
+
+#endif  // FS_H
diff --git a/code/filesys/filetable.h b/code/filesys/filetable.h
new file mode 100644
index 0000000..f4e9cb1
--- /dev/null
+++ b/code/filesys/filetable.h
@@ -0,0 +1,96 @@
+#ifndef FILETABLE_H
+#define FILETABLE_H
+#include "openfile.h"
+#include "sysdep.h"
+
+#define FILE_MAX 10
+#define CONSOLE_IN 0
+#define CONSOLE_OUT 1
+#define MODE_READWRITE 0
+#define MODE_READ 1
+#define MODE_WRITE 2
+
+class FileTable {
+   private:
+    OpenFile** openFile;
+    int* fileOpenMode;
+
+   public:
+    FileTable() {
+        openFile = new OpenFile*[FILE_MAX];
+        fileOpenMode = new int[FILE_MAX];
+        fileOpenMode[CONSOLE_IN] = MODE_READ;
+        fileOpenMode[CONSOLE_OUT] = MODE_WRITE;
+    }
+
+    int Insert(char* fileName, int openMode) {
+        int freeIndex = -1;
+        int fileDescriptor = -1;
+        for (int i = 2; i < FILE_MAX; i++) {
+            if (openFile[i] == NULL) {
+                freeIndex = i;
+                break;
+            }
+        }
+
+        if (freeIndex == -1) {
+            return -1;
+        }
+
+        if (openMode == MODE_READWRITE)
+            fileDescriptor = OpenForReadWrite(fileName, FALSE);
+        if (openMode == MODE_READ)
+            fileDescriptor = OpenForRead(fileName, FALSE);
+
+        if (fileDescriptor == -1) return -1;
+        openFile[freeIndex] = new OpenFile(fileDescriptor);
+        fileOpenMode[freeIndex] = openMode;
+
+        return freeIndex;
+    }
+
+    int Remove(int index) {
+        if (index < 2 || index >= FILE_MAX) return -1;
+        if (openFile[index]) {
+            delete openFile[index];
+            openFile[index] = NULL;
+            return 0;
+        }
+        return -1;
+    }
+
+    int Read(char* buffer, int charCount, int index) {
+        if (index >= FILE_MAX) return -1;
+        if (openFile[index] == NULL) return -1;
+        int result = openFile[index]->Read(buffer, charCount);
+        // if we cannot read enough bytes, we should return -2
+        if (result != charCount) return -2;
+        return result;
+    }
+
+    int Write(char* buffer, int charCount, int index) {
+        if (index >= FILE_MAX) return -1;
+        if (openFile[index] == NULL || fileOpenMode[index] == MODE_READ)
+            return -1;
+        return openFile[index]->Write(buffer, charCount);
+    }
+
+    int Seek(int pos, int index) {
+        if (index <= 1 || index >= FILE_MAX) return -1;
+        if (openFile[index] == NULL) return -1;
+        // use seek(-1) to move to the end of file
+        if (pos == -1) pos = openFile[index]->Length();
+        if (pos < 0 || pos > openFile[index]->Length()) return -1;
+        return openFile[index]->Seek(pos);
+    }
+
+    ~FileTable() {
+        for (int i = 0; i < FILE_MAX; i++) {
+            if (openFile[i]) delete openFile[i];
+        }
+        delete[] openFile;
+        delete[] fileOpenMode;
+    }
+};
+
+#endif
diff --git a/code/filesys/openfile.cc b/code/filesys/openfile.cc
new file mode 100644
index 0000000..b2aa4f7
--- /dev/null
+++ b/code/filesys/openfile.cc
@@ -0,0 +1,173 @@
+// openfile.cc
+//	Routines to manage an open Nachos file.  As in UNIX, a
+//	file must be open before we can read or write to it.
+//	Once we're all done, we can close it (in Nachos, by deleting
+//	the OpenFile data structure).
+//
+//	Also as in UNIX, for convenience, we keep the file header in
+//	memory while the file is open.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+#ifndef FILESYS_STUB
+
+#include "copyright.h"
+#include "main.h"
+#include "filehdr.h"
+#include "openfile.h"
+#include "synchdisk.h"
+
+//----------------------------------------------------------------------
+// OpenFile::OpenFile
+// 	Open a Nachos file for reading and writing.  Bring the file header
+//	into memory while the file is open.
+//
+//	"sector" -- the location on disk of the file header for this file
+//----------------------------------------------------------------------
+
+OpenFile::OpenFile(int sector) {
+    hdr = new FileHeader;
+    hdr->FetchFrom(sector);
+    seekPosition = 0;
+}
+
+//----------------------------------------------------------------------
+// OpenFile::~OpenFile
+// 	Close a Nachos file, de-allocating any in-memory data structures.
+//----------------------------------------------------------------------
+
+OpenFile::~OpenFile() { delete hdr; }
+
+//----------------------------------------------------------------------
+// OpenFile::Seek
+// 	Change the current location within the open file -- the point at
+//	which the next Read or Write will start from.
+//
+//	"position" -- the location within the file for the next Read/Write
+//----------------------------------------------------------------------
+
+void OpenFile::Seek(int position) { seekPosition = position; }
+
+//----------------------------------------------------------------------
+// OpenFile::Read/Write
+// 	Read/write a portion of a file, starting from seekPosition.
+//	Return the number of bytes actually written or read, and as a
+//	side effect, increment the current position within the file.
+//
+//	Implemented using the more primitive ReadAt/WriteAt.
+//
+//	"into" -- the buffer to contain the data to be read from disk
+//	"from" -- the buffer containing the data to be written to disk
+//	"numBytes" -- the number of bytes to transfer
+//----------------------------------------------------------------------
+
+int OpenFile::Read(char *into, int numBytes) {
+    int result = ReadAt(into, numBytes, seekPosition);
+    seekPosition += result;
+    return result;
+}
+
+int OpenFile::Write(char *into, int numBytes) {
+    int result = WriteAt(into, numBytes, seekPosition);
+    seekPosition += result;
+    return result;
+}
+
+//----------------------------------------------------------------------
+// OpenFile::ReadAt/WriteAt
+// 	Read/write a portion of a file, starting at "position".
+//	Return the number of bytes actually written or read, but has
+//	no side effects (except that Write modifies the file, of course).
+//
+//	There is no guarantee the request starts or ends on an even disk sector
+//	boundary; however the disk only knows how to read/write a whole disk
+//	sector at a time.  Thus:
+//
+//	For ReadAt:
+//	   We read in all of the full or partial sectors that are part of the
+//	   request, but we only copy the part we are interested in.
+//	For WriteAt:
+//	   We must first read in any sectors that will be partially written,
+//	   so that we don't overwrite the unmodified portion.  We then copy
+//	   in the data that will be modified, and write back all the full
+//	   or partial sectors that are part of the request.
+//
+//	"into" -- the buffer to contain the data to be read from disk
+//	"from" -- the buffer containing the data to be written to disk
+//	"numBytes" -- the number of bytes to transfer
+//	"position" -- the offset within the file of the first byte to be
+//			read/written
+//----------------------------------------------------------------------
+
+int OpenFile::ReadAt(char *into, int numBytes, int position) {
+    int fileLength = hdr->FileLength();
+    int i, firstSector, lastSector, numSectors;
+    char *buf;
+
+    if ((numBytes <= 0) || (position >= fileLength)) return 0;  // check request
+    if ((position + numBytes) > fileLength) numBytes = fileLength - position;
+    DEBUG(dbgFile, "Reading " << numBytes << " bytes at " << position
+                              << " from file of length " << fileLength);
+
+    firstSector = divRoundDown(position, SectorSize);
+    lastSector = divRoundDown(position + numBytes - 1, SectorSize);
+    numSectors = 1 + lastSector - firstSector;
+
+    // read in all the full and partial sectors that we need
+    buf = new char[numSectors * SectorSize];
+    for (i = firstSector; i <= lastSector; i++)
+        kernel->synchDisk->ReadSector(hdr->ByteToSector(i * SectorSize),
+                                      &buf[(i - firstSector) * SectorSize]);
+
+    // copy the part we want
+    bcopy(&buf[position - (firstSector * SectorSize)], into, numBytes);
+    delete[] buf;
+    return numBytes;
+}
+
+int OpenFile::WriteAt(char *from, int numBytes, int position) {
+    int fileLength = hdr->FileLength();
+    int i, firstSector, lastSector, numSectors;
+    bool firstAligned, lastAligned;
+    char *buf;
+
+    if ((numBytes <= 0) || (position >= fileLength)) return 0;  // check request
+    if ((position + numBytes) > fileLength) numBytes = fileLength - position;
+    DEBUG(dbgFile, "Writing " << numBytes << " bytes at " << position
+                              << " from file of length " << fileLength);
+
+    firstSector = divRoundDown(position, SectorSize);
+    lastSector = divRoundDown(position + numBytes - 1, SectorSize);
+    numSectors = 1 + lastSector - firstSector;
+
+    buf = new char[numSectors * SectorSize];
+
+    firstAligned = (position == (firstSector * SectorSize));
+    lastAligned = ((position + numBytes) == ((lastSector + 1) * SectorSize));
+
+    // read in first and last sector, if they are to be partially modified
+    if (!firstAligned) ReadAt(buf, SectorSize, firstSector * SectorSize);
+    if (!lastAligned && ((firstSector != lastSector) || firstAligned))
+        ReadAt(&buf[(lastSector - firstSector) * SectorSize], SectorSize,
+               lastSector * SectorSize);
+
+    // copy in the bytes we want to change
+    bcopy(from, &buf[position - (firstSector * SectorSize)], numBytes);
+
+    // write modified sectors back
+    for (i = firstSector; i <= lastSector; i++)
+        kernel->synchDisk->WriteSector(hdr->ByteToSector(i * SectorSize),
+                                       &buf[(i - firstSector) * SectorSize]);
+    delete[] buf;
+    return numBytes;
+}
+
+//----------------------------------------------------------------------
+// OpenFile::Length
+// 	Return the number of bytes in the file.
+//----------------------------------------------------------------------
+
+int OpenFile::Length() { return hdr->FileLength(); }
+
+#endif  // FILESYS_STUB
diff --git a/code/filesys/openfile.h b/code/filesys/openfile.h
new file mode 100644
index 0000000..171be8b
--- /dev/null
+++ b/code/filesys/openfile.h
@@ -0,0 +1,105 @@
+// openfile.h
+//	Data structures for opening, closing, reading and writing to
+//	individual files.  The operations supported are similar to
+//	the UNIX ones -- type 'man open' to the UNIX prompt.
+//
+//	There are two implementations.  One is a "STUB" that directly
+//	turns the file operations into the underlying UNIX operations.
+//	(cf. comment in filesys.h).
+//
+//	The other is the "real" implementation, that turns these
+//	operations into read and write disk sector requests.
+//	In this baseline implementation of the file system, we don't
+//	worry about concurrent accesses to the file system
+//	by different threads.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef OPENFILE_H
+#define OPENFILE_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "sysdep.h"
+
+#ifdef FILESYS_STUB  // Temporarily implement calls to
+                     // Nachos file system as calls to UNIX!
+                     // See definitions listed under #else
+class OpenFile {
+   public:
+    OpenFile(int f) {
+        file = f;
+        currentOffset = 0;
+    }                             // open the file
+    ~OpenFile() { Close(file); }  // close the file
+
+    int ReadAt(char *into, int numBytes, int position) {
+        Lseek(file, position, 0);
+        return ReadPartial(file, into, numBytes);
+    }
+    int WriteAt(char *from, int numBytes, int position) {
+        Lseek(file, position, 0);
+        WriteFile(file, from, numBytes);
+        return numBytes;
+    }
+    int Read(char *into, int numBytes) {
+        int numRead = ReadAt(into, numBytes, currentOffset);
+        currentOffset += numRead;
+        return numRead;
+    }
+    int Write(char *from, int numBytes) {
+        int numWritten = WriteAt(from, numBytes, currentOffset);
+        currentOffset += numWritten;
+        return numWritten;
+    }
+
+    int Length() {
+        Lseek(file, 0, 2);
+        return Tell(file);
+    }
+
+    int Seek(int position) { return currentOffset = position; }
+
+   private:
+    int file;
+    int currentOffset;
+};
+
+#else  // FILESYS
+class FileHeader;
+
+class OpenFile {
+   public:
+    OpenFile(int sector);  // Open a file whose header is located
+                           // at "sector" on the disk
+    ~OpenFile();           // Close the file
+
+    void Seek(int position);  // Set the position from which to
+                              // start reading/writing -- UNIX lseek
+
+    int Read(char *into, int numBytes);  // Read/write bytes from the file,
+                                         // starting at the implicit position.
+                                         // Return the # actually read/written,
+                                         // and increment position in file.
+    int Write(char *from, int numBytes);
+
+    int ReadAt(char *into, int numBytes, int position);
+    // Read/write bytes from the file,
+    // bypassing the implicit position.
+    int WriteAt(char *from, int numBytes, int position);
+
+    int Length();  // Return the number of bytes in the
+                   // file (this interface is simpler
+                   // than the UNIX idiom -- lseek to
+                   // end of file, tell, lseek back
+
+   private:
+    FileHeader *hdr;   // Header for this file
+    int seekPosition;  // Current position within the file
+};
+
+#endif  // FILESYS
+
+#endif  // OPENFILE_H
diff --git a/code/filesys/pbitmap.cc b/code/filesys/pbitmap.cc
new file mode 100644
index 0000000..e0d8ae2
--- /dev/null
+++ b/code/filesys/pbitmap.cc
@@ -0,0 +1,71 @@
+// pbitmap.c
+//	Routines to manage a persistent bitmap -- a bitmap that is
+//	stored on disk.
+//
+// Copyright (c) 1992,1993,1995 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "pbitmap.h"
+
+//----------------------------------------------------------------------
+// PersistentBitmap::PersistentBitmap(int)
+// 	Initialize a bitmap with "numItems" bits, so that every bit is clear.
+//	it can be added somewhere on a list.
+//
+//	"numItems" is the number of bits in the bitmap.
+//
+//      This constructor does not initialize the bitmap from a disk file
+//----------------------------------------------------------------------
+
+PersistentBitmap::PersistentBitmap(int numItems) : Bitmap(numItems) {}
+
+//----------------------------------------------------------------------
+// PersistentBitmap::PersistentBitmap(OpenFile*,int)
+// 	Initialize a persistent bitmap with "numItems" bits,
+//      so that every bit is clear.
+//
+//	"numItems" is the number of bits in the bitmap.
+//      "file" refers to an open file containing the bitmap (written
+//        by a previous call to PersistentBitmap::WriteBack
+//
+//      This constructor initializes the bitmap from a disk file
+//----------------------------------------------------------------------
+
+PersistentBitmap::PersistentBitmap(OpenFile *file, int numItems)
+    : Bitmap(numItems) {
+    // map has already been initialized by the BitMap constructor,
+    // but we will just overwrite that with the contents of the
+    // map found in the file
+    file->ReadAt((char *)map, numWords * sizeof(unsigned), 0);
+}
+
+//----------------------------------------------------------------------
+// PersistentBitmap::~PersistentBitmap
+// 	De-allocate a persistent bitmap.
+//----------------------------------------------------------------------
+
+PersistentBitmap::~PersistentBitmap() {}
+
+//----------------------------------------------------------------------
+// PersistentBitmap::FetchFrom
+// 	Initialize the contents of a persistent bitmap from a Nachos file.
+//
+//	"file" is the place to read the bitmap from
+//----------------------------------------------------------------------
+
+void PersistentBitmap::FetchFrom(OpenFile *file) {
+    file->ReadAt((char *)map, numWords * sizeof(unsigned), 0);
+}
+
+//----------------------------------------------------------------------
+// PersistentBitmap::WriteBack
+// 	Store the contents of a persistent bitmap to a Nachos file.
+//
+//	"file" is the place to write the bitmap to
+//----------------------------------------------------------------------
+
+void PersistentBitmap::WriteBack(OpenFile *file) {
+    file->WriteAt((char *)map, numWords * sizeof(unsigned), 0);
+}
diff --git a/code/filesys/pbitmap.h b/code/filesys/pbitmap.h
new file mode 100644
index 0000000..3c67d56
--- /dev/null
+++ b/code/filesys/pbitmap.h
@@ -0,0 +1,36 @@
+// pbitmap.h
+//	Data structures defining a "persistent" bitmap -- a bitmap
+//	that can be stored and fetched off of disk
+//
+//    A persistent bitmap can either be initialized from the disk
+//    when it is created, or it can be initialized later using
+//    the FetchFrom method
+//
+// Copyright (c) 1992,1993,1995 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef PBITMAP_H
+#define PBITMAP_H
+
+#include "copyright.h"
+#include "bitmap.h"
+#include "openfile.h"
+
+// The following class defines a persistent bitmap.  It inherits all
+// the behavior of a bitmap (see bitmap.h), adding the ability to
+// be read from and stored to the disk.
+
+class PersistentBitmap : public Bitmap {
+   public:
+    PersistentBitmap(OpenFile *file,
+                     int numItems);  // initialize bitmap from disk
+    PersistentBitmap(int numItems);  // or don't...
+
+    ~PersistentBitmap();  // deallocate bitmap
+
+    void FetchFrom(OpenFile *file);  // read bitmap from the disk
+    void WriteBack(OpenFile *file);  // write bitmap contents to disk
+};
+
+#endif  // PBITMAP_H
diff --git a/code/filesys/synchdisk.cc b/code/filesys/synchdisk.cc
new file mode 100644
index 0000000..c4b7f0e
--- /dev/null
+++ b/code/filesys/synchdisk.cc
@@ -0,0 +1,83 @@
+// synchdisk.cc
+//	Routines to synchronously access the disk.  The physical disk
+//	is an asynchronous device (disk requests return immediately, and
+//	an interrupt happens later on).  This is a layer on top of
+//	the disk providing a synchronous interface (requests wait until
+//	the request completes).
+//
+//	Use a semaphore to synchronize the interrupt handlers with the
+//	pending requests.  And, because the physical disk can only
+//	handle one operation at a time, use a lock to enforce mutual
+//	exclusion.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "synchdisk.h"
+
+//----------------------------------------------------------------------
+// SynchDisk::SynchDisk
+// 	Initialize the synchronous interface to the physical disk, in turn
+//	initializing the physical disk.
+//
+//----------------------------------------------------------------------
+
+SynchDisk::SynchDisk() {
+    semaphore = new Semaphore("synch disk", 0);
+    lock = new Lock("synch disk lock");
+    disk = new Disk(this);
+}
+
+//----------------------------------------------------------------------
+// SynchDisk::~SynchDisk
+// 	De-allocate data structures needed for the synchronous disk
+//	abstraction.
+//----------------------------------------------------------------------
+
+SynchDisk::~SynchDisk() {
+    delete disk;
+    delete lock;
+    delete semaphore;
+}
+
+//----------------------------------------------------------------------
+// SynchDisk::ReadSector
+// 	Read the contents of a disk sector into a buffer.  Return only
+//	after the data has been read.
+//
+//	"sectorNumber" -- the disk sector to read
+//	"data" -- the buffer to hold the contents of the disk sector
+//----------------------------------------------------------------------
+
+void SynchDisk::ReadSector(int sectorNumber, char* data) {
+    lock->Acquire();  // only one disk I/O at a time
+    disk->ReadRequest(sectorNumber, data);
+    semaphore->P();  // wait for interrupt
+    lock->Release();
+}
+
+//----------------------------------------------------------------------
+// SynchDisk::WriteSector
+// 	Write the contents of a buffer into a disk sector.  Return only
+//	after the data has been written.
+//
+//	"sectorNumber" -- the disk sector to be written
+//	"data" -- the new contents of the disk sector
+//----------------------------------------------------------------------
+
+void SynchDisk::WriteSector(int sectorNumber, char* data) {
+    lock->Acquire();  // only one disk I/O at a time
+    disk->WriteRequest(sectorNumber, data);
+    semaphore->P();  // wait for interrupt
+    lock->Release();
+}
+
+//----------------------------------------------------------------------
+// SynchDisk::CallBack
+// 	Disk interrupt handler.  Wake up any thread waiting for the disk
+//	request to finish.
+//----------------------------------------------------------------------
+
+void SynchDisk::CallBack() { semaphore->V(); }
diff --git a/code/filesys/synchdisk.h b/code/filesys/synchdisk.h
new file mode 100644
index 0000000..b406819
--- /dev/null
+++ b/code/filesys/synchdisk.h
@@ -0,0 +1,55 @@
+// synchdisk.h
+// 	Data structures to export a synchronous interface to the raw
+//	disk device.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+
+#ifndef SYNCHDISK_H
+#define SYNCHDISK_H
+
+#include "disk.h"
+#include "synch.h"
+#include "callback.h"
+
+// The following class defines a "synchronous" disk abstraction.
+// As with other I/O devices, the raw physical disk is an asynchronous device --
+// requests to read or write portions of the disk return immediately,
+// and an interrupt occurs later to signal that the operation completed.
+// (Also, the physical characteristics of the disk device assume that
+// only one operation can be requested at a time).
+//
+// This class provides the abstraction that for any individual thread
+// making a request, it waits around until the operation finishes before
+// returning.
+
+class SynchDisk : public CallBackObj {
+   public:
+    SynchDisk();   // Initialize a synchronous disk,
+                   // by initializing the raw Disk.
+    ~SynchDisk();  // De-allocate the synch disk data
+
+    void ReadSector(int sectorNumber, char *data);
+    // Read/write a disk sector, returning
+    // only once the data is actually read
+    // or written.  These call
+    // Disk::ReadRequest/WriteRequest and
+    // then wait until the request is done.
+    void WriteSector(int sectorNumber, char *data);
+
+    void CallBack();  // Called by the disk device interrupt
+                      // handler, to signal that the
+                      // current disk operation is complete.
+
+   private:
+    Disk *disk;            // Raw disk device
+    Semaphore *semaphore;  // To synchronize requesting thread
+                           // with the interrupt handler
+    Lock *lock;            // Only one read/write request
+                           // can be sent to the disk at a time
+};
+
+#endif  // SYNCHDISK_H
diff --git a/code/lib/bitmap.cc b/code/lib/bitmap.cc
new file mode 100644
index 0000000..0d85879
--- /dev/null
+++ b/code/lib/bitmap.cc
@@ -0,0 +1,172 @@
+// bitmap.cc
+//	Routines to manage a bitmap -- an array of bits each of which
+//	can be either on or off.  Represented as an array of integers.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "debug.h"
+#include "bitmap.h"
+
+//----------------------------------------------------------------------
+// BitMap::BitMap
+// 	Initialize a bitmap with "numItems" bits, so that every bit is clear.
+//	it can be added somewhere on a list.
+//
+//	"numItems" is the number of bits in the bitmap.
+//----------------------------------------------------------------------
+
+Bitmap::Bitmap(int numItems) {
+    int i;
+
+    ASSERT(numItems > 0);
+
+    numBits = numItems;
+    numWords = divRoundUp(numBits, BitsInWord);
+    map = new unsigned int[numWords];
+    for (i = 0; i < numWords; i++) {
+        map[i] = 0;  // initialize map to keep Purify happy
+    }
+    for (i = 0; i < numBits; i++) {
+        Clear(i);
+    }
+}
+
+//----------------------------------------------------------------------
+// Bitmap::~Bitmap
+// 	De-allocate a bitmap.
+//----------------------------------------------------------------------
+
+Bitmap::~Bitmap() { delete map; }
+
+//----------------------------------------------------------------------
+// Bitmap::Set
+// 	Set the "nth" bit in a bitmap.
+//
+//	"which" is the number of the bit to be set.
+//----------------------------------------------------------------------
+
+void Bitmap::Mark(int which) {
+    ASSERT(which >= 0 && which < numBits);
+
+    map[which / BitsInWord] |= 1 << (which % BitsInWord);
+
+    ASSERT(Test(which));
+}
+
+//----------------------------------------------------------------------
+// Bitmap::Clear
+// 	Clear the "nth" bit in a bitmap.
+//
+//	"which" is the number of the bit to be cleared.
+//----------------------------------------------------------------------
+
+void Bitmap::Clear(int which) {
+    ASSERT(which >= 0 && which < numBits);
+
+    map[which / BitsInWord] &= ~(1 << (which % BitsInWord));
+
+    ASSERT(!Test(which));
+}
+
+//----------------------------------------------------------------------
+// Bitmap::Test
+// 	Return TRUE if the "nth" bit is set.
+//
+//	"which" is the number of the bit to be tested.
+//----------------------------------------------------------------------
+
+bool Bitmap::Test(int which) const {
+    ASSERT(which >= 0 && which < numBits);
+
+    if (map[which / BitsInWord] & (1 << (which % BitsInWord))) {
+        return TRUE;
+    } else {
+        return FALSE;
+    }
+}
+
+//----------------------------------------------------------------------
+// Bitmap::FindAndSet
+// 	Return the number of the first bit which is clear.
+//	As a side effect, set the bit (mark it as in use).
+//	(In other words, find and allocate a bit.)
+//
+//	If no bits are clear, return -1.
+//----------------------------------------------------------------------
+
+int Bitmap::FindAndSet() {
+    for (int i = 0; i < numBits; i++) {
+        if (!Test(i)) {
+            Mark(i);
+            return i;
+        }
+    }
+    return -1;
+}
+
+//----------------------------------------------------------------------
+// Bitmap::NumClear
+// 	Return the number of clear bits in the bitmap.
+//	(In other words, how many bits are unallocated?)
+//----------------------------------------------------------------------
+
+int Bitmap::NumClear() const {
+    int count = 0;
+
+    for (int i = 0; i < numBits; i++) {
+        if (!Test(i)) {
+            count++;
+        }
+    }
+    return count;
+}
+
+//----------------------------------------------------------------------
+// Bitmap::Print
+// 	Print the contents of the bitmap, for debugging.
+//
+//	Could be done in a number of ways, but we just print the #'s of
+//	all the bits that are set in the bitmap.
+//----------------------------------------------------------------------
+
+void Bitmap::Print() const {
+    cout << "Bitmap set:\n";
+    for (int i = 0; i < numBits; i++) {
+        if (Test(i)) {
+            cout << i << ", ";
+        }
+    }
+    cout << "\n";
+}
+
+//----------------------------------------------------------------------
+// Bitmap::SelfTest
+// 	Test whether this module is working.
+//----------------------------------------------------------------------
+
+void Bitmap::SelfTest() {
+    int i;
+
+    ASSERT(numBits >= BitsInWord);  // bitmap must be big enough
+
+    ASSERT(NumClear() == numBits);  // bitmap must be empty
+    ASSERT(FindAndSet() == 0);
+    Mark(31);
+    ASSERT(Test(0) && Test(31));
+
+    ASSERT(FindAndSet() == 1);
+    Clear(0);
+    Clear(1);
+    Clear(31);
+
+    for (i = 0; i < numBits; i++) {
+        Mark(i);
+    }
+    ASSERT(FindAndSet() == -1);  // bitmap should be full!
+    for (i = 0; i < numBits; i++) {
+        Clear(i);
+    }
+}
diff --git a/code/lib/bitmap.h b/code/lib/bitmap.h
new file mode 100644
index 0000000..d035ed0
--- /dev/null
+++ b/code/lib/bitmap.h
@@ -0,0 +1,59 @@
+// bitmap.h
+//	Data structures defining a bitmap -- an array of bits each of which
+//	can be either on or off.
+//
+//	Represented as an array of unsigned integers, on which we do
+//	modulo arithmetic to find the bit we are interested in.
+//
+//	The bitmap can be parameterized with with the number of bits being
+//	managed.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef BITMAP_H
+#define BITMAP_H
+
+#include "copyright.h"
+#include "utility.h"
+
+// Definitions helpful for representing a bitmap as an array of integers
+const int BitsInByte = 8;
+const int BitsInWord = sizeof(unsigned int) * BitsInByte;
+
+// The following class defines a "bitmap" -- an array of bits,
+// each of which can be independently set, cleared, and tested.
+//
+// Most useful for managing the allocation of the elements of an array --
+// for instance, disk sectors, or main memory pages.
+// Each bit represents whether the corresponding sector or page is
+// in use or free.
+
+class Bitmap {
+   public:
+    Bitmap(int numItems);  // Initialize a bitmap, with "numItems" bits
+                           // initially, all bits are cleared.
+    ~Bitmap();             // De-allocate bitmap
+
+    void Mark(int which);        // Set the "nth" bit
+    void Clear(int which);       // Clear the "nth" bit
+    bool Test(int which) const;  // Is the "nth" bit set?
+    int FindAndSet();            // Return the # of a clear bit, and as a side
+                                 // effect, set the bit.
+                                 // If no bits are clear, return -1.
+    int NumClear() const;        // Return the number of clear bits
+
+    void Print() const;  // Print contents of bitmap
+    void SelfTest();     // Test whether bitmap is working
+
+   protected:
+    int numBits;        // number of bits in the bitmap
+    int numWords;       // number of words of bitmap storage
+                        // (rounded up if numBits is not a
+                        //  multiple of the number of bits in
+                        //  a word)
+    unsigned int *map;  // bit storage
+};
+
+#endif  // BITMAP_H
diff --git a/code/lib/copyright.h b/code/lib/copyright.h
new file mode 100644
index 0000000..b733b6f
--- /dev/null
+++ b/code/lib/copyright.h
@@ -0,0 +1,26 @@
+/*
+Copyright (c) 1992-1996 The Regents of the University of California.
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose, without fee, and without written agreement is
+hereby granted, provided that the above copyright notice and the following
+two paragraphs appear in all copies of this software.
+
+IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
+OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
+CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
+PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+*/
+
+#ifdef MAIN /* include the copyright message in every executable */
+static char *copyright =
+    "Copyright (c) 1992-1993 The Regents of the University of California.  All "
+    "rights reserved.";
+#endif  // MAIN
diff --git a/code/lib/debug.cc b/code/lib/debug.cc
new file mode 100644
index 0000000..9c94804
--- /dev/null
+++ b/code/lib/debug.cc
@@ -0,0 +1,39 @@
+// debug.cc
+//	Debugging routines.  Allows users to control whether to
+//	print DEBUG statements, based on a command line argument.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "utility.h"
+#include "debug.h"
+#include "string.h"
+
+//----------------------------------------------------------------------
+// Debug::Debug
+//      Initialize so that only DEBUG messages with a flag in flagList
+//	will be printed.
+//
+//	If the flag is "+", we enable all DEBUG messages.
+//
+// 	"flagList" is a string of characters for whose DEBUG messages are
+//		to be enabled.
+//----------------------------------------------------------------------
+
+Debug::Debug(char *flagList) { enableFlags = flagList; }
+
+//----------------------------------------------------------------------
+// Debug::IsEnabled
+//      Return TRUE if DEBUG messages with "flag" are to be printed.
+//----------------------------------------------------------------------
+
+bool Debug::IsEnabled(char flag) {
+    if (enableFlags != NULL) {
+        return ((strchr(enableFlags, flag) != 0) ||
+                (strchr(enableFlags, '+') != 0));
+    } else {
+        return FALSE;
+    }
+}
diff --git a/code/lib/debug.h b/code/lib/debug.h
new file mode 100644
index 0000000..ba789c9
--- /dev/null
+++ b/code/lib/debug.h
@@ -0,0 +1,98 @@
+// debug.h
+//	Data structures for debugging routines.
+//
+//	The debugging routines allow the user to turn on selected
+//	debugging messages, controllable from the command line arguments
+//	passed to Nachos (-d).  You are encouraged to add your own
+//	debugging flags.  Please....
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef DEBUG_H
+#define DEBUG_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "sysdep.h"
+
+// The pre-defined debugging flags are:
+
+const char dbgAll = '+';     // turn on all debug messages
+const char dbgThread = 't';  // threads
+const char dbgSynch = 's';   // locks, semaphores, condition vars
+const char dbgInt = 'i';     // interrupt emulation
+const char dbgMach = 'm';    // machine emulation
+const char dbgDisk = 'd';    // disk emulation
+const char dbgFile = 'f';    // file system
+const char dbgAddr = 'a';    // address spaces
+const char dbgNet = 'n';     // network emulation
+const char dbgSys = 'u';     // systemcall
+
+class Debug {
+   public:
+    Debug(char *flagList);
+
+    bool IsEnabled(char flag);
+
+   private:
+    char *enableFlags;  // controls which DEBUG messages are printed
+};
+
+extern Debug *debug;
+
+//----------------------------------------------------------------------
+// DEBUG
+//      If flag is enabled, print a message.
+//----------------------------------------------------------------------
+#define DEBUG(flag, expr)          \
+    if (!debug->IsEnabled(flag)) { \
+    } else {                       \
+        cerr << expr << "\n";      \
+    }
+
+//----------------------------------------------------------------------
+// ASSERT
+//      If condition is false,  print a message and dump core.
+//	Useful for documenting assumptions in the code.
+//
+//	NOTE: needs to be a #define, to be able to print the location
+//	where the error occurred.
+//----------------------------------------------------------------------
+#define ASSERT(condition)                                                     \
+    if (condition) {                                                          \
+    } else {                                                                  \
+        cerr << "Assertion failed: line " << __LINE__ << " file " << __FILE__ \
+             << "\n";                                                         \
+        Abort();                                                              \
+    }
+
+//----------------------------------------------------------------------
+// ASSERTNOTREACHED
+//      Print a message and dump core (equivalent to ASSERT(FALSE) without
+//	making the compiler whine).  Useful for documenting when
+//	code should not be reached.
+//
+//	NOTE: needs to be a #define, to be able to print the location
+//	where the error occurred.
+//----------------------------------------------------------------------
+
+#define ASSERTNOTREACHED()                                                    \
+    {                                                                         \
+        cerr << "Assertion failed: line " << __LINE__ << " file " << __FILE__ \
+             << "\n";                                                         \
+        Abort();                                                              \
+    }
+
+//----------------------------------------------------------------------
+// ASSERTUNIMPLEMENTED
+//     Print a message that unimplemented code is executed and dump core
+//----------------------------------------------------------------------
+#define UNIMPLEMENTED()                                                     \
+    {                                                                       \
+        cerr << "Reached UNIMPLEMENTED function " << __FUNCTION__           \
+             << " in file: " << __FILE__ << " line: " << __LINE__ << ".\n"; \
+    }
+
+#endif  // DEBUG_H
diff --git a/code/lib/hash.cc b/code/lib/hash.cc
new file mode 100644
index 0000000..5809acc
--- /dev/null
+++ b/code/lib/hash.cc
@@ -0,0 +1,327 @@
+// hash.cc
+//     	Routines to manage a self-expanding hash table of arbitrary things.
+//	The hashing function is supplied by the objects being put into
+//	the table; we use chaining to resolve hash conflicts.
+//
+//	The hash table is implemented as an array of sorted lists,
+//	and we expand the hash table if the number of elements in the table
+//	gets too big.
+//
+//     	NOTE: Mutual exclusion must be provided by the caller.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+const int InitialBuckets = 4;  // how big a hash table do we start with
+const int ResizeRatio = 3;     // when do we grow the hash table?
+const int IncreaseSizeBy = 4;  // how much do we grow table when needed?
+
+#include "copyright.h"
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::HashTable
+//	Initialize a hash table, empty to start with.
+//	Elements can now be added to the table.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+HashTable<Key, T>::HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x)) {
+    numItems = 0;
+    InitBuckets(InitialBuckets);
+    getKey = get;
+    hash = hFunc;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::InitBuckets
+//	Initialize the bucket array for a hash table.
+//	Called by the constructor and by ReHash().
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::InitBuckets(int sz) {
+    numBuckets = sz;
+    buckets = new Bucket[numBuckets];
+    for (int i = 0; i < sz; i++) {
+        buckets[i] = new List<T>;
+    }
+}
+
+//----------------------------------------------------------------------
+// HashTable<T>::~HashTable
+//	Prepare a hash table for deallocation.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+HashTable<Key, T>::~HashTable() {
+    ASSERT(IsEmpty());  // make sure table is empty
+    DeleteBuckets(buckets, numBuckets);
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::DeleteBuckets
+//	De-Initialize the bucket array for a hash table.
+//	Called by the destructor and by ReHash().
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::DeleteBuckets(List<T> **table, int sz) {
+    for (int i = 0; i < sz; i++) {
+        delete table[i];
+    }
+    delete[] table;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::HashValue
+//      Return hash table bucket that would contain key.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+int HashTable<Key, T>::HashValue(Key key) const {
+    int result = (*hash)(key) % numBuckets;
+    ASSERT(result >= 0 && result < numBuckets);
+    return result;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::Insert
+//      Put an item into the hashtable.
+//
+//	Resize the table if the # of elements / # of buckets is too big.
+//	Then allocate a HashElement to keep track of the key, item pair,
+//	and add it to the right bucket.
+//
+//	"key" is the key we'll use to find this item.
+//	"item" is the thing to put in the table.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::Insert(T item) {
+    Key key = getKey(item);
+
+    ASSERT(!IsInTable(key));
+
+    if ((numItems / numBuckets) >= ResizeRatio) {
+        ReHash();
+    }
+
+    buckets[HashValue(key)]->Append(item);
+    numItems++;
+
+    ASSERT(IsInTable(key));
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::ReHash
+//      Increase the size of the hashtable, by
+//	  (i) making a new table
+//	  (ii) moving all the elements into the new table
+//	  (iii) deleting the old table
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::ReHash() {
+    Bucket *oldTable = buckets;
+    int oldSize = numBuckets;
+    T item;
+
+    SanityCheck();
+    InitBuckets(numBuckets * IncreaseSizeBy);
+
+    for (int i = 0; i < oldSize; i++) {
+        while (!oldTable[i]->IsEmpty()) {
+            item = oldTable[i]->RemoveFront();
+            buckets[HashValue(getKey(item))]->Append(item);
+        }
+    }
+    DeleteBuckets(oldTable, oldSize);
+    SanityCheck();
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::FindInBucket
+//      Find an item in a hash table bucket, from it's key
+//
+//	"bucket" -- the list storing the item, if it's in the table
+//	"key" -- the key uniquely identifying the item
+//
+// Returns:
+//	Whether item is found, and if found, the item.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+bool HashTable<Key, T>::FindInBucket(int bucket, Key key, T *itemPtr) const {
+    ListIterator<T> iterator(buckets[bucket]);
+
+    for (; !iterator.IsDone(); iterator.Next()) {
+        if (key == getKey(iterator.Item())) {  // found!
+            *itemPtr = iterator.Item();
+            return TRUE;
+        }
+    }
+    *itemPtr = NULL;
+    return FALSE;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::Find
+//      Find an item from the hash table.
+//
+// Returns:
+//	The item or NULL if not found.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+bool HashTable<Key, T>::Find(Key key, T *itemPtr) const {
+    int bucket = HashValue(key);
+
+    return FindInBucket(bucket, key, itemPtr);
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::Remove
+//      Remove an item from the hash table. The item must be in the table.
+//
+// Returns:
+//	The removed item.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+T HashTable<Key, T>::Remove(Key key) {
+    int bucket = HashValue(key);
+    T item;
+    bool found = FindInBucket(bucket, key, &item);
+
+    ASSERT(found);  // item must be in table
+
+    buckets[bucket]->Remove(item);
+    numItems--;
+
+    ASSERT(!IsInTable(key));
+    return item;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::Apply
+//      Apply function to every item in the hash table.
+//
+//	"func" -- the function to apply
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::Apply(void (*func)(T)) const {
+    for (int bucket = 0; bucket < numBuckets; bucket++) {
+        buckets[bucket]->Apply(func);
+    }
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::FindNextFullBucket
+//      Find the next bucket in the hash table that has any items in it.
+//
+//	"bucket" -- where to start looking for full buckets
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+int HashTable<Key, T>::FindNextFullBucket(int bucket) const {
+    for (; bucket < numBuckets; bucket++) {
+        if (!buckets[bucket]->IsEmpty()) {
+            break;
+        }
+    }
+    return bucket;
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::SanityCheck
+//      Test whether this is still a legal hash table.
+//
+//	Tests: are all the buckets legal?
+//	       does the table have the right # of elements?
+//	       do all the elements hash to where they are stored?
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::SanityCheck() const {
+    int numFound = 0;
+    ListIterator<T> *iterator;
+
+    for (int i = 0; i < numBuckets; i++) {
+        buckets[i]->SanityCheck();
+        numFound += buckets[i]->NumInList();
+        iterator = new ListIterator<T>(buckets[i]);
+        for (; !iterator->IsDone(); iterator->Next()) {
+            ASSERT(i == HashValue(getKey(iterator->Item())));
+        }
+        delete iterator;
+    }
+    ASSERT(numItems == numFound);
+}
+
+//----------------------------------------------------------------------
+// HashTable<Key,T>::SelfTest
+//      Test whether this module is working.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashTable<Key, T>::SelfTest(T *p, int numEntries) {
+    int i;
+    HashIterator<Key, T> *iterator = new HashIterator<Key, T>(this);
+
+    SanityCheck();
+    ASSERT(IsEmpty());  // check that table is empty in various ways
+    for (; !iterator->IsDone(); iterator->Next()) {
+        ASSERTNOTREACHED();
+    }
+    delete iterator;
+
+    for (i = 0; i < numEntries; i++) {
+        Insert(p[i]);
+        ASSERT(IsInTable(getKey(p[i])));
+        ASSERT(!IsEmpty());
+    }
+
+    // should be able to get out everything we put in
+    for (i = 0; i < numEntries; i++) {
+        ASSERT(Remove(getKey(p[i])) == p[i]);
+    }
+
+    ASSERT(IsEmpty());
+    SanityCheck();
+}
+
+//----------------------------------------------------------------------
+// HashIterator<Key,T>::HashIterator
+//      Initialize a data structure to allow us to step through
+//	every entry in a has table.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+HashIterator<Key, T>::HashIterator(HashTable<Key, T> *tbl) {
+    table = tbl;
+    bucket = table->FindNextFullBucket(0);
+    bucketIter = NULL;
+    if (bucket < table->numBuckets) {
+        bucketIter = new ListIterator<T>(table->buckets[bucket]);
+    }
+}
+
+//----------------------------------------------------------------------
+// HashIterator<Key,T>::Next
+//      Update iterator to point to the next item in the table.
+//----------------------------------------------------------------------
+
+template <class Key, class T>
+void HashIterator<Key, T>::Next() {
+    bucketIter->Next();
+    if (bucketIter->IsDone()) {
+        delete bucketIter;
+        bucketIter = NULL;
+        bucket = table->FindNextFullBucket(++bucket);
+        if (bucket < table->numBuckets) {
+            bucketIter = new ListIterator<T>(table->buckets[bucket]);
+        }
+    }
+}
diff --git a/code/lib/hash.h b/code/lib/hash.h
new file mode 100644
index 0000000..c5df6a9
--- /dev/null
+++ b/code/lib/hash.h
@@ -0,0 +1,132 @@
+// hash.h
+//      Data structures to manage a hash table to relate arbitrary
+//	keys to arbitrary values. A hash table allows efficient lookup
+//	for the value given the key.
+//
+//	I've only tested this implementation when both the key and the
+//	value are primitive types (ints or pointers).  There is no
+//	guarantee that it will work in general.  In particular, it
+//	assumes that the "==" operator works for both keys and values.
+//
+//	In addition, the key must have Hash() defined:
+//		unsigned Hash(Key k);
+//			returns a randomized # based on value of key
+//
+//	The value must have a function defined to retrieve the key:
+//		Key GetKey(T x);
+//
+//	The hash table automatically resizes itself as items are
+//	put into the table.  The implementation uses chaining
+//	to resolve hash conflicts.
+//
+//	Allocation and deallocation of the items in the table are to
+//	be done by the caller.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef HASH_H
+#define HASH_H
+
+#include "copyright.h"
+#include "list.h"
+
+// The following class defines a "hash table" -- allowing quick
+// lookup according to the hash function defined for the items
+// being put into the table.
+
+template <class Key, class T>
+class HashIterator;
+
+template <class Key, class T>
+class HashTable {
+   public:
+    HashTable(Key (*get)(T x), unsigned (*hFunc)(Key x));
+    // initialize a hash table
+    ~HashTable();  // deallocate a hash table
+
+    void Insert(T item);  // Put item into hash table
+    T Remove(Key key);    // Remove item from hash table.
+
+    bool Find(Key key, T *itemPtr) const;
+    // Find an item from its key
+    bool IsInTable(Key key) {
+        T dummy;
+        return Find(key, &dummy);
+    }
+    // Is the item in the table?
+
+    bool IsEmpty() { return numItems == 0; }
+    // does the table have anything in it
+
+    void Apply(void (*f)(T)) const;
+    // apply function to all elements in table
+
+    void SanityCheck() const;  // is this still a legal hash table?
+    void SelfTest(T *p, int numItems);
+    // is the module working?
+
+   private:
+    typedef List<T> *Bucket;
+
+    Bucket *buckets;  // the array of hash buckets
+    int numBuckets;   // the number of buckets
+    int numItems;     // the number of items in the table
+
+    Key (*getKey)(T x);       // get Key from value
+    unsigned (*hash)(Key x);  // the hash function
+
+    void InitBuckets(int size);  // initialize bucket array
+    void DeleteBuckets(Bucket *table, int size);
+    // deallocate bucket array
+
+    int HashValue(Key key) const;
+    // which bucket does the key hash to?
+
+    void ReHash();  // expand the hash table
+
+    bool FindInBucket(int bucket, Key key, T *itemPtr) const;
+    // find item in bucket
+    int FindNextFullBucket(int start) const;
+    // find next full bucket starting from this one
+
+    friend class HashIterator<Key, T>;
+};
+
+// The following class can be used to step through a hash table --
+// same interface as ListIterator.  Example code:
+//	HashIterator<Key, T> iter(table);
+//
+//	for (; !iter->IsDone(); iter->Next()) {
+//	    Operation on iter->Item()
+//      }
+
+template <class Key, class T>
+class HashIterator {
+   public:
+    HashIterator(HashTable<Key, T> *table);  // initialize an iterator
+    ~HashIterator() {
+        if (bucketIter != NULL) delete bucketIter;
+    };
+    // destruct an iterator
+
+    bool IsDone() { return (bucket == table->numBuckets); };
+    // return TRUE if no more items in table
+    T Item() {
+        ASSERT(!IsDone());
+        return bucketIter->Item();
+    };
+    // return current item in table
+    void Next();  // update iterator to point to next
+
+   private:
+    HashTable<Key, T> *table;     // the hash table we're stepping through
+    int bucket;                   // current bucket we are in
+    ListIterator<T> *bucketIter;  // where we are in the bucket
+};
+
+#include "hash.cc"  // templates are really like macros
+// so needs to be included in every
+// file that uses the template
+#endif  // HASH_H
diff --git a/code/lib/libtest.cc b/code/lib/libtest.cc
new file mode 100644
index 0000000..15b6077
--- /dev/null
+++ b/code/lib/libtest.cc
@@ -0,0 +1,80 @@
+// libtest.cc
+//	Driver code to call self-test routines for standard library
+//	classes -- bitmaps, lists, sorted lists, and hash tables.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "libtest.h"
+#include "bitmap.h"
+#include "list.h"
+#include "hash.h"
+#include "sysdep.h"
+
+//----------------------------------------------------------------------
+// IntCompare
+//	Compare two integers together.  Serves as the comparison
+//	function for testing SortedLists
+//----------------------------------------------------------------------
+
+static int IntCompare(int x, int y) {
+    if (x < y)
+        return -1;
+    else if (x == y)
+        return 0;
+    else
+        return 1;
+}
+
+//----------------------------------------------------------------------
+// HashInt, HashKey
+//	Compute a hash function on an integer.  Serves as the
+//	hashing function for testing HashTables.
+//----------------------------------------------------------------------
+
+static unsigned int HashInt(int key) { return (unsigned int)key; }
+
+//----------------------------------------------------------------------
+// HashKey
+//	Convert a string into an integer.  Serves as the function
+//	to retrieve the key from the item in the hash table, for
+//	testing HashTables.  Should be able to use "atoi" directly,
+//	but some compilers complain about that.
+//----------------------------------------------------------------------
+
+static int HashKey(char *str) { return atoi(str); }
+
+// Array of values to be inserted into a List or SortedList.
+static int listTestVector[] = {9, 5, 7};
+
+// Array of values to be inserted into the HashTable
+// There are enough here to force a ReHash().
+static char *hashTestVector[] = {"0", "1", "2",  "3",  "4",  "5",  "6", "7",
+                                 "8", "9", "10", "11", "12", "13", "14"};
+
+//----------------------------------------------------------------------
+// LibSelfTest
+//	Run self tests on bitmaps, lists, sorted lists, and
+//	hash tables.
+//----------------------------------------------------------------------
+
+void LibSelfTest() {
+    Bitmap *map = new Bitmap(200);
+    List<int> *list = new List<int>;
+    SortedList<int> *sortList = new SortedList<int>(IntCompare);
+    HashTable<int, char *> *hashTable =
+        new HashTable<int, char *>(HashKey, HashInt);
+
+    map->SelfTest();
+    list->SelfTest(listTestVector, sizeof(listTestVector) / sizeof(int));
+    sortList->SelfTest(listTestVector, sizeof(listTestVector) / sizeof(int));
+    hashTable->SelfTest(hashTestVector,
+                        sizeof(hashTestVector) / sizeof(char *));
+
+    delete map;
+    delete list;
+    delete sortList;
+    delete hashTable;
+}
diff --git a/code/lib/libtest.h b/code/lib/libtest.h
new file mode 100644
index 0000000..ae17545
--- /dev/null
+++ b/code/lib/libtest.h
@@ -0,0 +1,15 @@
+// libtest.h
+//	 Defines self test module for standard library routines.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef LIBTEST_H
+#define LIBTEST_H
+
+#include "copyright.h"
+
+extern void LibSelfTest();
+
+#endif  // LIBTEST_H
diff --git a/code/lib/list.cc b/code/lib/list.cc
new file mode 100644
index 0000000..0ea90a5
--- /dev/null
+++ b/code/lib/list.cc
@@ -0,0 +1,354 @@
+// list.cc
+//     	Routines to manage a singly linked list of "things".
+//	Lists are implemented as templates so that we can store
+//	anything on the list in a type-safe manner.
+//
+// 	A "ListElement" is allocated for each item to be put on the
+//	list; it is de-allocated when the item is removed. This means
+//      we don't need to keep a "next" pointer in every object we
+//      want to put on a list.
+//
+//     	NOTE: Mutual exclusion must be provided by the caller.
+//  	If you want a synchronized list, you must use the routines
+//	in synchlist.cc.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+
+//----------------------------------------------------------------------
+// ListElement<T>::ListElement
+// 	Initialize a list element, so it can be added somewhere on a list.
+//
+//	"itm" is the thing to be put on the list.
+//----------------------------------------------------------------------
+
+template <class T>
+ListElement<T>::ListElement(T itm) {
+    item = itm;
+    next = NULL;  // always initialize to something!
+}
+
+//----------------------------------------------------------------------
+// List<T>::List
+//	Initialize a list, empty to start with.
+//	Elements can now be added to the list.
+//----------------------------------------------------------------------
+
+template <class T>
+List<T>::List() {
+    first = last = NULL;
+    numInList = 0;
+}
+
+//----------------------------------------------------------------------
+// List<T>::~List
+//	Prepare a list for deallocation.
+//      This does *NOT* free list elements, nor does it
+//      free the data those elements point to.
+//      Normally, the list should be empty when this is called.
+//----------------------------------------------------------------------
+
+template <class T>
+List<T>::~List() {}
+
+//----------------------------------------------------------------------
+// List<T>::Append
+//      Append an "item" to the end of the list.
+//
+//	Allocate a ListElement to keep track of the item.
+//      If the list is empty, then this will be the only element.
+//	Otherwise, put it at the end.
+//
+//	"item" is the thing to put on the list.
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::Append(T item) {
+    ListElement<T> *element = new ListElement<T>(item);
+
+    ASSERT(!IsInList(item));
+    if (IsEmpty()) {  // list is empty
+        first = element;
+        last = element;
+    } else {  // else put it after last
+        last->next = element;
+        last = element;
+    }
+    numInList++;
+    ASSERT(IsInList(item));
+}
+
+//----------------------------------------------------------------------
+// List<T>::Prepend
+//	Same as Append, only put "item" on the front.
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::Prepend(T item) {
+    ListElement<T> *element = new ListElement<T>(item);
+
+    ASSERT(!IsInList(item));
+    if (IsEmpty()) {  // list is empty
+        first = element;
+        last = element;
+    } else {  // else put it before first
+        element->next = first;
+        first = element;
+    }
+    numInList++;
+    ASSERT(IsInList(item));
+}
+
+//----------------------------------------------------------------------
+// List<T>::RemoveFront
+//      Remove the first "item" from the front of the list.
+//	List must not be empty.
+//
+// Returns:
+//	The removed item.
+//----------------------------------------------------------------------
+
+template <class T>
+T List<T>::RemoveFront() {
+    ListElement<T> *element = first;
+    T thing;
+
+    ASSERT(!IsEmpty());
+
+    thing = first->item;
+    if (first == last) {  // list had one item, now has none
+        first = NULL;
+        last = NULL;
+    } else {
+        first = element->next;
+    }
+    numInList--;
+    delete element;
+    return thing;
+}
+
+//----------------------------------------------------------------------
+// List<T>::Remove
+//      Remove a specific item from the list.  Must be in the list!
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::Remove(T item) {
+    ListElement<T> *prev, *ptr;
+    T removed;
+
+    ASSERT(IsInList(item));
+
+    // if first item on list is match, then remove from front
+    if (item == first->item) {
+        removed = RemoveFront();
+        ASSERT(item == removed);
+    } else {
+        prev = first;
+        for (ptr = first->next; ptr != NULL; prev = ptr, ptr = ptr->next) {
+            if (item == ptr->item) {
+                prev->next = ptr->next;
+                if (prev->next == NULL) {
+                    last = prev;
+                }
+                delete ptr;
+                numInList--;
+                break;
+            }
+        }
+        ASSERT(ptr != NULL);  // should always find item!
+    }
+    ASSERT(!IsInList(item));
+}
+
+//----------------------------------------------------------------------
+// List<T>::IsInList
+//      Return TRUE if the item is in the list.
+//----------------------------------------------------------------------
+
+template <class T>
+bool List<T>::IsInList(T item) const {
+    ListElement<T> *ptr;
+
+    for (ptr = first; ptr != NULL; ptr = ptr->next) {
+        if (item == ptr->item) {
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+//----------------------------------------------------------------------
+// List<T>::Apply
+//      Apply function to every item on a list.
+//
+//	"func" -- the function to apply
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::Apply(void (*func)(T)) const {
+    ListElement<T> *ptr;
+
+    for (ptr = first; ptr != NULL; ptr = ptr->next) {
+        (*func)(ptr->item);
+    }
+}
+
+//----------------------------------------------------------------------
+// SortedList::Insert
+//      Insert an "item" into a list, so that the list elements are
+//	sorted in increasing order.
+//
+//	Allocate a ListElement to keep track of the item.
+//      If the list is empty, then this will be the only element.
+//	Otherwise, walk through the list, one element at a time,
+//	to find where the new item should be placed.
+//
+//	"item" is the thing to put on the list.
+//----------------------------------------------------------------------
+
+template <class T>
+void SortedList<T>::Insert(T item) {
+    ListElement<T> *element = new ListElement<T>(item);
+    ListElement<T> *ptr;  // keep track
+
+    ASSERT(!this->IsInList(item));
+    if (this->IsEmpty()) {  // if list is empty, put at front
+        this->first = element;
+        this->last = element;
+    } else if (compare(item, this->first->item) < 0) {  // item goes at front
+        element->next = this->first;
+        this->first = element;
+    } else {  // look for first elt in list bigger than item
+        for (ptr = this->first; ptr->next != NULL; ptr = ptr->next) {
+            if (compare(item, ptr->next->item) < 0) {
+                element->next = ptr->next;
+                ptr->next = element;
+                this->numInList++;
+                return;
+            }
+        }
+        this->last->next = element;  // item goes at end of list
+        this->last = element;
+    }
+    this->numInList++;
+    ASSERT(this->IsInList(item));
+}
+
+//----------------------------------------------------------------------
+// List::SanityCheck
+//      Test whether this is still a legal list.
+//
+//	Tests: do I get to last starting from first?
+//	       does the list have the right # of elements?
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::SanityCheck() const {
+    ListElement<T> *ptr;
+    int numFound;
+
+    if (first == NULL) {
+        ASSERT((numInList == 0) && (last == NULL));
+    } else if (first == last) {
+        ASSERT((numInList == 1) && (last->next == NULL));
+    } else {
+        for (numFound = 1, ptr = first; ptr != last; ptr = ptr->next) {
+            numFound++;
+            ASSERT(numFound <= numInList);  // prevent infinite loop
+        }
+        ASSERT(numFound == numInList);
+        ASSERT(last->next == NULL);
+    }
+}
+
+//----------------------------------------------------------------------
+// List::SelfTest
+//      Test whether this module is working.
+//----------------------------------------------------------------------
+
+template <class T>
+void List<T>::SelfTest(T *p, int numEntries) {
+    int i;
+    ListIterator<T> *iterator = new ListIterator<T>(this);
+
+    SanityCheck();
+    // check various ways that list is empty
+    ASSERT(IsEmpty() && (first == NULL));
+    for (; !iterator->IsDone(); iterator->Next()) {
+        ASSERTNOTREACHED();  // nothing on list
+    }
+
+    for (i = 0; i < numEntries; i++) {
+        Append(p[i]);
+        ASSERT(IsInList(p[i]));
+        ASSERT(!IsEmpty());
+    }
+    SanityCheck();
+
+    // should be able to get out everything we put in
+    for (i = 0; i < numEntries; i++) {
+        Remove(p[i]);
+        ASSERT(!IsInList(p[i]));
+    }
+    ASSERT(IsEmpty());
+    SanityCheck();
+    delete iterator;
+}
+
+//----------------------------------------------------------------------
+// SortedList::SanityCheck
+//      Test whether this is still a legal sorted list.
+//
+//	Test: is the list sorted?
+//----------------------------------------------------------------------
+
+template <class T>
+void SortedList<T>::SanityCheck() const {
+    ListElement<T> *prev, *ptr;
+
+    List<T>::SanityCheck();
+    if (this->first != this->last) {
+        for (prev = this->first, ptr = this->first->next; ptr != NULL;
+             prev = ptr, ptr = ptr->next) {
+            ASSERT(compare(prev->item, ptr->item) <= 0);
+        }
+    }
+}
+
+//----------------------------------------------------------------------
+// SortedList::SelfTest
+//      Test whether this module is working.
+//----------------------------------------------------------------------
+
+template <class T>
+void SortedList<T>::SelfTest(T *p, int numEntries) {
+    int i;
+    T *q = new T[numEntries];
+
+    List<T>::SelfTest(p, numEntries);
+
+    for (i = 0; i < numEntries; i++) {
+        Insert(p[i]);
+        ASSERT(this->IsInList(p[i]));
+    }
+    SanityCheck();
+
+    // should be able to get out everything we put in
+    for (i = 0; i < numEntries; i++) {
+        q[i] = this->RemoveFront();
+        ASSERT(!this->IsInList(q[i]));
+    }
+    ASSERT(this->IsEmpty());
+
+    // make sure everything came out in the right order
+    for (i = 0; i < (numEntries - 1); i++) {
+        ASSERT(compare(q[i], q[i + 1]) <= 0);
+    }
+    SanityCheck();
+
+    delete q;
+}
diff --git a/code/lib/list.h b/code/lib/list.h
new file mode 100644
index 0000000..3ce9553
--- /dev/null
+++ b/code/lib/list.h
@@ -0,0 +1,147 @@
+// list.h
+//	Data structures to manage LISP-like lists.
+//
+//      As in LISP, a list can contain any type of data structure
+//	as an item on the list: thread control blocks,
+//	pending interrupts, etc.  Allocation and deallocation of the
+//	items on the list are to be done by the caller.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef LIST_H
+#define LIST_H
+
+#include "copyright.h"
+#include "debug.h"
+
+// The following class defines a "list element" -- which is
+// used to keep track of one item on a list.  It is equivalent to a
+// LISP cell, with a "car" ("next") pointing to the next element on the list,
+// and a "cdr" ("item") pointing to the item on the list.
+//
+// This class is private to this module (and classes that inherit
+// from this module). Made public for notational convenience.
+
+template <class T>
+class ListElement {
+   public:
+    ListElement(T itm);  // initialize a list element
+    ListElement *next;   // next element on list, NULL if this is last
+    T item;              // item on the list
+};
+
+// The following class defines a "list" -- a singly linked list of
+// list elements, each of which points to a single item on the list.
+// The class has been tested only for primitive types (ints, pointers);
+// no guarantees it will work in general.  For instance, all types
+// to be inserted into a list must have a "==" operator defined.
+
+template <class T>
+class ListIterator;
+
+template <class T>
+class List {
+   public:
+    List();           // initialize the list
+    virtual ~List();  // de-allocate the list
+
+    virtual void Prepend(T item);  // Put item at the beginning of the list
+    virtual void Append(T item);   // Put item at the end of the list
+
+    T Front() { return first->item; }
+    // Return first item on list
+    // without removing it
+    T RemoveFront();      // Take item off the front of the list
+    void Remove(T item);  // Remove specific item from list
+
+    bool IsInList(T item) const;  // is the item in the list?
+
+    unsigned int NumInList() { return numInList; };
+    // how many items in the list?
+    bool IsEmpty() { return (numInList == 0); };
+    // is the list empty?
+
+    void Apply(void (*f)(T)) const;
+    // apply function to all elements in list
+
+    virtual void SanityCheck() const;
+    // has this list been corrupted?
+    void SelfTest(T *p, int numEntries);
+    // verify module is working
+
+   protected:
+    ListElement<T> *first;  // Head of the list, NULL if list is empty
+    ListElement<T> *last;   // Last element of list
+    int numInList;          // number of elements in list
+
+    friend class ListIterator<T>;
+};
+
+// The following class defines a "sorted list" -- a singly linked list of
+// list elements, arranged so that "Remove" always returns the smallest
+// element.
+// All types to be inserted onto a sorted list must have a "Compare"
+// function defined:
+//	   int Compare(T x, T y)
+//		returns -1 if x < y
+//		returns 0 if x == y
+//		returns 1 if x > y
+
+template <class T>
+class SortedList : public List<T> {
+   public:
+    SortedList(int (*comp)(T x, T y)) : List<T>() { compare = comp; };
+    ~SortedList(){};  // base class destructor called automatically
+
+    void Insert(T item);  // insert an item onto the list in sorted order
+
+    void SanityCheck() const;  // has this list been corrupted?
+    void SelfTest(T *p, int numEntries);
+    // verify module is working
+
+   private:
+    int (*compare)(T x, T y);  // function for sorting list elements
+
+    void Prepend(T item) {
+        Insert(item);
+    }                                      // *pre*pending has no meaning
+                                           //	in a sorted list
+    void Append(T item) { Insert(item); }  // neither does *ap*pend
+};
+
+// The following class can be used to step through a list.
+// Example code:
+//	ListIterator<T> *iter(list);
+//
+//	for (; !iter->IsDone(); iter->Next()) {
+//	    Operation on iter->Item()
+//      }
+
+template <class T>
+class ListIterator {
+   public:
+    ListIterator(List<T> *list) { current = list->first; }
+    // initialize an iterator
+
+    bool IsDone() { return current == NULL; };
+    // return TRUE if we are at the end of the list
+
+    T Item() {
+        ASSERT(!IsDone());
+        return current->item;
+    };
+    // return current element on list
+
+    void Next() { current = current->next; };
+    // update iterator to point to next
+
+   private:
+    ListElement<T> *current;  // where we are in the list
+};
+
+#include "list.cc"  // templates are really like macros
+// so needs to be included in every
+// file that uses the template
+#endif  // LIST_H
diff --git a/code/lib/sysdep.cc b/code/lib/sysdep.cc
new file mode 100644
index 0000000..162661c
--- /dev/null
+++ b/code/lib/sysdep.cc
@@ -0,0 +1,498 @@
+// sysdep.cc
+//	Implementation of system-dependent interface.  Nachos uses the
+//	routines defined here, rather than directly calling the UNIX library,
+//	to simplify porting between versions of UNIX, and even to
+//	other systems, such as MSDOS.
+//
+//	On UNIX, almost all of these routines are simple wrappers
+//	for the underlying UNIX system calls.
+//
+//	NOTE: all of these routines refer to operations on the underlying
+//	host machine (e.g., the DECstation, SPARC, etc.), supporting the
+//	Nachos simulation code.  Nachos implements similar operations,
+//	(such as opening a file), but those are implemented in terms
+//	of hardware devices, which are simulated by calls to the underlying
+//	routines in the host workstation OS.
+//
+//	This file includes lots of calls to C routines.  C++ requires
+//	us to wrap all C definitions with a "extern "C" block".
+// 	This prevents the internal forms of the names from being
+// 	changed by the C++ compiler.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "debug.h"
+#include "sysdep.h"
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/time.h>
+#include <sys/file.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <cerrno>
+
+#ifdef SOLARIS
+// KMS
+// for open()
+#include <fcntl.h>
+#endif
+
+#ifdef LINUX  // at this point, linux doesn't support mprotect
+#define NO_MPROT
+#endif
+#ifdef DOS  // neither does DOS
+#define NO_MPROT
+#endif
+
+extern "C" {
+#include <signal.h>
+#include <sys/types.h>
+
+#ifndef NO_MPROT
+#include <sys/mman.h>
+#endif
+
+// UNIX routines called by procedures in this file
+
+#if defined CYGWIN
+size_t getpagesize(void);
+#else
+int getpagesize(void);
+#endif
+unsigned sleep(unsigned);
+//#ifdef SOLARIS
+// int usleep(useconds_t);
+//#else
+// void usleep(unsigned int);  // rcgood - to avoid spinning processes.
+//#endif
+
+#ifndef NO_MPROT
+
+#ifdef OSF
+#define OSF_OR_AIX
+#endif
+#ifdef AIX
+#define OSF_OR_AIX
+#endif
+
+#ifdef OSF_OR_AIX
+int mprotect(const void *, long unsigned int, int);
+#else
+int mprotect(char *, unsigned int, int);
+#endif
+#endif
+
+#if defined(BSD) || defined(SOLARIS) || defined(LINUX)
+// KMS
+// added Solaris and LINUX
+int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+           struct timeval *timeout);
+#else
+int select(int numBits, void *readFds, void *writeFds, void *exceptFds,
+           struct timeval *timeout);
+#endif
+
+int socket(int, int, int);
+
+#if defined(SUNOS) || defined(ULTRIX)
+long tell(int);
+int bind(int, const void *, int);
+int recvfrom(int, void *, int, int, void *, int *);
+int sendto(int, const void *, int, int, void *, int);
+#endif
+}
+
+//----------------------------------------------------------------------
+// CallOnUserAbort
+// 	Arrange that "func" will be called when the user aborts (e.g., by
+//	hitting ctl-C.
+//----------------------------------------------------------------------
+
+void CallOnUserAbort(void (*func)(int)) { (void)signal(SIGINT, func); }
+
+//----------------------------------------------------------------------
+// Delay
+// 	Put the UNIX process running Nachos to sleep for x seconds,
+//	to give the user time to start up another invocation of Nachos
+//	in a different UNIX shell.
+//----------------------------------------------------------------------
+
+void Delay(int seconds) { (void)sleep((unsigned)seconds); }
+
+//----------------------------------------------------------------------
+// UDelay
+// 	Put the UNIX process running Nachos to sleep for x microseconds,
+//	to prevent an idle Nachos process from spinning...
+//----------------------------------------------------------------------
+
+void UDelay(unsigned int useconds) {
+    //#ifdef SOLARIS
+    //   usleep(useconds_t useconds);
+    //#else
+    //   usleep(useconds);
+    //#endif /* SOLARIS */
+}
+
+//----------------------------------------------------------------------
+// Abort
+// 	Quit and drop core.
+//----------------------------------------------------------------------
+
+void Abort() { abort(); }
+
+//----------------------------------------------------------------------
+// Exit
+// 	Quit without dropping core.
+//----------------------------------------------------------------------
+
+void Exit(int exitCode) { exit(exitCode); }
+
+//----------------------------------------------------------------------
+// RandomInit
+// 	Initialize the pseudo-random number generator.  We use the
+//	now obsolete "srand" and "rand" because they are more portable!
+//----------------------------------------------------------------------
+
+void RandomInit(unsigned seed) { srand(seed); }
+
+//----------------------------------------------------------------------
+// RandomNumber
+// 	Return a pseudo-random number.
+//----------------------------------------------------------------------
+
+unsigned int RandomNumber() { return rand(); }
+
+//----------------------------------------------------------------------
+// AllocBoundedArray
+// 	Return an array, with the two pages just before
+//	and after the array unmapped, to catch illegal references off
+//	the end of the array.  Particularly useful for catching overflow
+//	beyond fixed-size thread execution stacks.
+//
+//	Note: Just return the useful part!
+//
+//	"size" -- amount of useful space needed (in bytes)
+//----------------------------------------------------------------------
+
+char *AllocBoundedArray(int size) {
+#ifdef NO_MPROT
+    return new char[size];
+#else
+    int pgSize = getpagesize();
+    char *ptr = new char[pgSize * 2 + size];
+
+    mprotect(ptr, pgSize, 0);
+    mprotect(ptr + pgSize + size, pgSize, 0);
+    return ptr + pgSize;
+#endif
+}
+
+//----------------------------------------------------------------------
+// DeallocBoundedArray
+// 	Deallocate an array of integers, unprotecting its two boundary pages.
+//
+//	"ptr" -- the array to be deallocated
+//	"size" -- amount of useful space in the array (in bytes)
+//----------------------------------------------------------------------
+
+#ifdef NO_MPROT
+void DeallocBoundedArray(char *ptr, int /* size */) { delete[] ptr; }
+#else
+void DeallocBoundedArray(char *ptr, int size) {
+    int pgSize = getpagesize();
+
+    mprotect(ptr - pgSize, pgSize, PROT_READ | PROT_WRITE | PROT_EXEC);
+    mprotect(ptr + size, pgSize, PROT_READ | PROT_WRITE | PROT_EXEC);
+    delete[](ptr - pgSize);
+}
+#endif
+
+//----------------------------------------------------------------------
+// PollFile
+// 	Check open file or open socket to see if there are any
+//	characters that can be read immediately.  If so, read them
+//	in, and return TRUE.
+//
+//	"fd" -- the file descriptor of the file to be polled
+//----------------------------------------------------------------------
+
+bool PollFile(int fd) {
+#if defined(SOLARIS) || defined(LINUX)
+    // KMS
+    fd_set rfd, wfd, xfd;
+#else
+    int rfd = (1 << fd), wfd = 0, xfd = 0;
+#endif
+    int retVal;
+    struct timeval pollTime;
+
+#if defined(SOLARIS) || defined(LINUX)
+    // KMS
+    FD_ZERO(&rfd);
+    FD_ZERO(&wfd);
+    FD_ZERO(&xfd);
+    FD_SET(fd, &rfd);
+#endif
+
+    // don't wait if there are no characters on the file
+    pollTime.tv_sec = 0;
+    pollTime.tv_usec = 0;
+
+// poll file or socket
+#if defined(BSD)
+    retVal =
+        select(32, (fd_set *)&rfd, (fd_set *)&wfd, (fd_set *)&xfd, &pollTime);
+#elif defined(SOLARIS) || defined(LINUX)
+    // KMS
+    retVal = select(32, &rfd, &wfd, &xfd, &pollTime);
+#else
+    retVal = select(32, &rfd, &wfd, &xfd, &pollTime);
+#endif
+
+    ASSERT((retVal == 0) || (retVal == 1));
+    if (retVal == 0) return FALSE;  // no char waiting to be read
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// OpenForWrite
+// 	Open a file for writing.  Create it if it doesn't exist; truncate it
+//	if it does already exist.  Return the file descriptor.
+//
+//	"name" -- file name
+//----------------------------------------------------------------------
+
+int OpenForWrite(char *name) {
+    int fd = open(name, O_RDWR | O_CREAT | O_TRUNC, 0666);
+
+    ASSERT(fd >= 0);
+    return fd;
+}
+
+int OpenForRead(char *name, bool crashOnError) {
+    int fd = open(name, O_RDONLY, 0);
+
+    ASSERT(!crashOnError || fd >= 0);
+    return fd;
+}
+
+//----------------------------------------------------------------------
+// OpenForReadWrite
+// 	Open a file for reading or writing.
+//	Return the file descriptor, or error if it doesn't exist.
+//
+//	"name" -- file name
+//----------------------------------------------------------------------
+
+int OpenForReadWrite(char *name, bool crashOnError) {
+    int fd = open(name, O_RDWR, 0);
+
+    ASSERT(!crashOnError || fd >= 0);
+    return fd;
+}
+
+//----------------------------------------------------------------------
+// Read
+// 	Read characters from an open file.  Abort if read fails.
+//----------------------------------------------------------------------
+
+void Read(int fd, char *buffer, int nBytes) {
+    int retVal = read(fd, buffer, nBytes);
+    ASSERT(retVal == nBytes);
+}
+
+//----------------------------------------------------------------------
+// ReadPartial
+// 	Read characters from an open file, returning as many as are
+//	available.
+//----------------------------------------------------------------------
+
+int ReadPartial(int fd, char *buffer, int nBytes) {
+    return read(fd, buffer, nBytes);
+}
+
+//----------------------------------------------------------------------
+// WriteFile
+// 	Write characters to an open file.  Abort if write fails.
+//----------------------------------------------------------------------
+
+void WriteFile(int fd, char *buffer, int nBytes) {
+    int retVal = write(fd, buffer, nBytes);
+    ASSERT(retVal == nBytes);
+}
+
+//----------------------------------------------------------------------
+// Lseek
+// 	Change the location within an open file.  Abort on error.
+//----------------------------------------------------------------------
+
+void Lseek(int fd, int offset, int whence) {
+    int retVal = lseek(fd, offset, whence);
+    ASSERT(retVal >= 0);
+}
+
+//----------------------------------------------------------------------
+// Tell
+// 	Report the current location within an open file.
+//----------------------------------------------------------------------
+
+int Tell(int fd) {
+#if defined(BSD) || defined(SOLARIS) || defined(LINUX)
+    return lseek(fd, 0, SEEK_CUR);  // 386BSD doesn't have the tell() system
+                                    // call neither do Solaris and Linux  -KMS
+#else
+    return tell(fd);
+#endif
+}
+
+//----------------------------------------------------------------------
+// Close
+// 	Close a file.  Abort on error.
+//----------------------------------------------------------------------
+
+int Close(int fd) {
+    int retVal = close(fd);
+    ASSERT(retVal >= 0);
+    return retVal;
+}
+
+//----------------------------------------------------------------------
+// Unlink
+// 	Delete a file.
+//----------------------------------------------------------------------
+
+bool Unlink(char *name) { return unlink(name); }
+
+//----------------------------------------------------------------------
+// OpenSocket
+// 	Open an interprocess communication (IPC) connection.  For now,
+//	just open a datagram port where other Nachos (simulating
+//	workstations on a network) can send messages to this Nachos.
+//----------------------------------------------------------------------
+
+int OpenSocket() {
+    int sockID;
+
+    sockID = socket(AF_UNIX, SOCK_DGRAM, 0);
+    ASSERT(sockID >= 0);
+
+    return sockID;
+}
+
+//----------------------------------------------------------------------
+// CloseSocket
+// 	Close the IPC connection.
+//----------------------------------------------------------------------
+
+void CloseSocket(int sockID) { (void)close(sockID); }
+
+//----------------------------------------------------------------------
+// InitSocketName
+// 	Initialize a UNIX socket address -- magical!
+//----------------------------------------------------------------------
+
+static void InitSocketName(struct sockaddr_un *uname, char *name) {
+    uname->sun_family = AF_UNIX;
+    strcpy(uname->sun_path, name);
+}
+
+//----------------------------------------------------------------------
+// AssignNameToSocket
+// 	Give a UNIX file name to the IPC port, so other instances of Nachos
+//	can locate the port.
+//----------------------------------------------------------------------
+
+void AssignNameToSocket(char *socketName, int sockID) {
+    struct sockaddr_un uName;
+    int retVal;
+
+    (void)unlink(socketName);  // in case it's still around from last time
+
+    InitSocketName(&uName, socketName);
+    retVal = bind(sockID, (struct sockaddr *)&uName, sizeof(uName));
+    ASSERT(retVal >= 0);
+    DEBUG(dbgNet, "Created socket " << socketName);
+}
+
+//----------------------------------------------------------------------
+// DeAssignNameToSocket
+// 	Delete the UNIX file name we assigned to our IPC port, on cleanup.
+//----------------------------------------------------------------------
+void DeAssignNameToSocket(char *socketName) { (void)unlink(socketName); }
+
+//----------------------------------------------------------------------
+// PollSocket
+// 	Return TRUE if there are any messages waiting to arrive on the
+//	IPC port.
+//----------------------------------------------------------------------
+bool PollSocket(int sockID) {
+    return PollFile(sockID);  // on UNIX, socket ID's are just file ID's
+}
+
+//----------------------------------------------------------------------
+// ReadFromSocket
+// 	Read a fixed size packet off the IPC port.  Abort on error.
+//----------------------------------------------------------------------
+void ReadFromSocket(int sockID, char *buffer, int packetSize) {
+    int retVal;
+    struct sockaddr_un uName;
+#ifdef LINUX
+    socklen_t size = sizeof(uName);
+#else
+    int size = sizeof(uName);
+#endif
+
+    retVal = recvfrom(sockID, buffer, packetSize, 0, (struct sockaddr *)&uName,
+                      &size);
+
+    if (retVal != packetSize) {
+        perror("in recvfrom");
+#if defined CYGWIN
+        cerr << "called with " << packetSize << ", got back " << retVal
+             << ", and "
+             << "\n";
+#else
+        cerr << "called with " << packetSize << ", got back " << retVal
+             << ", and " << errno << "\n";
+#endif
+    }
+    ASSERT(retVal == packetSize);
+}
+
+//----------------------------------------------------------------------
+//    modified by KMS to add retry...
+// SendToSocket
+// 	Transmit a fixed size packet to another Nachos' IPC port.
+//	Try 10 times with a one second delay between attempts.
+//      This is useful, e.g., to give the other socket a chance
+//      to get set up.
+//      Terminate if we still fail after 10 tries.
+//----------------------------------------------------------------------
+void SendToSocket(int sockID, char *buffer, int packetSize, char *toName) {
+    struct sockaddr_un uName;
+    int retVal;
+    int retryCount;
+
+    InitSocketName(&uName, toName);
+
+    for (retryCount = 0; retryCount < 10; retryCount++) {
+        retVal = sendto(sockID, buffer, packetSize, 0,
+                        (struct sockaddr *)&uName, sizeof(uName));
+        if (retVal == packetSize) return;
+        // if we did not succeed, we should see a negative
+        // return value indicating complete failure.  If we
+        // don't, something fishy is going on...
+        ASSERT(retVal < 0);
+        // wait a second before trying again
+        Delay(1);
+    }
+    // At this point, we have failed many times
+    // The most common reason for this is that the target machine
+    // has halted and its socket no longer exists.
+    // We simply do nothing (drop the packet).
+    // This may mask other kinds of failures, but it is the
+    // right thing to do in the common case.
+}
diff --git a/code/lib/sysdep.h b/code/lib/sysdep.h
new file mode 100644
index 0000000..441712f
--- /dev/null
+++ b/code/lib/sysdep.h
@@ -0,0 +1,77 @@
+// sysdep.h
+//	System-dependent interface.  Nachos uses the routines defined
+//	here, rather than directly calling the UNIX library functions, to
+//	simplify porting between versions of UNIX, and even to
+//	other systems, such as MSDOS and the Macintosh.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef SYSDEP_H
+#define SYSDEP_H
+
+#include "copyright.h"
+#include <iostream>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+using namespace std;
+
+// Process control: abort, exit, and sleep
+extern void Abort();
+extern void Exit(int exitCode);
+extern void Delay(int seconds);
+extern void UDelay(unsigned int usec);  // rcgood - to avoid spinners.
+
+// Initialize system so that cleanUp routine is called when user hits ctl-C
+extern void CallOnUserAbort(void (*cleanup)(int));
+
+// Initialize the pseudo random number generator
+extern void RandomInit(unsigned seed);
+extern unsigned int RandomNumber();
+
+// Allocate, de-allocate an array, such that de-referencing
+// just beyond either end of the array will cause an error
+extern char *AllocBoundedArray(int size);
+extern void DeallocBoundedArray(char *p, int size);
+
+// Check file to see if there are any characters to be read.
+// If no characters in the file, return without waiting.
+extern bool PollFile(int fd);
+
+// File operations: open/read/write/lseek/close, and check for error
+// For simulating the disk and the console devices.
+extern int OpenForWrite(char *name);
+extern int OpenForRead(char *name, bool crashOnError);
+extern int OpenForReadWrite(char *name, bool crashOnError);
+extern void Read(int fd, char *buffer, int nBytes);
+extern int ReadPartial(int fd, char *buffer, int nBytes);
+extern void WriteFile(int fd, char *buffer, int nBytes);
+extern void Lseek(int fd, int offset, int whence);
+extern int Tell(int fd);
+extern int Close(int fd);
+extern bool Unlink(char *name);
+
+// Other C library routines that are used by Nachos.
+// These are assumed to be portable, so we don't include a wrapper.
+extern "C" {
+int atoi(const char *str);
+double atof(const char *str);
+int abs(int i);
+void bcopy(const void *s1, void *s2, size_t n);
+void bzero(void *s, size_t n);
+}
+
+// Interprocess communication operations, for simulating the network
+extern int OpenSocket();
+extern void CloseSocket(int sockID);
+extern void AssignNameToSocket(char *socketName, int sockID);
+extern void DeAssignNameToSocket(char *socketName);
+extern bool PollSocket(int sockID);
+extern void ReadFromSocket(int sockID, char *buffer, int packetSize);
+extern void SendToSocket(int sockID, char *buffer, int packetSize,
+                         char *toName);
+
+#endif  // SYSDEP_H
diff --git a/code/lib/utility.h b/code/lib/utility.h
new file mode 100644
index 0000000..b1c3bdb
--- /dev/null
+++ b/code/lib/utility.h
@@ -0,0 +1,38 @@
+// utility.h
+//	Miscellaneous useful definitions.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef UTILITY_H
+#define UTILITY_H
+
+#include "copyright.h"
+
+// Miscellaneous useful routines
+
+#define NULL 0
+#define TRUE true
+#define FALSE false
+// #define bool int		// necessary on the Mac?
+
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#define max(a, b) (((a) > (b)) ? (a) : (b))
+
+// Divide and either round up or down
+#define divRoundDown(n, s) ((n) / (s))
+#define divRoundUp(n, s) (((n) / (s)) + ((((n) % (s)) > 0) ? 1 : 0))
+
+// This declares the type "VoidFunctionPtr" to be a "pointer to a
+// function taking an arbitrary pointer argument and returning nothing".  With
+// such a function pointer (say it is "func"), we can call it like this:
+//
+//	(*func) ("help!");
+//
+// This is used by Thread::Fork as well as a couple of other places.
+
+typedef void (*VoidFunctionPtr)(void *arg);
+typedef void (*VoidNoArgFunctionPtr)();
+
+#endif  // UTILITY_H
diff --git a/code/machine/callback.h b/code/machine/callback.h
new file mode 100644
index 0000000..e09afa1
--- /dev/null
+++ b/code/machine/callback.h
@@ -0,0 +1,45 @@
+// callback.h
+//	Data structure to allow an object to register a "callback".
+//	On an asynchronous operation, the call to start the operation
+//	returns immediately.  When the operation completes, the called
+//	object must somehow notify the caller of the completion.
+//	In the general case, the called object doesn't know the type
+//	of the caller.
+//
+//	We implement this using virtual functions in C++.  An object
+//	that needs to register a callback is set up as a derived class of
+//	the abstract base class "CallbackObj".  When we pass a
+//	pointer to the object to a lower level module, that module
+//	calls back via "obj->CallBack()", without knowing the
+//	type of the object being called back.
+//
+// 	Note that this isn't a general-purpose mechanism,
+//	because a class can only register a single callback.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+//
+
+#ifndef CALLBACK_H
+#define CALLBACK_H
+
+#include "copyright.h"
+
+// Abstract base class for objects that register callbacks
+
+class CallBackObj {
+   public:
+    virtual void CallBack() = 0;
+
+   protected:
+    CallBackObj(){};  // to prevent anyone from creating
+                      // an instance of this class.  Only
+                      // allow creation of instances of
+                      // classes derived from this class.
+    virtual ~CallBackObj(){};
+};
+
+#endif
diff --git a/code/machine/console.cc b/code/machine/console.cc
new file mode 100644
index 0000000..3ad662b
--- /dev/null
+++ b/code/machine/console.cc
@@ -0,0 +1,155 @@
+// console.cc
+//	Routines to simulate a serial port to a console device.
+//	A console has input (a keyboard) and output (a display).
+//	These are each simulated by operations on UNIX files.
+//	The simulated device is asynchronous, so we have to invoke
+//	the interrupt handler (after a simulated delay), to signal that
+//	a byte has arrived and/or that a written byte has departed.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "console.h"
+#include "main.h"
+
+//----------------------------------------------------------------------
+// ConsoleInput::ConsoleInput
+// 	Initialize the simulation of the input for a hardware console device.
+//
+//	"readFile" -- UNIX file simulating the keyboard (NULL -> use stdin)
+// 	"toCall" is the interrupt handler to call when a character arrives
+//		from the keyboard
+//----------------------------------------------------------------------
+
+ConsoleInput::ConsoleInput(char *readFile, CallBackObj *toCall) {
+    if (readFile == NULL)
+        readFileNo = 0;  // keyboard = stdin
+    else
+        readFileNo = OpenForReadWrite(readFile, TRUE);  // should be read-only
+
+    // set up the stuff to emulate asynchronous interrupts
+    callWhenAvail = toCall;
+    incoming = EOF;
+
+    // start polling for incoming keystrokes
+    kernel->interrupt->Schedule(this, ConsoleTime, ConsoleReadInt);
+}
+
+//----------------------------------------------------------------------
+// ConsoleInput::~ConsoleInput
+// 	Clean up console input emulation
+//----------------------------------------------------------------------
+
+ConsoleInput::~ConsoleInput() {
+    if (readFileNo != 0) Close(readFileNo);
+}
+
+//----------------------------------------------------------------------
+// ConsoleInput::CallBack()
+// 	Simulator calls this when a character may be available to be
+//	read in from the simulated keyboard (eg, the user typed something).
+//
+//	First check to make sure character is available.
+//	Then invoke the "callBack" registered by whoever wants the character.
+//----------------------------------------------------------------------
+
+void ConsoleInput::CallBack() {
+    char c;
+    int readCount;
+
+    ASSERT(incoming == EOF);
+    if (!PollFile(readFileNo)) {  // nothing to be read
+        // schedule the next time to poll for a packet
+        kernel->interrupt->Schedule(this, ConsoleTime, ConsoleReadInt);
+    } else {
+        // otherwise, try to read a character
+        readCount = ReadPartial(readFileNo, &c, sizeof(char));
+        if (readCount == 0) {
+            // this seems to happen at end of file, when the
+            // console input is a regular file
+            // don't schedule an interrupt, since there will never
+            // be any more input
+            // just do nothing....
+        } else {
+            // save the character and notify the OS that
+            // it is available
+            ASSERT(readCount == sizeof(char));
+            incoming = c;
+            kernel->stats->numConsoleCharsRead++;
+        }
+        callWhenAvail->CallBack();
+    }
+}
+
+//----------------------------------------------------------------------
+// ConsoleInput::GetChar()
+// 	Read a character from the input buffer, if there is any there.
+//	Either return the character, or EOF if none buffered.
+//----------------------------------------------------------------------
+
+char ConsoleInput::GetChar() {
+    char ch = incoming;
+
+    if (incoming != EOF) {  // schedule when next char will arrive
+        kernel->interrupt->Schedule(this, ConsoleTime, ConsoleReadInt);
+    }
+    incoming = EOF;
+    return ch;
+}
+
+//----------------------------------------------------------------------
+// ConsoleOutput::ConsoleOutput
+// 	Initialize the simulation of the output for a hardware console device.
+//
+//	"writeFile" -- UNIX file simulating the display (NULL -> use stdout)
+// 	"toCall" is the interrupt handler to call when a write to
+//	the display completes.
+//----------------------------------------------------------------------
+
+ConsoleOutput::ConsoleOutput(char *writeFile, CallBackObj *toCall) {
+    if (writeFile == NULL)
+        writeFileNo = 1;  // display = stdout
+    else
+        writeFileNo = OpenForWrite(writeFile);
+
+    callWhenDone = toCall;
+    putBusy = FALSE;
+}
+
+//----------------------------------------------------------------------
+// ConsoleOutput::~ConsoleOutput
+// 	Clean up console output emulation
+//----------------------------------------------------------------------
+
+ConsoleOutput::~ConsoleOutput() {
+    if (writeFileNo != 1) Close(writeFileNo);
+}
+
+//----------------------------------------------------------------------
+// ConsoleOutput::CallBack()
+// 	Simulator calls this when the next character can be output to the
+//	display.
+//----------------------------------------------------------------------
+
+void ConsoleOutput::CallBack() {
+    putBusy = FALSE;
+    kernel->stats->numConsoleCharsWritten++;
+    callWhenDone->CallBack();
+}
+
+//----------------------------------------------------------------------
+// ConsoleOutput::PutChar()
+// 	Write a character to the simulated display, schedule an interrupt
+//	to occur in the future, and return.
+//----------------------------------------------------------------------
+
+void ConsoleOutput::PutChar(char ch) {
+    ASSERT(putBusy == FALSE);
+    WriteFile(writeFileNo, &ch, sizeof(char));
+    putBusy = TRUE;
+    kernel->interrupt->Schedule(this, ConsoleTime, ConsoleWriteInt);
+}
diff --git a/code/machine/console.h b/code/machine/console.h
new file mode 100644
index 0000000..a88186c
--- /dev/null
+++ b/code/machine/console.h
@@ -0,0 +1,91 @@
+// console.h
+//	Data structures to simulate the behavior of a terminal
+//	I/O device.  A terminal has two parts -- a keyboard input,
+//	and a display output, each of which produces/accepts
+//	characters sequentially.
+//
+//	The console hardware device is asynchronous.  When a character is
+//	written to the device, the routine returns immediately, and an
+//	interrupt handler is called later when the I/O completes.
+//	For reads, an interrupt handler is called when a character arrives.
+//
+//	In either case, the serial line connecting the computer
+//	to the console has limited bandwidth (like a modem!), and so
+//	each character takes measurable time.
+//
+//	The user of the device registers itself to be called "back" when
+//	the read/write interrupts occur.  There is a separate interrupt
+//	for read and write, and the device is "duplex" -- a character
+//	can be outgoing and incoming at the same time.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef CONSOLE_H
+#define CONSOLE_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+
+// The following two classes define the input (and output) side of a
+// hardware console device.  Input (and output) to the device is simulated
+// by reading (and writing) to the UNIX file "readFile" (and "writeFile").
+//
+// Since input (and output) to the device is asynchronous, the interrupt
+// handler "callWhenAvail" is called when a character has arrived to be
+// read in (and "callWhenDone" is called when an output character has been
+// "put" so that the next character can be written).
+//
+// In practice, usually a single hardware thing that does both
+// serial input and serial output.  But conceptually simpler to
+// use two objects.
+
+class ConsoleInput : public CallBackObj {
+   public:
+    ConsoleInput(char *readFile, CallBackObj *toCall);
+    // initialize hardware console input
+    ~ConsoleInput();  // clean up console emulation
+
+    char GetChar();  // Poll the console input.  If a char is
+                     // available, return it.  Otherwise, return EOF.
+                     // "callWhenAvail" is called whenever there is
+    // a char to be gotten
+
+    void CallBack();  // Invoked when a character arrives
+                      // from the keyboard.
+
+   private:
+    int readFileNo;              // UNIX file emulating the keyboard
+    CallBackObj *callWhenAvail;  // Interrupt handler to call when
+                                 // there is a char to be read
+    char incoming;               // Contains the character to be read,
+                                 // if there is one available.
+                                 // Otherwise contains EOF.
+};
+
+class ConsoleOutput : public CallBackObj {
+   public:
+    ConsoleOutput(char *writeFile, CallBackObj *toCall);
+    // initialize hardware console output
+    ~ConsoleOutput();  // clean up console emulation
+
+    void PutChar(char ch);  // Write "ch" to the console display,
+                            // and return immediately.  "callWhenDone"
+                            // will called when the I/O completes.
+
+    void CallBack();  // Invoked when next character can be put
+                      // out to the display.
+
+   private:
+    int writeFileNo;            // UNIX file emulating the display
+    CallBackObj *callWhenDone;  // Interrupt handler to call when
+                                // the next char can be put
+    bool putBusy;               // Is a PutChar operation in progress?
+                                // If so, you can't do another one!
+};
+
+#endif  // CONSOLE_H
diff --git a/code/machine/disk.cc b/code/machine/disk.cc
new file mode 100644
index 0000000..e871e72
--- /dev/null
+++ b/code/machine/disk.cc
@@ -0,0 +1,245 @@
+// disk.cc
+//	Routines to simulate a physical disk device; reading and writing
+//	to the disk is simulated as reading and writing to a UNIX file.
+//	See disk.h for details about the behavior of disks (and
+//	therefore about the behavior of this simulation).
+//
+//	Disk operations are asynchronous, so we have to invoke an interrupt
+//	handler when the simulated operation completes.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "disk.h"
+#include "debug.h"
+#include "sysdep.h"
+#include "main.h"
+
+// We put a magic number at the front of the UNIX file representing the
+// disk, to make it less likely we will accidentally treat a useful file
+// as a disk (which would probably trash the file's contents).
+
+const int MagicNumber = 0x456789ab;
+const int MagicSize = sizeof(int);
+const int DiskSize = (MagicSize + (NumSectors * SectorSize));
+
+//----------------------------------------------------------------------
+// Disk::Disk()
+// 	Initialize a simulated disk.  Open the UNIX file (creating it
+//	if it doesn't exist), and check the magic number to make sure it's
+// 	ok to treat it as Nachos disk storage.
+//
+//	"toCall" -- object to call when disk read/write request completes
+//----------------------------------------------------------------------
+
+Disk::Disk(CallBackObj *toCall) {
+    int magicNum;
+    int tmp = 0;
+
+    DEBUG(dbgDisk, "Initializing the disk.");
+    callWhenDone = toCall;
+    lastSector = 0;
+    bufferInit = 0;
+
+    sprintf(diskname, "DISK_%d", kernel->hostName);
+    fileno = OpenForReadWrite(diskname, FALSE);
+    if (fileno >= 0) {  // file exists, check magic number
+        Read(fileno, (char *)&magicNum, MagicSize);
+        ASSERT(magicNum == MagicNumber);
+    } else {  // file doesn't exist, create it
+        fileno = OpenForWrite(diskname);
+        magicNum = MagicNumber;
+        WriteFile(fileno, (char *)&magicNum, MagicSize);  // write magic number
+
+        // need to write at end of file, so that reads will not return EOF
+        Lseek(fileno, DiskSize - sizeof(int), 0);
+        WriteFile(fileno, (char *)&tmp, sizeof(int));
+    }
+    active = FALSE;
+}
+
+//----------------------------------------------------------------------
+// Disk::~Disk()
+// 	Clean up disk simulation, by closing the UNIX file representing the
+//	disk.
+//----------------------------------------------------------------------
+
+Disk::~Disk() { Close(fileno); }
+
+//----------------------------------------------------------------------
+// Disk::PrintSector()
+// 	Dump the data in a disk read/write request, for debugging.
+//----------------------------------------------------------------------
+
+static void PrintSector(bool writing, int sector, char *data) {
+    int *p = (int *)data;
+
+    if (writing)
+        cout << "Writing sector: " << sector << "\n";
+    else
+        cout << "Reading sector: " << sector << "\n";
+    for (unsigned int i = 0; i < (SectorSize / sizeof(int)); i++) {
+        cout << p[i] << " ";
+    }
+    cout << "\n";
+}
+
+//----------------------------------------------------------------------
+// Disk::ReadRequest/WriteRequest
+// 	Simulate a request to read/write a single disk sector
+//	   Do the read/write immediately to the UNIX file
+//	   Set up an interrupt handler to be called later,
+//	      that will notify the caller when the simulator says
+//	      the operation has completed.
+//
+//	Note that a disk only allows an entire sector to be read/written,
+//	not part of a sector.
+//
+//	"sectorNumber" -- the disk sector to read/write
+//	"data" -- the bytes to be written, the buffer to hold the incoming bytes
+//----------------------------------------------------------------------
+
+void Disk::ReadRequest(int sectorNumber, char *data) {
+    int ticks = ComputeLatency(sectorNumber, FALSE);
+
+    ASSERT(!active);  // only one request at a time
+    ASSERT((sectorNumber >= 0) && (sectorNumber < NumSectors));
+
+    DEBUG(dbgDisk, "Reading from sector " << sectorNumber);
+    Lseek(fileno, SectorSize * sectorNumber + MagicSize, 0);
+    Read(fileno, data, SectorSize);
+    if (debug->IsEnabled('d')) PrintSector(FALSE, sectorNumber, data);
+
+    active = TRUE;
+    UpdateLast(sectorNumber);
+    kernel->stats->numDiskReads++;
+    kernel->interrupt->Schedule(this, ticks, DiskInt);
+}
+
+void Disk::WriteRequest(int sectorNumber, char *data) {
+    int ticks = ComputeLatency(sectorNumber, TRUE);
+
+    ASSERT(!active);
+    ASSERT((sectorNumber >= 0) && (sectorNumber < NumSectors));
+
+    DEBUG(dbgDisk, "Writing to sector " << sectorNumber);
+    Lseek(fileno, SectorSize * sectorNumber + MagicSize, 0);
+    WriteFile(fileno, data, SectorSize);
+    if (debug->IsEnabled('d')) PrintSector(TRUE, sectorNumber, data);
+
+    active = TRUE;
+    UpdateLast(sectorNumber);
+    kernel->stats->numDiskWrites++;
+    kernel->interrupt->Schedule(this, ticks, DiskInt);
+}
+
+//----------------------------------------------------------------------
+// Disk::CallBack()
+// 	Called by the machine simulation when the disk interrupt occurs.
+//----------------------------------------------------------------------
+
+void Disk::CallBack() {
+    active = FALSE;
+    callWhenDone->CallBack();
+}
+
+//----------------------------------------------------------------------
+// Disk::TimeToSeek()
+//	Returns how long it will take to position the disk head over the correct
+//	track on the disk.  Since when we finish seeking, we are likely
+//	to be in the middle of a sector that is rotating past the head,
+//	we also return how long until the head is at the next sector boundary.
+//
+//   	Disk seeks at one track per SeekTime ticks (cf. stats.h)
+//   	and rotates at one sector per RotationTime ticks
+//----------------------------------------------------------------------
+
+int Disk::TimeToSeek(int newSector, int *rotation) {
+    int newTrack = newSector / SectorsPerTrack;
+    int oldTrack = lastSector / SectorsPerTrack;
+    int seek = abs(newTrack - oldTrack) * SeekTime;
+    // how long will seek take?
+    int over = (kernel->stats->totalTicks + seek) % RotationTime;
+    // will we be in the middle of a sector when
+    // we finish the seek?
+
+    *rotation = 0;
+    if (over > 0)  // if so, need to round up to next full sector
+        *rotation = RotationTime - over;
+    return seek;
+}
+
+//----------------------------------------------------------------------
+// Disk::ModuloDiff()
+// 	Return number of sectors of rotational delay between target sector
+//	"to" and current sector position "from"
+//----------------------------------------------------------------------
+
+int Disk::ModuloDiff(int to, int from) {
+    int toOffset = to % SectorsPerTrack;
+    int fromOffset = from % SectorsPerTrack;
+
+    return ((toOffset - fromOffset) + SectorsPerTrack) % SectorsPerTrack;
+}
+
+//----------------------------------------------------------------------
+// Disk::ComputeLatency()
+// 	Return how long will it take to read/write a disk sector, from
+//	the current position of the disk head.
+//
+//   	Latency = seek time + rotational latency + transfer time
+//   	Disk seeks at one track per SeekTime ticks (cf. stats.h)
+//   	and rotates at one sector per RotationTime ticks
+//
+//   	To find the rotational latency, we first must figure out where the
+//   	disk head will be after the seek (if any).  We then figure out
+//   	how long it will take to rotate completely past newSector after
+//	that point.
+//
+//   	The disk also has a "track buffer"; the disk continuously reads
+//   	the contents of the current disk track into the buffer.  This allows
+//   	read requests to the current track to be satisfied more quickly.
+//   	The contents of the track buffer are discarded after every seek to
+//   	a new track.
+//----------------------------------------------------------------------
+
+int Disk::ComputeLatency(int newSector, bool writing) {
+    int rotation;
+    int seek = TimeToSeek(newSector, &rotation);
+    int timeAfter = kernel->stats->totalTicks + seek + rotation;
+
+#ifndef NOTRACKBUF  // turn this on if you don't want the track buffer stuff
+    // check if track buffer applies
+    if ((writing == FALSE) && (seek == 0) &&
+        (((timeAfter - bufferInit) / RotationTime) >
+         ModuloDiff(newSector, bufferInit / RotationTime))) {
+        DEBUG(dbgDisk, "Request latency = " << RotationTime);
+        return RotationTime;  // time to transfer sector from the track buffer
+    }
+#endif
+
+    rotation += ModuloDiff(newSector, timeAfter / RotationTime) * RotationTime;
+
+    DEBUG(dbgDisk, "Request latency = " << (seek + rotation + RotationTime));
+    return (seek + rotation + RotationTime);
+}
+
+//----------------------------------------------------------------------
+// Disk::UpdateLast
+//   	Keep track of the most recently requested sector.  So we can know
+//	what is in the track buffer.
+//----------------------------------------------------------------------
+
+void Disk::UpdateLast(int newSector) {
+    int rotate;
+    int seek = TimeToSeek(newSector, &rotate);
+
+    if (seek != 0) bufferInit = kernel->stats->totalTicks + seek + rotate;
+    lastSector = newSector;
+    DEBUG(dbgDisk,
+          "Updating last sector = " << lastSector << " , " << bufferInit);
+}
diff --git a/code/machine/disk.h b/code/machine/disk.h
new file mode 100644
index 0000000..4bdb8f7
--- /dev/null
+++ b/code/machine/disk.h
@@ -0,0 +1,92 @@
+// disk.h
+//	Data structures to emulate a physical disk.  A physical disk
+//	can accept (one at a time) requests to read/write a disk sector;
+//	when the request is satisfied, the CPU gets an interrupt, and
+//	the next request can be sent to the disk.
+//
+//	Disk contents are preserved across machine crashes, but if
+//	a file system operation (eg, create a file) is in progress when the
+//	system shuts down, the file system may be corrupted.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef DISK_H
+#define DISK_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+
+// The following class defines a physical disk I/O device.  The disk
+// has a single surface, split up into "tracks", and each track split
+// up into "sectors" (the same number of sectors on each track, and each
+// sector has the same number of bytes of storage).
+//
+// Addressing is by sector number -- each sector on the disk is given
+// a unique number: track * SectorsPerTrack + offset within a track.
+//
+// As with other I/O devices, the raw physical disk is an asynchronous device --
+// requests to read or write portions of the disk return immediately,
+// and an interrupt is invoked later to signal that the operation completed.
+//
+// The physical disk is in fact simulated via operations on a UNIX file.
+//
+// To make life a little more realistic, the simulated time for
+// each operation reflects a "track buffer" -- RAM to store the contents
+// of the current track as the disk head passes by.  The idea is that the
+// disk always transfers to the track buffer, in case that data is requested
+// later on.  This has the benefit of eliminating the need for
+// "skip-sector" scheduling -- a read request which comes in shortly after
+// the head has passed the beginning of the sector can be satisfied more
+// quickly, because its contents are in the track buffer.  Most
+// disks these days now come with a track buffer.
+//
+// The track buffer simulation can be disabled by compiling with -DNOTRACKBUF
+
+const int SectorSize = 128;      // number of bytes per disk sector
+const int SectorsPerTrack = 32;  // number of sectors per disk track
+const int NumTracks = 32;        // number of tracks per disk
+const int NumSectors = (SectorsPerTrack * NumTracks);
+// total # of sectors per disk
+
+class Disk : public CallBackObj {
+   public:
+    Disk(CallBackObj *toCall);  // Create a simulated disk.
+                                // Invoke toCall->CallBack()
+                                // when each request completes.
+    ~Disk();                    // Deallocate the disk.
+
+    void ReadRequest(int sectorNumber, char *data);
+    // Read/write an single disk sector.
+    // These routines send a request to
+    // the disk and return immediately.
+    // Only one request allowed at a time!
+    void WriteRequest(int sectorNumber, char *data);
+
+    void CallBack();  // Invoked when disk request
+                      // finishes. In turn calls, callWhenDone.
+
+    int ComputeLatency(int newSector, bool writing);
+    // Return how long a request to
+    // newSector will take:
+    // (seek + rotational delay + transfer)
+
+   private:
+    int fileno;                 // UNIX file number for simulated disk
+    char diskname[32];          // name of simulated disk's file
+    CallBackObj *callWhenDone;  // Invoke when any disk request finishes
+    bool active;                // Is a disk operation in progress?
+    int lastSector;             // The previous disk request
+    int bufferInit;             // When the track buffer started
+                                // being loaded
+
+    int TimeToSeek(int newSector, int *rotate);  // time to get to the new track
+    int ModuloDiff(int to, int from);  // # sectors between to and from
+    void UpdateLast(int newSector);
+};
+
+#endif  // DISK_H
diff --git a/code/machine/interrupt.cc b/code/machine/interrupt.cc
new file mode 100644
index 0000000..4ed8291
--- /dev/null
+++ b/code/machine/interrupt.cc
@@ -0,0 +1,330 @@
+// interrupt.cc
+//	Routines to simulate hardware interrupts.
+//
+//	The hardware provides a routine (SetLevel) to enable or disable
+//	interrupts.
+//
+//	In order to emulate the hardware, we need to keep track of all
+//	interrupts the hardware devices would cause, and when they
+//	are supposed to occur.
+//
+//	This module also keeps track of simulated time.  Time advances
+//	only when the following occur:
+//		interrupts are re-enabled
+//		a user instruction is executed
+//		there is nothing in the ready queue
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "interrupt.h"
+#include "main.h"
+
+// String definitions for debugging messages
+
+static char *intLevelNames[] = {"off", "on"};
+static char *intTypeNames[] = {"timer",        "disk",         "console write",
+                               "console read", "network send", "network recv"};
+
+//----------------------------------------------------------------------
+// PendingInterrupt::PendingInterrupt
+// 	Initialize a hardware device interrupt that is to be scheduled
+//	to occur in the near future.
+//
+//	"callOnInt" is the object to call when the interrupt occurs
+//	"time" is when (in simulated time) the interrupt is to occur
+//	"kind" is the hardware device that generated the interrupt
+//----------------------------------------------------------------------
+
+PendingInterrupt::PendingInterrupt(CallBackObj *callOnInt, int time,
+                                   IntType kind) {
+    callOnInterrupt = callOnInt;
+    when = time;
+    type = kind;
+}
+
+//----------------------------------------------------------------------
+// PendingCompare
+//	Compare to interrupts based on which should occur first.
+//----------------------------------------------------------------------
+
+static int PendingCompare(PendingInterrupt *x, PendingInterrupt *y) {
+    if (x->when < y->when) {
+        return -1;
+    } else if (x->when > y->when) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+//----------------------------------------------------------------------
+// Interrupt::Interrupt
+// 	Initialize the simulation of hardware device interrupts.
+//
+//	Interrupts start disabled, with no interrupts pending, etc.
+//----------------------------------------------------------------------
+
+Interrupt::Interrupt() {
+    level = IntOff;
+    pending = new SortedList<PendingInterrupt *>(PendingCompare);
+    inHandler = FALSE;
+    yieldOnReturn = FALSE;
+    status = SystemMode;
+}
+
+//----------------------------------------------------------------------
+// Interrupt::~Interrupt
+// 	De-allocate the data structures needed by the interrupt simulation.
+//----------------------------------------------------------------------
+
+Interrupt::~Interrupt() {
+    while (!pending->IsEmpty()) {
+        delete pending->RemoveFront();
+    }
+    delete pending;
+}
+
+//----------------------------------------------------------------------
+// Interrupt::ChangeLevel
+// 	Change interrupts to be enabled or disabled, without advancing
+//	the simulated time (normally, enabling interrupts advances the time).
+//
+//	Used internally.
+//
+//	"old" -- the old interrupt status
+//	"now" -- the new interrupt status
+//----------------------------------------------------------------------
+
+void Interrupt::ChangeLevel(IntStatus old, IntStatus now) {
+    level = now;
+    DEBUG(dbgInt, "\tinterrupts: " << intLevelNames[old] << " -> "
+                                   << intLevelNames[now]);
+}
+
+//----------------------------------------------------------------------
+// Interrupt::SetLevel
+// 	Change interrupts to be enabled or disabled, and if interrupts
+//	are being enabled, advance simulated time by calling OneTick().
+//
+// Returns:
+//	The old interrupt status.
+// Parameters:
+//	"now" -- the new interrupt status
+//----------------------------------------------------------------------
+
+IntStatus Interrupt::SetLevel(IntStatus now) {
+    IntStatus old = level;
+
+    // interrupt handlers are prohibited from enabling interrupts
+    ASSERT((now == IntOff) || (inHandler == FALSE));
+
+    ChangeLevel(old, now);  // change to new state
+    if ((now == IntOn) && (old == IntOff)) {
+        OneTick();  // advance simulated time
+    }
+    return old;
+}
+
+//----------------------------------------------------------------------
+// Interrupt::OneTick
+// 	Advance simulated time and check if there are any pending
+//	interrupts to be called.
+//
+//	Two things can cause OneTick to be called:
+//		interrupts are re-enabled
+//		a user instruction is executed
+//----------------------------------------------------------------------
+void Interrupt::OneTick() {
+    MachineStatus oldStatus = status;
+    Statistics *stats = kernel->stats;
+
+    // advance simulated time
+    if (status == SystemMode) {
+        stats->totalTicks += SystemTick;
+        stats->systemTicks += SystemTick;
+    } else {
+        stats->totalTicks += UserTick;
+        stats->userTicks += UserTick;
+    }
+    DEBUG(dbgInt, "== Tick " << stats->totalTicks << " ==");
+
+    // check any pending interrupts are now ready to fire
+    ChangeLevel(IntOn, IntOff);  // first, turn off interrupts
+                                 // (interrupt handlers run with
+                                 // interrupts disabled)
+    CheckIfDue(FALSE);           // check for pending interrupts
+    ChangeLevel(IntOff, IntOn);  // re-enable interrupts
+    if (yieldOnReturn) {         // if the timer device handler asked
+                                 // for a context switch, ok to do it now
+        yieldOnReturn = FALSE;
+        status = SystemMode;  // yield is a kernel routine
+        kernel->currentThread->Yield();
+        status = oldStatus;
+    }
+}
+
+//----------------------------------------------------------------------
+// Interrupt::YieldOnReturn
+// 	Called from within an interrupt handler, to cause a context switch
+//	(for example, on a time slice) in the interrupted thread,
+//	when the handler returns.
+//
+//	We can't do the context switch here, because that would switch
+//	out the interrupt handler, and we want to switch out the
+//	interrupted thread.
+//----------------------------------------------------------------------
+
+void Interrupt::YieldOnReturn() {
+    ASSERT(inHandler == TRUE);
+    yieldOnReturn = TRUE;
+}
+
+//----------------------------------------------------------------------
+// Interrupt::Idle
+// 	Routine called when there is nothing in the ready queue.
+//
+//	Since something has to be running in order to put a thread
+//	on the ready queue, the only thing to do is to advance
+//	simulated time until the next scheduled hardware interrupt.
+//
+//	If there are no pending interrupts, stop.  There's nothing
+//	more for us to do.
+//----------------------------------------------------------------------
+void Interrupt::Idle() {
+    DEBUG(dbgInt, "Machine idling; checking for interrupts.");
+    status = IdleMode;
+    if (CheckIfDue(TRUE)) {  // check for any pending interrupts
+        status = SystemMode;
+        return;  // return in case there's now
+                 // a runnable thread
+    }
+
+    // if there are no pending interrupts, and nothing is on the ready
+    // queue, it is time to stop.   If the console or the network is
+    // operating, there are *always* pending interrupts, so this code
+    // is not reached.  Instead, the halt must be invoked by the user program.
+
+    DEBUG(dbgInt, "Machine idle.  No interrupts to do.");
+    cout << "No threads ready or runnable, and no pending interrupts.\n";
+    cout << "Assuming the program completed.\n";
+    Halt();
+}
+
+//----------------------------------------------------------------------
+// Interrupt::Halt
+// 	Shut down Nachos cleanly, printing out performance statistics.
+//----------------------------------------------------------------------
+void Interrupt::Halt() {
+    cout << "Machine halting!\n\n";
+    kernel->stats->Print();
+    delete kernel;  // Never returns.
+}
+
+//----------------------------------------------------------------------
+// Interrupt::Schedule
+// 	Arrange for the CPU to be interrupted when simulated time
+//	reaches "now + when".
+//
+//	Implementation: just put it on a sorted list.
+//
+//	NOTE: the Nachos kernel should not call this routine directly.
+//	Instead, it is only called by the hardware device simulators.
+//
+//	"toCall" is the object to call when the interrupt occurs
+//	"fromNow" is how far in the future (in simulated time) the
+//		 interrupt is to occur
+//	"type" is the hardware device that generated the interrupt
+//----------------------------------------------------------------------
+void Interrupt::Schedule(CallBackObj *toCall, int fromNow, IntType type) {
+    int when = kernel->stats->totalTicks + fromNow;
+    PendingInterrupt *toOccur = new PendingInterrupt(toCall, when, type);
+
+    DEBUG(dbgInt, "Scheduling interrupt handler the " << intTypeNames[type]
+                                                      << " at time = " << when);
+    ASSERT(fromNow > 0);
+
+    pending->Insert(toOccur);
+}
+
+//----------------------------------------------------------------------
+// Interrupt::CheckIfDue
+// 	Check if any interrupts are scheduled to occur, and if so,
+//	fire them off.
+//
+// Returns:
+//	TRUE, if we fired off any interrupt handlers
+// Params:
+//	"advanceClock" -- if TRUE, there is nothing in the ready queue,
+//		so we should simply advance the clock to when the next
+//		pending interrupt would occur (if any).
+//----------------------------------------------------------------------
+bool Interrupt::CheckIfDue(bool advanceClock) {
+    PendingInterrupt *next;
+    Statistics *stats = kernel->stats;
+
+    ASSERT(level == IntOff);  // interrupts need to be disabled,
+                              // to invoke an interrupt handler
+    if (debug->IsEnabled(dbgInt)) {
+        DumpState();
+    }
+    if (pending->IsEmpty()) {  // no pending interrupts
+        return FALSE;
+    }
+    next = pending->Front();
+    if (next->when > stats->totalTicks) {
+        if (!advanceClock) {  // not time yet
+            return FALSE;
+        } else {  // advance the clock to next interrupt
+            stats->idleTicks += (next->when - stats->totalTicks);
+            stats->totalTicks = next->when;
+            // UDelay(1000L); // rcgood - to stop nachos from spinning.
+        }
+    }
+
+    DEBUG(dbgInt, "Invoking interrupt handler for the ");
+    DEBUG(dbgInt, intTypeNames[next->type] << " at time " << next->when);
+
+    if (kernel->machine != NULL) {
+        kernel->machine->DelayedLoad(0, 0);
+    }
+
+    inHandler = TRUE;
+    do {
+        next = pending->RemoveFront();      // pull interrupt off list
+        next->callOnInterrupt->CallBack();  // call the interrupt handler
+        delete next;
+    } while (!pending->IsEmpty() &&
+             (pending->Front()->when <= stats->totalTicks));
+    inHandler = FALSE;
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// PrintPending
+// 	Print information about an interrupt that is scheduled to occur.
+//	When, where, why, etc.
+//----------------------------------------------------------------------
+
+static void PrintPending(PendingInterrupt *pending) {
+    cout << "Interrupt handler " << intTypeNames[pending->type];
+    cout << ", scheduled at " << pending->when;
+}
+
+//----------------------------------------------------------------------
+// DumpState
+// 	Print the complete interrupt state - the status, and all interrupts
+//	that are scheduled to occur in the future.
+//----------------------------------------------------------------------
+
+void Interrupt::DumpState() {
+    cout << "Time: " << kernel->stats->totalTicks;
+    cout << ", interrupts " << intLevelNames[level] << "\n";
+    cout << "Pending interrupts:\n";
+    pending->Apply(PrintPending);
+    cout << "\nEnd of pending interrupts\n";
+}
diff --git a/code/machine/interrupt.h b/code/machine/interrupt.h
new file mode 100644
index 0000000..315e1a6
--- /dev/null
+++ b/code/machine/interrupt.h
@@ -0,0 +1,145 @@
+// interrupt.h
+//	Data structures to emulate low-level interrupt hardware.
+//
+//	The hardware provides a routine (SetLevel) to enable or disable
+//	interrupts.
+//
+//	In order to emulate the hardware, we need to keep track of all
+//	interrupts the hardware devices would cause, and when they
+//	are supposed to occur.
+//
+//	This module also keeps track of simulated time.  Time advances
+//	only when the following occur:
+//		interrupts are re-enabled
+//		a user instruction is executed
+//		there is nothing in the ready queue
+//
+//	As a result, unlike real hardware, interrupts (and thus time-slice
+//	context switches) cannot occur anywhere in the code where interrupts
+//	are enabled, but rather only at those places in the code where
+//	simulated time advances (so that it becomes time to invoke an
+//	interrupt in the hardware simulation).
+//
+//	NOTE: this means that incorrectly synchronized code may work
+//	fine on this hardware simulation (even with randomized time slices),
+//	but it wouldn't work on real hardware.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef INTERRUPT_H
+#define INTERRUPT_H
+
+#include "copyright.h"
+#include "list.h"
+#include "callback.h"
+
+// Interrupts can be disabled (IntOff) or enabled (IntOn)
+enum IntStatus { IntOff, IntOn };
+
+// Nachos can be running kernel code (SystemMode), user code (UserMode),
+// or there can be no runnable thread, because the ready list
+// is empty (IdleMode).
+enum MachineStatus { IdleMode, SystemMode, UserMode };
+
+// IntType records which hardware device generated an interrupt.
+// In Nachos, we support a hardware timer device, a disk, a console
+// display and keyboard, and a network.
+enum IntType {
+    TimerInt,
+    DiskInt,
+    ConsoleWriteInt,
+    ConsoleReadInt,
+    NetworkSendInt,
+    NetworkRecvInt
+};
+
+// The following class defines an interrupt that is scheduled
+// to occur in the future.  The internal data structures are
+// left public to make it simpler to manipulate.
+
+class PendingInterrupt {
+   public:
+    PendingInterrupt(CallBackObj *callOnInt, int time, IntType kind);
+    // initialize an interrupt that will
+    // occur in the future
+
+    CallBackObj
+        *callOnInterrupt;  // The object (in the hardware device
+                           // emulator) to call when the interrupt occurs
+
+    int when;      // When the interrupt is supposed to fire
+    IntType type;  // for debugging
+};
+
+// The following class defines the data structures for the simulation
+// of hardware interrupts.  We record whether interrupts are enabled
+// or disabled, and any hardware interrupts that are scheduled to occur
+// in the future.
+
+class Interrupt {
+   public:
+    Interrupt();   // initialize the interrupt simulation
+    ~Interrupt();  // de-allocate data structures
+
+    IntStatus SetLevel(IntStatus level);
+    // Disable or enable interrupts
+    // and return previous setting.
+
+    void Enable() { (void)SetLevel(IntOn); }
+    // Enable interrupts.
+    IntStatus getLevel() { return level; }
+    // Return whether interrupts
+    // are enabled or disabled
+
+    void Idle();  // The ready queue is empty, roll
+                  // simulated time forward until the
+                  // next interrupt
+
+    void Halt();  // quit and print out stats
+
+    void YieldOnReturn();  // cause a context switch on return
+                           // from an interrupt handler
+
+    MachineStatus getStatus() { return status; }
+    void setStatus(MachineStatus st) { status = st; }
+    // idle, kernel, user
+
+    void DumpState();  // Print interrupt state
+
+    // NOTE: the following are internal to the hardware simulation code.
+    // DO NOT call these directly.  I should make them "private",
+    // but they need to be public since they are called by the
+    // hardware device simulators.
+
+    void Schedule(CallBackObj *callTo, int when, IntType type);
+    // Schedule an interrupt to occur
+    // at time "when".  This is called
+    // by the hardware device simulators.
+
+    void OneTick();  // Advance simulated time
+
+   private:
+    IntStatus level;  // are interrupts enabled or disabled?
+    SortedList<PendingInterrupt *> *pending;
+    // the list of interrupts scheduled
+    // to occur in the future
+    bool inHandler;        // TRUE if we are running an interrupt handler
+    bool yieldOnReturn;    // TRUE if we are to context switch
+                           // on return from the interrupt handler
+    MachineStatus status;  // idle, kernel mode, user mode
+
+    // these functions are internal to the interrupt simulation code
+
+    bool CheckIfDue(bool advanceClock);
+    // Check if any interrupts are supposed
+    // to occur now, and if so, do them
+
+    void ChangeLevel(IntStatus old,   // SetLevel, without advancing the
+                     IntStatus now);  // simulated time
+};
+
+#endif  // INTERRRUPT_H
diff --git a/code/machine/machine.cc b/code/machine/machine.cc
new file mode 100644
index 0000000..5d22764
--- /dev/null
+++ b/code/machine/machine.cc
@@ -0,0 +1,212 @@
+// machine.cc
+//	Routines for simulating the execution of user programs.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "machine.h"
+#include "main.h"
+
+// Textual names of the exceptions that can be generated by user program
+// execution, for debugging.
+static char* exceptionNames[] = {"no exception",
+                                 "syscall",
+                                 "page fault/no TLB entry",
+                                 "page read only",
+                                 "bus error",
+                                 "address error",
+                                 "overflow",
+                                 "illegal instruction"};
+
+//----------------------------------------------------------------------
+// CheckEndian
+// 	Check to be sure that the host really uses the format it says it
+//	does, for storing the bytes of an integer.  Stop on error.
+//----------------------------------------------------------------------
+
+static void CheckEndian() {
+    union checkit {
+        char charword[4];
+        unsigned int intword;
+    } check;
+
+    check.charword[0] = 1;
+    check.charword[1] = 2;
+    check.charword[2] = 3;
+    check.charword[3] = 4;
+
+#ifdef HOST_IS_BIG_ENDIAN
+    ASSERT(check.intword == 0x01020304);
+#else
+    ASSERT(check.intword == 0x04030201);
+#endif
+}
+
+//----------------------------------------------------------------------
+// Machine::Machine
+// 	Initialize the simulation of user program execution.
+//
+//	"debug" -- if TRUE, drop into the debugger after each user instruction
+//		is executed.
+//----------------------------------------------------------------------
+
+Machine::Machine(bool debug) {
+    int i;
+
+    for (i = 0; i < NumTotalRegs; i++) registers[i] = 0;
+    mainMemory = new char[MemorySize];
+    for (i = 0; i < MemorySize; i++) mainMemory[i] = 0;
+#ifdef USE_TLB
+    tlb = new TranslationEntry[TLBSize];
+    for (i = 0; i < TLBSize; i++) tlb[i].valid = FALSE;
+    pageTable = NULL;
+#else  // use linear page table
+    tlb = NULL;
+    pageTable = NULL;
+#endif
+
+    singleStep = debug;
+    CheckEndian();
+}
+
+//----------------------------------------------------------------------
+// Machine::~Machine
+// 	De-allocate the data structures used to simulate user program execution.
+//----------------------------------------------------------------------
+
+Machine::~Machine() {
+    delete[] mainMemory;
+    if (tlb != NULL) delete[] tlb;
+}
+
+//----------------------------------------------------------------------
+// Machine::RaiseException
+// 	Transfer control to the Nachos kernel from user mode, because
+//	the user program either invoked a system call, or some exception
+//	occured (such as the address translation failed).
+//
+//	"which" -- the cause of the kernel trap
+//	"badVaddr" -- the virtual address causing the trap, if appropriate
+//----------------------------------------------------------------------
+
+void Machine::RaiseException(ExceptionType which, int badVAddr) {
+    DEBUG(dbgMach, "Exception: " << exceptionNames[which]);
+
+    registers[BadVAddrReg] = badVAddr;
+    DelayedLoad(0, 0);  // finish anything in progress
+    kernel->interrupt->setStatus(SystemMode);
+    ExceptionHandler(which);  // interrupts are enabled at this point
+    kernel->interrupt->setStatus(UserMode);
+}
+
+//----------------------------------------------------------------------
+// Machine::Debugger
+// 	Primitive debugger for user programs.  Note that we can't use
+//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
+//	It could, but you'd have to implement *a lot* more system calls
+//	to get it to work!
+//
+//	So just allow single-stepping, and printing the contents of memory.
+//----------------------------------------------------------------------
+
+void Machine::Debugger() {
+    char* buf = new char[80];
+    int num;
+    bool done = FALSE;
+
+    kernel->interrupt->DumpState();
+    DumpState();
+    while (!done) {
+        // read commands until we should proceed with more execution
+        // prompt for input, giving current simulation time in the prompt
+        cout << kernel->stats->totalTicks << ">";
+        // read one line of input (80 chars max)
+        cin.get(buf, 80);
+        if (sscanf(buf, "%d", &num) == 1) {
+            runUntilTime = num;
+            done = TRUE;
+        } else {
+            runUntilTime = 0;
+            switch (*buf) {
+                case '\0':
+                    done = TRUE;
+                    break;
+                case 'c':
+                    singleStep = FALSE;
+                    done = TRUE;
+                    break;
+                case '?':
+                    cout << "Machine commands:\n";
+                    cout << "    <return>  execute one instruction\n";
+                    cout << "    <number>  run until the given timer tick\n";
+                    cout << "    c         run until completion\n";
+                    cout << "    ?         print help message\n";
+                    break;
+                default:
+                    cout << "Unknown command: " << buf << "\n";
+                    cout << "Type ? for help.\n";
+            }
+        }
+        // consume the newline delimiter, which does not get
+        // eaten by cin.get(buf,80) above.
+        buf[0] = cin.get();
+    }
+    delete[] buf;
+}
+
+//----------------------------------------------------------------------
+// Machine::DumpState
+// 	Print the user program's CPU state.  We might print the contents
+//	of memory, but that seemed like overkill.
+//----------------------------------------------------------------------
+
+void Machine::DumpState() {
+    int i;
+
+    cout << "Machine registers:\n";
+    for (i = 0; i < NumGPRegs; i++) {
+        switch (i) {
+            case StackReg:
+                cout << "\tSP(" << i << "):\t" << registers[i];
+                break;
+
+            case RetAddrReg:
+                cout << "\tRA(" << i << "):\t" << registers[i];
+                break;
+
+            default:
+                cout << "\t" << i << ":\t" << registers[i];
+                break;
+        }
+        if ((i % 4) == 3) {
+            cout << "\n";
+        }
+    }
+
+    cout << "\tHi:\t" << registers[HiReg];
+    cout << "\tLo:\t" << registers[LoReg];
+    cout << "\tPC:\t" << registers[PCReg];
+    cout << "\tNextPC:\t" << registers[NextPCReg];
+    cout << "\tPrevPC:\t" << registers[PrevPCReg];
+    cout << "\tLoad:\t" << registers[LoadReg];
+    cout << "\tLoadV:\t" << registers[LoadValueReg] << "\n";
+}
+
+//----------------------------------------------------------------------
+// Machine::ReadRegister/WriteRegister
+//   	Fetch or write the contents of a user program register.
+//----------------------------------------------------------------------
+
+int Machine::ReadRegister(int num) {
+    ASSERT((num >= 0) && (num < NumTotalRegs));
+    return registers[num];
+}
+
+void Machine::WriteRegister(int num, int value) {
+    ASSERT((num >= 0) && (num < NumTotalRegs));
+    registers[num] = value;
+}
diff --git a/code/machine/machine.h b/code/machine/machine.h
new file mode 100644
index 0000000..55fe1b5
--- /dev/null
+++ b/code/machine/machine.h
@@ -0,0 +1,204 @@
+// machine.h
+//	Data structures for simulating the execution of user programs
+//	running on top of Nachos.
+//
+//	User programs are loaded into "mainMemory"; to Nachos,
+//	this looks just like an array of bytes.  Of course, the Nachos
+//	kernel is in memory too -- but as in most machines these days,
+//	the kernel is loaded into a separate memory region from user
+//	programs, and accesses to kernel memory are not translated or paged.
+//
+//	In Nachos, user programs are executed one instruction at a time,
+//	by the simulator.  Each memory reference is translated, checked
+//	for errors, etc.
+//
+//  DO NOT CHANGE EXCEPT AS NOTED BELOW -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef MACHINE_H
+#define MACHINE_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "translate.h"
+
+// Definitions related to the size, and format of user memory
+
+const int PageSize = 128;  // set the page size equal to
+                           // the disk sector size, for simplicity
+
+//
+// You are allowed to change this value.
+// Doing so will change the number of pages of physical memory
+// available on the simulated machine.
+//
+const int NumPhysPages = 128;
+
+const int MemorySize = (NumPhysPages * PageSize);
+const int TLBSize = 4;  // if there is a TLB, make it small
+
+enum ExceptionType {
+    NoException,            // Everything ok!
+    SyscallException,       // A program executed a system call.
+    PageFaultException,     // No valid translation found
+    ReadOnlyException,      // Write attempted to page marked
+                            // "read-only"
+    BusErrorException,      // Translation resulted in an
+                            // invalid physical address
+    AddressErrorException,  // Unaligned reference or one that
+                            // was beyond the end of the
+                            // address space
+    OverflowException,      // Integer overflow in add or sub.
+    IllegalInstrException,  // Unimplemented or reserved instr.
+
+    NumExceptionTypes
+};
+
+// User program CPU state.  The full set of MIPS registers, plus a few
+// more because we need to be able to start/stop a user program between
+// any two instructions (thus we need to keep track of things like load
+// delay slots, etc.)
+
+#define StackReg 29    // User's stack pointer
+#define RetAddrReg 31  // Holds return address for procedure calls
+#define NumGPRegs 32   // 32 general purpose registers on MIPS
+#define HiReg 32       // Double register to hold multiply result
+#define LoReg 33
+#define PCReg 34         // Current program counter
+#define NextPCReg 35     // Next program counter (for branch delay)
+#define PrevPCReg 36     // Previous program counter (for debugging)
+#define LoadReg 37       // The register target of a delayed load.
+#define LoadValueReg 38  // The value to be loaded by a delayed load.
+#define BadVAddrReg 39   // The failing virtual address on an exception
+
+#define NumTotalRegs 40
+
+// The following class defines the simulated host workstation hardware, as
+// seen by user programs -- the CPU registers, main memory, etc.
+// User programs shouldn't be able to tell that they are running on our
+// simulator or on the real hardware, except
+//	we don't support floating point instructions
+//	the system call interface to Nachos is not the same as UNIX
+//	  (10 system calls in Nachos vs. 200 in UNIX!)
+// If we were to implement more of the UNIX system calls, we ought to be
+// able to run Nachos on top of Nachos!
+//
+// The procedures in this class are defined in machine.cc, mipssim.cc, and
+// translate.cc.
+
+class Instruction;
+class Interrupt;
+
+class Machine {
+   public:
+    Machine(bool debug);  // Initialize the simulation of the hardware
+                          // for running user programs
+    ~Machine();           // De-allocate the data structures
+
+    // Routines callable by the Nachos kernel
+    void Run();  // Run a user program
+
+    int ReadRegister(int num);  // read the contents of a CPU register
+
+    void WriteRegister(int num, int value);
+    // store a value into a CPU register
+
+    // Data structures accessible to the Nachos kernel -- main memory and the
+    // page table/TLB.
+    //
+    // Note that *all* communication between the user program and the kernel
+    // are in terms of these data structures (plus the CPU registers).
+
+    char *mainMemory;  // physical memory to store user program,
+                       // code and data, while executing
+
+    // NOTE: the hardware translation of virtual addresses in the user program
+    // to physical addresses (relative to the beginning of "mainMemory")
+    // can be controlled by one of:
+    //	a traditional linear page table
+    //  	a software-loaded translation lookaside buffer (tlb) -- a cache of
+    //	  mappings of virtual page #'s to physical page #'s
+    //
+    // If "tlb" is NULL, the linear page table is used
+    // If "tlb" is non-NULL, the Nachos kernel is responsible for managing
+    //	the contents of the TLB.  But the kernel can use any data structure
+    //	it wants (eg, segmented paging) for handling TLB cache misses.
+    //
+    // For simplicity, both the page table pointer and the TLB pointer are
+    // public.  However, while there can be multiple page tables (one per
+    // address space, stored in memory), there is only one TLB (implemented in
+    // hardware). Thus the TLB pointer should be considered as *read-only*,
+    // although the contents of the TLB are free to be modified by the kernel
+    // software.
+
+    TranslationEntry *tlb;  // this pointer should be considered
+                            // "read-only" to Nachos kernel code
+
+    TranslationEntry *pageTable;
+    unsigned int pageTableSize;
+
+    bool ReadMem(int addr, int size, int *value);
+    bool WriteMem(int addr, int size, int value);
+    // Read or write 1, 2, or 4 bytes of virtual
+    // memory (at addr).  Return FALSE if a
+    // correct translation couldn't be found.
+   private:
+    // Routines internal to the machine simulation -- DO NOT call these directly
+    void DelayedLoad(int nextReg, int nextVal);
+    // Do a pending delayed load (modifying a reg)
+
+    void OneInstruction(Instruction *instr);
+    // Run one instruction of a user program.
+
+    ExceptionType Translate(int virtAddr, int *physAddr, int size,
+                            bool writing);
+    // Translate an address, and check for
+    // alignment.  Set the use and dirty bits in
+    // the translation entry appropriately,
+    // and return an exception code if the
+    // translation couldn't be completed.
+
+    void RaiseException(ExceptionType which, int badVAddr);
+    // Trap to the Nachos kernel, because of a
+    // system call or other exception.
+
+    void Debugger();   // invoke the user program debugger
+    void DumpState();  // print the user CPU and memory state
+
+    // Internal data structures
+
+    int registers[NumTotalRegs];  // CPU registers, for executing user programs
+
+    bool singleStep;   // drop back into the debugger after each
+                       // simulated instruction
+    int runUntilTime;  // drop back into the debugger when simulated
+                       // time reaches this value
+
+    friend class Interrupt;  // calls DelayedLoad()
+};
+
+extern void ExceptionHandler(ExceptionType which);
+// Entry point into Nachos for handling
+// user system calls and exceptions
+// Defined in exception.cc
+
+// Routines for converting Words and Short Words to and from the
+// simulated machine's format of little endian.  If the host machine
+// is little endian (DEC and Intel), these end up being NOPs.
+//
+// What is stored in each format:
+//	host byte ordering:
+//	   kernel data structures
+//	   user registers
+//	simulated machine byte ordering:
+//	   contents of main memory
+
+unsigned int WordToHost(unsigned int word);
+unsigned short ShortToHost(unsigned short shortword);
+unsigned int WordToMachine(unsigned int word);
+unsigned short ShortToMachine(unsigned short shortword);
+
+#endif  // MACHINE_H
diff --git a/code/machine/mipssim.cc b/code/machine/mipssim.cc
new file mode 100644
index 0000000..20edd33
--- /dev/null
+++ b/code/machine/mipssim.cc
@@ -0,0 +1,799 @@
+// mipssim.cc -- simulate a MIPS R2/3000 processor
+//
+//   This code has been adapted from Ousterhout's MIPSSIM package.
+//   Byte ordering is little-endian, so we can be compatible with
+//   DEC RISC systems.
+//
+//   DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+// Simulation fixes done by Peter E Reissner, class of Winter 1994/95 (York)
+// I've not been able to test this extensively.
+// Ported to newer version of Nachos at Waterloo by Scott Graham (Mar 99).
+
+#include "copyright.h"
+
+#include "debug.h"
+#include "machine.h"
+#include "mipssim.h"
+#include "main.h"
+
+static void Mult(int a, int b, bool signedArith, int *hiPtr, int *loPtr);
+
+// The following class defines an instruction, represented in both
+// 	undecoded binary form
+//      decoded to identify
+//	    operation to do
+//	    registers to act on
+//	    any immediate operand value
+
+class Instruction {
+   public:
+    void Decode();  // decode the binary representation of the instruction
+
+    unsigned int value;  // binary representation of the instruction
+
+    char opCode;      // Type of instruction.  This is NOT the same as the
+                      // opcode field from the instruction: see defs in mips.h
+    char rs, rt, rd;  // Three registers from instruction.
+    int extra;        // Immediate or target or shamt field or offset.
+                      // Immediates are sign-extended.
+};
+
+//----------------------------------------------------------------------
+// Machine::Run
+// 	Simulate the execution of a user-level program on Nachos.
+//	Called by the kernel when the program starts up; never returns.
+//
+//	This routine is re-entrant, in that it can be called multiple
+//	times concurrently -- one for each thread executing user code.
+//----------------------------------------------------------------------
+
+void Machine::Run() {
+    Instruction *instr = new Instruction;  // storage for decoded instruction
+
+    if (debug->IsEnabled('m')) {
+        cout << "Starting program in thread: "
+             << kernel->currentThread->getName();
+        cout << ", at time: " << kernel->stats->totalTicks << "\n";
+    }
+    kernel->interrupt->setStatus(UserMode);
+    for (;;) {
+        OneInstruction(instr);
+        kernel->interrupt->OneTick();
+        if (singleStep && (runUntilTime <= kernel->stats->totalTicks))
+            Debugger();
+    }
+}
+
+//----------------------------------------------------------------------
+// TypeToReg
+// 	Retrieve the register # referred to in an instruction.
+//----------------------------------------------------------------------
+
+static int TypeToReg(RegType reg, Instruction *instr) {
+    switch (reg) {
+        case RS:
+            return instr->rs;
+        case RT:
+            return instr->rt;
+        case RD:
+            return instr->rd;
+        case EXTRA:
+            return instr->extra;
+        default:
+            return -1;
+    }
+}
+
+//----------------------------------------------------------------------
+// Machine::OneInstruction
+// 	Execute one instruction from a user-level program
+//
+// 	If there is any kind of exception or interrupt, we invoke the
+//	exception handler, and when it returns, we return to Run(), which
+//	will re-invoke us in a loop.  This allows us to
+//	re-start the instruction execution from the beginning, in
+//	case any of our state has changed.  On a syscall,
+// 	the OS software must increment the PC so execution begins
+// 	at the instruction immediately after the syscall.
+//
+//	This routine is re-entrant, in that it can be called multiple
+//	times concurrently -- one for each thread executing user code.
+//	We get re-entrancy by never caching any data -- we always re-start the
+//	simulation from scratch each time we are called (or after trapping
+//	back to the Nachos kernel on an exception or interrupt), and we always
+//	store all data back to the machine registers and memory before
+//	leaving.  This allows the Nachos kernel to control our behavior
+//	by controlling the contents of memory, the translation table,
+//	and the register set.
+//----------------------------------------------------------------------
+
+void Machine::OneInstruction(Instruction *instr) {
+#ifdef SIM_FIX
+    int byte;  // described in Kane for LWL,LWR,...
+#endif
+
+    int raw;
+    int nextLoadReg = 0;
+    int nextLoadValue = 0;  // record delayed load operation, to apply
+                            // in the future
+
+    // Fetch instruction
+    if (!ReadMem(registers[PCReg], 4, &raw)) return;  // exception occurred
+    instr->value = raw;
+    instr->Decode();
+
+    if (debug->IsEnabled('m')) {
+        struct OpString *str = &opStrings[instr->opCode];
+        char buf[80];
+
+        ASSERT(instr->opCode <= MaxOpcode);
+        cout << "At PC = " << registers[PCReg];
+        sprintf(buf, str->format, TypeToReg(str->args[0], instr),
+                TypeToReg(str->args[1], instr), TypeToReg(str->args[2], instr));
+        cout << "\t" << buf << "\n";
+    }
+
+    // Compute next pc, but don't install in case there's an error or branch.
+    int pcAfter = registers[NextPCReg] + 4;
+    int sum, diff, tmp, value;
+    unsigned int rs, rt, imm;
+
+    // Execute the instruction (cf. Kane's book)
+    switch (instr->opCode) {
+        case OP_ADD:
+            sum = registers[instr->rs] + registers[instr->rt];
+            if (!((registers[instr->rs] ^ registers[instr->rt]) & SIGN_BIT) &&
+                ((registers[instr->rs] ^ sum) & SIGN_BIT)) {
+                RaiseException(OverflowException, 0);
+                return;
+            }
+            registers[instr->rd] = sum;
+            break;
+
+        case OP_ADDI:
+            sum = registers[instr->rs] + instr->extra;
+            if (!((registers[instr->rs] ^ instr->extra) & SIGN_BIT) &&
+                ((instr->extra ^ sum) & SIGN_BIT)) {
+                RaiseException(OverflowException, 0);
+                return;
+            }
+            registers[instr->rt] = sum;
+            break;
+
+        case OP_ADDIU:
+            registers[instr->rt] = registers[instr->rs] + instr->extra;
+            break;
+
+        case OP_ADDU:
+            registers[instr->rd] = registers[instr->rs] + registers[instr->rt];
+            break;
+
+        case OP_AND:
+            registers[instr->rd] = registers[instr->rs] & registers[instr->rt];
+            break;
+
+        case OP_ANDI:
+            registers[instr->rt] =
+                registers[instr->rs] & (instr->extra & 0xffff);
+            break;
+
+        case OP_BEQ:
+            if (registers[instr->rs] == registers[instr->rt])
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_BGEZAL:
+            registers[R31] = registers[NextPCReg] + 4;
+        case OP_BGEZ:
+            if (!(registers[instr->rs] & SIGN_BIT))
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_BGTZ:
+            if (registers[instr->rs] > 0)
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_BLEZ:
+            if (registers[instr->rs] <= 0)
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_BLTZAL:
+            registers[R31] = registers[NextPCReg] + 4;
+        case OP_BLTZ:
+            if (registers[instr->rs] & SIGN_BIT)
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_BNE:
+            if (registers[instr->rs] != registers[instr->rt])
+                pcAfter = registers[NextPCReg] + IndexToAddr(instr->extra);
+            break;
+
+        case OP_DIV:
+            if (registers[instr->rt] == 0) {
+                registers[LoReg] = 0;
+                registers[HiReg] = 0;
+            } else {
+                registers[LoReg] = registers[instr->rs] / registers[instr->rt];
+                registers[HiReg] = registers[instr->rs] % registers[instr->rt];
+            }
+            break;
+
+        case OP_DIVU:
+            rs = (unsigned int)registers[instr->rs];
+            rt = (unsigned int)registers[instr->rt];
+            if (rt == 0) {
+                registers[LoReg] = 0;
+                registers[HiReg] = 0;
+            } else {
+                tmp = rs / rt;
+                registers[LoReg] = (int)tmp;
+                tmp = rs % rt;
+                registers[HiReg] = (int)tmp;
+            }
+            break;
+
+        case OP_JAL:
+            registers[R31] = registers[NextPCReg] + 4;
+        case OP_J:
+            pcAfter = (pcAfter & 0xf0000000) | IndexToAddr(instr->extra);
+            break;
+
+        case OP_JALR:
+            registers[instr->rd] = registers[NextPCReg] + 4;
+        case OP_JR:
+            pcAfter = registers[instr->rs];
+            break;
+
+        case OP_LB:
+        case OP_LBU:
+            tmp = registers[instr->rs] + instr->extra;
+            if (!ReadMem(tmp, 1, &value)) return;
+
+            if ((value & 0x80) && (instr->opCode == OP_LB))
+                value |= 0xffffff00;
+            else
+                value &= 0xff;
+            nextLoadReg = instr->rt;
+            nextLoadValue = value;
+            break;
+
+        case OP_LH:
+        case OP_LHU:
+            tmp = registers[instr->rs] + instr->extra;
+            if (tmp & 0x1) {
+                RaiseException(AddressErrorException, tmp);
+                return;
+            }
+            if (!ReadMem(tmp, 2, &value)) return;
+
+            if ((value & 0x8000) && (instr->opCode == OP_LH))
+                value |= 0xffff0000;
+            else
+                value &= 0xffff;
+            nextLoadReg = instr->rt;
+            nextLoadValue = value;
+            break;
+
+        case OP_LUI:
+            DEBUG(dbgMach,
+                  "Executing: LUI r" << instr->rt << ", " << instr->extra);
+            registers[instr->rt] = instr->extra << 16;
+            break;
+
+        case OP_LW:
+            tmp = registers[instr->rs] + instr->extra;
+            if (tmp & 0x3) {
+                RaiseException(AddressErrorException, tmp);
+                return;
+            }
+            if (!ReadMem(tmp, 4, &value)) return;
+            nextLoadReg = instr->rt;
+            nextLoadValue = value;
+            break;
+
+        case OP_LWL:
+            tmp = registers[instr->rs] + instr->extra;
+
+#ifdef SIM_FIX
+            // The only difference between this code and the BIG ENDIAN code
+            // is that the ReadMem call is guaranteed an aligned access as it
+            // should be (Kane's book hides the fact that all memory access
+            // are done using aligned loads - what the instruction asks for
+            // is a arbitrary) This is the whole purpose of LWL and LWR etc.
+            // Then the switch uses  3 - (tmp & 0x3)  instead of (tmp & 0x3)
+
+            byte = tmp & 0x3;
+            // DEBUG('P', "Addr 0x%X\n",tmp-byte);
+
+            if (!ReadMem(tmp - byte, 4, &value)) return;
+#else
+            // ReadMem assumes all 4 byte requests are aligned on an even
+            // word boundary.  Also, the little endian/big endian swap code
+            // would fail (I think) if the other cases are ever exercised.
+            ASSERT((tmp & 0x3) == 0);
+
+            if (!ReadMem(tmp, 4, &value)) return;
+#endif
+
+            if (registers[LoadReg] == instr->rt)
+                nextLoadValue = registers[LoadValueReg];
+            else
+                nextLoadValue = registers[instr->rt];
+#ifdef SIM_FIX
+            switch (3 - byte)
+#else
+            switch (tmp & 0x3)
+#endif
+            {
+                case 0:
+                    nextLoadValue = value;
+                    break;
+                case 1:
+                    nextLoadValue = (nextLoadValue & 0xff) | (value << 8);
+                    break;
+                case 2:
+                    nextLoadValue = (nextLoadValue & 0xffff) | (value << 16);
+                    break;
+                case 3:
+                    nextLoadValue = (nextLoadValue & 0xffffff) | (value << 24);
+                    break;
+            }
+            nextLoadReg = instr->rt;
+            break;
+
+        case OP_LWR:
+            tmp = registers[instr->rs] + instr->extra;
+
+#ifdef SIM_FIX
+            // The only difference between this code and the BIG ENDIAN code
+            // is that the ReadMem call is guaranteed an aligned access as it
+            // should be (Kane's book hides the fact that all memory access
+            // are done using aligned loads - what the instruction asks
+            // for is a arbitrary) This is the whole purpose of LWL and LWR etc.
+            // Then the switch uses  3 - (tmp & 0x3)  instead of (tmp & 0x3)
+
+            byte = tmp & 0x3;
+            // DEBUG('P', "Addr 0x%X\n",tmp-byte);
+
+            if (!ReadMem(tmp - byte, 4, &value)) return;
+#else
+            // ReadMem assumes all 4 byte requests are aligned on an even
+            // word boundary.  Also, the little endian/big endian swap code
+            // would fail (I think) if the other cases are ever exercised.
+            ASSERT((tmp & 0x3) == 0);
+
+            if (!ReadMem(tmp, 4, &value)) return;
+#endif
+
+            if (registers[LoadReg] == instr->rt)
+                nextLoadValue = registers[LoadValueReg];
+            else
+                nextLoadValue = registers[instr->rt];
+
+#ifdef SIM_FIX
+            switch (3 - byte)
+#else
+            switch (tmp & 0x3)
+#endif
+            {
+                case 0:
+                    nextLoadValue =
+                        (nextLoadValue & 0xffffff00) | ((value >> 24) & 0xff);
+                    break;
+                case 1:
+                    nextLoadValue =
+                        (nextLoadValue & 0xffff0000) | ((value >> 16) & 0xffff);
+                    break;
+                case 2:
+                    nextLoadValue = (nextLoadValue & 0xff000000) |
+                                    ((value >> 8) & 0xffffff);
+                    break;
+                case 3:
+                    nextLoadValue = value;
+                    break;
+            }
+            nextLoadReg = instr->rt;
+            break;
+
+        case OP_MFHI:
+            registers[instr->rd] = registers[HiReg];
+            break;
+
+        case OP_MFLO:
+            registers[instr->rd] = registers[LoReg];
+            break;
+
+        case OP_MTHI:
+            registers[HiReg] = registers[instr->rs];
+            break;
+
+        case OP_MTLO:
+            registers[LoReg] = registers[instr->rs];
+            break;
+
+        case OP_MULT:
+            Mult(registers[instr->rs], registers[instr->rt], TRUE,
+                 &registers[HiReg], &registers[LoReg]);
+            break;
+
+        case OP_MULTU:
+            Mult(registers[instr->rs], registers[instr->rt], FALSE,
+                 &registers[HiReg], &registers[LoReg]);
+            break;
+
+        case OP_NOR:
+            registers[instr->rd] =
+                ~(registers[instr->rs] | registers[instr->rt]);
+            break;
+
+        case OP_OR:
+            registers[instr->rd] = registers[instr->rs] | registers[instr->rt];
+            break;
+
+        case OP_ORI:
+            registers[instr->rt] =
+                registers[instr->rs] | (instr->extra & 0xffff);
+            break;
+
+        case OP_SB:
+            if (!WriteMem((unsigned)(registers[instr->rs] + instr->extra), 1,
+                          registers[instr->rt]))
+                return;
+            break;
+
+        case OP_SH:
+            if (!WriteMem((unsigned)(registers[instr->rs] + instr->extra), 2,
+                          registers[instr->rt]))
+                return;
+            break;
+
+        case OP_SLL:
+            registers[instr->rd] = registers[instr->rt] << instr->extra;
+            break;
+
+        case OP_SLLV:
+            registers[instr->rd] = registers[instr->rt]
+                                   << (registers[instr->rs] & 0x1f);
+            break;
+
+        case OP_SLT:
+            if (registers[instr->rs] < registers[instr->rt])
+                registers[instr->rd] = 1;
+            else
+                registers[instr->rd] = 0;
+            break;
+
+        case OP_SLTI:
+            if (registers[instr->rs] < instr->extra)
+                registers[instr->rt] = 1;
+            else
+                registers[instr->rt] = 0;
+            break;
+
+        case OP_SLTIU:
+            rs = registers[instr->rs];
+            imm = instr->extra;
+            if (rs < imm)
+                registers[instr->rt] = 1;
+            else
+                registers[instr->rt] = 0;
+            break;
+
+        case OP_SLTU:
+            rs = registers[instr->rs];
+            rt = registers[instr->rt];
+            if (rs < rt)
+                registers[instr->rd] = 1;
+            else
+                registers[instr->rd] = 0;
+            break;
+
+        case OP_SRA:
+            registers[instr->rd] = registers[instr->rt] >> instr->extra;
+            break;
+
+        case OP_SRAV:
+            registers[instr->rd] =
+                registers[instr->rt] >> (registers[instr->rs] & 0x1f);
+            break;
+
+        case OP_SRL:
+            tmp = registers[instr->rt];
+            tmp >>= instr->extra;
+            registers[instr->rd] = tmp;
+            break;
+
+        case OP_SRLV:
+            tmp = registers[instr->rt];
+            tmp >>= (registers[instr->rs] & 0x1f);
+            registers[instr->rd] = tmp;
+            break;
+
+        case OP_SUB:
+            diff = registers[instr->rs] - registers[instr->rt];
+            if (((registers[instr->rs] ^ registers[instr->rt]) & SIGN_BIT) &&
+                ((registers[instr->rs] ^ diff) & SIGN_BIT)) {
+                RaiseException(OverflowException, 0);
+                return;
+            }
+            registers[instr->rd] = diff;
+            break;
+
+        case OP_SUBU:
+            registers[instr->rd] = registers[instr->rs] - registers[instr->rt];
+            break;
+
+        case OP_SW:
+            if (!WriteMem((unsigned)(registers[instr->rs] + instr->extra), 4,
+                          registers[instr->rt]))
+                return;
+            break;
+
+        case OP_SWL:
+            tmp = registers[instr->rs] + instr->extra;
+
+#ifdef SIM_FIX
+            // The only difference between this code and the BIG ENDIAN code
+            // is that the ReadMem call is guaranteed an aligned access as it
+            // should be (Kane's book hides the fact that all memory access
+            // are done using aligned loads - what the instruction asks for
+            // is a arbitrary) This is the whole purpose of LWL and LWR etc.
+
+            byte = tmp & 0x3;
+            // DEBUG('P', "Addr 0x%X\n",tmp-byte);
+            if (!ReadMem(tmp - byte, 4, &value)) return;
+
+                // DEBUG('P', "Value 0x%X\n",value);
+#else
+
+            // The little endian/big endian swap code would
+            // fail (I think) if the other cases are ever exercised.
+            ASSERT((tmp & 0x3) == 0);
+
+            if (!ReadMem((tmp & ~0x3), 4, &value)) return;
+#endif
+
+#ifdef SIM_FIX
+            switch (3 - byte)
+#else
+            switch (tmp & 0x3)
+#endif  // SIM_FIX
+            {
+                case 0:
+                    value = registers[instr->rt];
+                    break;
+                case 1:
+                    value = (value & 0xff000000) |
+                            ((registers[instr->rt] >> 8) & 0xffffff);
+                    break;
+                case 2:
+                    value = (value & 0xffff0000) |
+                            ((registers[instr->rt] >> 16) & 0xffff);
+                    break;
+                case 3:
+                    value = (value & 0xffffff00) |
+                            ((registers[instr->rt] >> 24) & 0xff);
+                    break;
+            }
+#ifndef SIM_FIX
+            if (!WriteMem((tmp & ~0x3), 4, value)) return;
+#else
+            // DEBUG('P', "Value 0x%X\n",value);
+
+            if (!WriteMem((tmp - byte), 4, value)) return;
+#endif  // SIM_FIX
+            break;
+
+        case OP_SWR:
+            tmp = registers[instr->rs] + instr->extra;
+
+#ifndef SIM_FIX
+            // The little endian/big endian swap code would
+            // fail (I think) if the other cases are ever exercised.
+            ASSERT((tmp & 0x3) == 0);
+
+            if (!ReadMem((tmp & ~0x3), 4, &value)) return;
+#else
+            // The only difference between this code and the BIG ENDIAN code
+            // is that the ReadMem call is guaranteed an aligned access as
+            // it should be (Kane's book hides the fact that all memory
+            // access are done using aligned loads - what the instruction
+            // asks for is a arbitrary) This is the whole purpose of LWL
+            // and LWR etc.
+
+            byte = tmp & 0x3;
+            // DEBUG('P', "Addr 0x%X\n",tmp-byte);
+
+            if (!ReadMem(tmp - byte, 4, &value)) return;
+                // DEBUG('P', "Value 0x%X\n",value);
+#endif  // SIM_FIX
+
+#ifndef SIM_FIX
+            switch (tmp & 0x3)
+#else
+            switch (3 - byte)
+#endif  // SIM_FIX
+            {
+                case 0:
+                    value = (value & 0xffffff) | (registers[instr->rt] << 24);
+                    break;
+                case 1:
+                    value = (value & 0xffff) | (registers[instr->rt] << 16);
+                    break;
+                case 2:
+                    value = (value & 0xff) | (registers[instr->rt] << 8);
+                    break;
+                case 3:
+                    value = registers[instr->rt];
+                    break;
+            }
+
+#ifndef SIM_FIX
+            if (!WriteMem((tmp & ~0x3), 4, value)) return;
+#else
+            // DEBUG('P', "Value 0x%X\n",value);
+
+            if (!WriteMem((tmp - byte), 4, value)) return;
+#endif  // SIM_FIX
+
+            break;
+
+        case OP_SYSCALL:
+            RaiseException(SyscallException, 0);
+            return;
+
+        case OP_XOR:
+            registers[instr->rd] = registers[instr->rs] ^ registers[instr->rt];
+            break;
+
+        case OP_XORI:
+            registers[instr->rt] =
+                registers[instr->rs] ^ (instr->extra & 0xffff);
+            break;
+
+        case OP_RES:
+        case OP_UNIMP:
+            RaiseException(IllegalInstrException, 0);
+            return;
+
+        default:
+            ASSERT(FALSE);
+    }
+
+    // Now we have successfully executed the instruction.
+
+    // Do any delayed load operation
+    DelayedLoad(nextLoadReg, nextLoadValue);
+
+    // Advance program counters.
+    registers[PrevPCReg] = registers[PCReg];  // for debugging, in case we
+                                              // are jumping into lala-land
+    registers[PCReg] = registers[NextPCReg];
+    registers[NextPCReg] = pcAfter;
+}
+
+//----------------------------------------------------------------------
+// Machine::DelayedLoad
+// 	Simulate effects of a delayed load.
+//
+// 	NOTE -- RaiseException/CheckInterrupts must also call DelayedLoad,
+//	since any delayed load must get applied before we trap to the kernel.
+//----------------------------------------------------------------------
+
+void Machine::DelayedLoad(int nextReg, int nextValue) {
+    registers[registers[LoadReg]] = registers[LoadValueReg];
+    registers[LoadReg] = nextReg;
+    registers[LoadValueReg] = nextValue;
+    registers[0] = 0;  // and always make sure R0 stays zero.
+}
+
+//----------------------------------------------------------------------
+// Instruction::Decode
+// 	Decode a MIPS instruction
+//----------------------------------------------------------------------
+
+void Instruction::Decode() {
+    OpInfo *opPtr;
+
+    rs = (value >> 21) & 0x1f;
+    rt = (value >> 16) & 0x1f;
+    rd = (value >> 11) & 0x1f;
+    opPtr = &opTable[(value >> 26) & 0x3f];
+    opCode = opPtr->opCode;
+    if (opPtr->format == IFMT) {
+        extra = value & 0xffff;
+        if (extra & 0x8000) {
+            extra |= 0xffff0000;
+        }
+    } else if (opPtr->format == RFMT) {
+        extra = (value >> 6) & 0x1f;
+    } else {
+        extra = value & 0x3ffffff;
+    }
+    if (opCode == SPECIAL) {
+        opCode = specialTable[value & 0x3f];
+    } else if (opCode == BCOND) {
+        int i = value & 0x1f0000;
+
+        if (i == 0) {
+            opCode = OP_BLTZ;
+        } else if (i == 0x10000) {
+            opCode = OP_BGEZ;
+        } else if (i == 0x100000) {
+            opCode = OP_BLTZAL;
+        } else if (i == 0x110000) {
+            opCode = OP_BGEZAL;
+        } else {
+            opCode = OP_UNIMP;
+        }
+    }
+}
+
+//----------------------------------------------------------------------
+// Mult
+// 	Simulate R2000 multiplication.
+// 	The words at *hiPtr and *loPtr are overwritten with the
+// 	double-length result of the multiplication.
+//----------------------------------------------------------------------
+
+static void Mult(int a, int b, bool signedArith, int *hiPtr, int *loPtr) {
+    if ((a == 0) || (b == 0)) {
+        *hiPtr = *loPtr = 0;
+        return;
+    }
+
+    // Compute the sign of the result, then make everything positive
+    // so unsigned computation can be done in the main loop.
+    bool negative = FALSE;
+    if (signedArith) {
+        if (a < 0) {
+            negative = !negative;
+            a = -a;
+        }
+        if (b < 0) {
+            negative = !negative;
+            b = -b;
+        }
+    }
+
+    // Compute the result in unsigned arithmetic (check a's bits one at
+    // a time, and add in a shifted value of b).
+    unsigned int bLo = b;
+    unsigned int bHi = 0;
+    unsigned int lo = 0;
+    unsigned int hi = 0;
+    for (int i = 0; i < 32; i++) {
+        if (a & 1) {
+            lo += bLo;
+            if (lo < bLo)  // Carry out of the low bits?
+                hi += 1;
+            hi += bHi;
+            if ((a & 0xfffffffe) == 0) break;
+        }
+        bHi <<= 1;
+        if (bLo & 0x80000000) bHi |= 1;
+
+        bLo <<= 1;
+        a >>= 1;
+    }
+
+    // If the result is supposed to be negative, compute the two's
+    // complement of the double-word result.
+    if (negative) {
+        hi = ~hi;
+        lo = ~lo;
+        lo++;
+        if (lo == 0) hi++;
+    }
+
+    *hiPtr = (int)hi;
+    *loPtr = (int)lo;
+}
diff --git a/code/machine/mipssim.h b/code/machine/mipssim.h
new file mode 100644
index 0000000..791c886
--- /dev/null
+++ b/code/machine/mipssim.h
@@ -0,0 +1,224 @@
+// mipssim.h
+//	Internal data structures for simulating the MIPS instruction set.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef MIPSSIM_H
+#define MIPSSIM_H
+
+#include "copyright.h"
+
+/*
+ * OpCode values.  The names are straight from the MIPS
+ * manual except for the following special ones:
+ *
+ * OP_UNIMP -		means that this instruction is legal, but hasn't
+ *			been implemented in the simulator yet.
+ * OP_RES -		means that this is a reserved opcode (it isn't
+ *			supported by the architecture).
+ */
+
+#define OP_ADD 1
+#define OP_ADDI 2
+#define OP_ADDIU 3
+#define OP_ADDU 4
+#define OP_AND 5
+#define OP_ANDI 6
+#define OP_BEQ 7
+#define OP_BGEZ 8
+#define OP_BGEZAL 9
+#define OP_BGTZ 10
+#define OP_BLEZ 11
+#define OP_BLTZ 12
+#define OP_BLTZAL 13
+#define OP_BNE 14
+
+#define OP_DIV 16
+#define OP_DIVU 17
+#define OP_J 18
+#define OP_JAL 19
+#define OP_JALR 20
+#define OP_JR 21
+#define OP_LB 22
+#define OP_LBU 23
+#define OP_LH 24
+#define OP_LHU 25
+#define OP_LUI 26
+#define OP_LW 27
+#define OP_LWL 28
+#define OP_LWR 29
+
+#define OP_MFHI 31
+#define OP_MFLO 32
+
+#define OP_MTHI 34
+#define OP_MTLO 35
+#define OP_MULT 36
+#define OP_MULTU 37
+#define OP_NOR 38
+#define OP_OR 39
+#define OP_ORI 40
+#define OP_RFE 41
+#define OP_SB 42
+#define OP_SH 43
+#define OP_SLL 44
+#define OP_SLLV 45
+#define OP_SLT 46
+#define OP_SLTI 47
+#define OP_SLTIU 48
+#define OP_SLTU 49
+#define OP_SRA 50
+#define OP_SRAV 51
+#define OP_SRL 52
+#define OP_SRLV 53
+#define OP_SUB 54
+#define OP_SUBU 55
+#define OP_SW 56
+#define OP_SWL 57
+#define OP_SWR 58
+#define OP_XOR 59
+#define OP_XORI 60
+#define OP_SYSCALL 61
+#define OP_UNIMP 62
+#define OP_RES 63
+#define MaxOpcode 63
+
+/*
+ * Miscellaneous definitions:
+ */
+
+#define IndexToAddr(x) ((x) << 2)
+
+#define SIGN_BIT 0x80000000
+#define R31 31
+
+/*
+ * The table below is used to translate bits 31:26 of the instruction
+ * into a value suitable for the "opCode" field of a MemWord structure,
+ * or into a special value for further decoding.
+ */
+
+#define SPECIAL 100
+#define BCOND 101
+
+#define IFMT 1
+#define JFMT 2
+#define RFMT 3
+
+struct OpInfo {
+    int opCode; /* Translated op code. */
+    int format; /* Format type (IFMT or JFMT or RFMT) */
+};
+
+static OpInfo opTable[] = {
+    {SPECIAL, RFMT},  {BCOND, IFMT},    {OP_J, JFMT},     {OP_JAL, JFMT},
+    {OP_BEQ, IFMT},   {OP_BNE, IFMT},   {OP_BLEZ, IFMT},  {OP_BGTZ, IFMT},
+    {OP_ADDI, IFMT},  {OP_ADDIU, IFMT}, {OP_SLTI, IFMT},  {OP_SLTIU, IFMT},
+    {OP_ANDI, IFMT},  {OP_ORI, IFMT},   {OP_XORI, IFMT},  {OP_LUI, IFMT},
+    {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},
+    {OP_LB, IFMT},    {OP_LH, IFMT},    {OP_LWL, IFMT},   {OP_LW, IFMT},
+    {OP_LBU, IFMT},   {OP_LHU, IFMT},   {OP_LWR, IFMT},   {OP_RES, IFMT},
+    {OP_SB, IFMT},    {OP_SH, IFMT},    {OP_SWL, IFMT},   {OP_SW, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_SWR, IFMT},   {OP_RES, IFMT},
+    {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},
+    {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT}, {OP_UNIMP, IFMT},
+    {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT},   {OP_RES, IFMT}};
+
+/*
+ * The table below is used to convert the "funct" field of SPECIAL
+ * instructions into the "opCode" field of a MemWord.
+ */
+
+static int specialTable[] = {
+    OP_SLL,  OP_RES,   OP_SRL,  OP_SRA,  OP_SLLV,    OP_RES,   OP_SRLV, OP_SRAV,
+    OP_JR,   OP_JALR,  OP_RES,  OP_RES,  OP_SYSCALL, OP_UNIMP, OP_RES,  OP_RES,
+    OP_MFHI, OP_MTHI,  OP_MFLO, OP_MTLO, OP_RES,     OP_RES,   OP_RES,  OP_RES,
+    OP_MULT, OP_MULTU, OP_DIV,  OP_DIVU, OP_RES,     OP_RES,   OP_RES,  OP_RES,
+    OP_ADD,  OP_ADDU,  OP_SUB,  OP_SUBU, OP_AND,     OP_OR,    OP_XOR,  OP_NOR,
+    OP_RES,  OP_RES,   OP_SLT,  OP_SLTU, OP_RES,     OP_RES,   OP_RES,  OP_RES,
+    OP_RES,  OP_RES,   OP_RES,  OP_RES,  OP_RES,     OP_RES,   OP_RES,  OP_RES,
+    OP_RES,  OP_RES,   OP_RES,  OP_RES,  OP_RES,     OP_RES,   OP_RES,  OP_RES};
+
+// Stuff to help print out each instruction, for debugging
+
+enum RegType { NONE, RS, RT, RD, EXTRA };
+
+struct OpString {
+    char *format;  // Printed version of instruction
+    RegType args[3];
+};
+
+static struct OpString opStrings[] = {{"Shouldn't happen", {NONE, NONE, NONE}},
+                                      {"ADD r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"ADDI r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"ADDIU r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"ADDU r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"AND r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"ANDI r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"BEQ r%d,r%d,%d", {RS, RT, EXTRA}},
+                                      {"BGEZ r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BGEZAL r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BGTZ r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BLEZ r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BLTZ r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BLTZAL r%d,%d", {RS, EXTRA, NONE}},
+                                      {"BNE r%d,r%d,%d", {RS, RT, EXTRA}},
+                                      {"Shouldn't happen", {NONE, NONE, NONE}},
+                                      {"DIV r%d,r%d", {RS, RT, NONE}},
+                                      {"DIVU r%d,r%d", {RS, RT, NONE}},
+                                      {"J %d", {EXTRA, NONE, NONE}},
+                                      {"JAL %d", {EXTRA, NONE, NONE}},
+                                      {"JALR r%d,r%d", {RD, RS, NONE}},
+                                      {"JR r%d,r%d", {RD, RS, NONE}},
+                                      {"LB r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LBU r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LH r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LHU r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LUI r%d,%d", {RT, EXTRA, NONE}},
+                                      {"LW r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LWL r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"LWR r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"Shouldn't happen", {NONE, NONE, NONE}},
+                                      {"MFHI r%d", {RD, NONE, NONE}},
+                                      {"MFLO r%d", {RD, NONE, NONE}},
+                                      {"Shouldn't happen", {NONE, NONE, NONE}},
+                                      {"MTHI r%d", {RS, NONE, NONE}},
+                                      {"MTLO r%d", {RS, NONE, NONE}},
+                                      {"MULT r%d,r%d", {RS, RT, NONE}},
+                                      {"MULTU r%d,r%d", {RS, RT, NONE}},
+                                      {"NOR r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"OR r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"ORI r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"RFE", {NONE, NONE, NONE}},
+                                      {"SB r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"SH r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"SLL r%d,r%d,%d", {RD, RT, EXTRA}},
+                                      {"SLLV r%d,r%d,r%d", {RD, RT, RS}},
+                                      {"SLT r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"SLTI r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"SLTIU r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"SLTU r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"SRA r%d,r%d,%d", {RD, RT, EXTRA}},
+                                      {"SRAV r%d,r%d,r%d", {RD, RT, RS}},
+                                      {"SRL r%d,r%d,%d", {RD, RT, EXTRA}},
+                                      {"SRLV r%d,r%d,r%d", {RD, RT, RS}},
+                                      {"SUB r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"SUBU r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"SW r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"SWL r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"SWR r%d,%d(r%d)", {RT, EXTRA, RS}},
+                                      {"XOR r%d,r%d,r%d", {RD, RS, RT}},
+                                      {"XORI r%d,r%d,%d", {RT, RS, EXTRA}},
+                                      {"SYSCALL", {NONE, NONE, NONE}},
+                                      {"Unimplemented", {NONE, NONE, NONE}},
+                                      {"Reserved", {NONE, NONE, NONE}}};
+
+#endif  // MIPSSIM_H
diff --git a/code/machine/network.cc b/code/machine/network.cc
new file mode 100644
index 0000000..0c36c5f
--- /dev/null
+++ b/code/machine/network.cc
@@ -0,0 +1,172 @@
+// network.cc
+//	Routines to simulate a network interface, using UNIX sockets
+//	to deliver packets between multiple invocations of nachos.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "network.h"
+#include "main.h"
+
+//-----------------------------------------------------------------------
+// NetworkInput::NetworkInput
+// 	Initialize the simulation for the network input
+//
+//   	"toCall" is the interrupt handler to call when packet arrives
+//-----------------------------------------------------------------------
+
+NetworkInput::NetworkInput(CallBackObj *toCall) {
+    // set up the stuff to emulate asynchronous interrupts
+    callWhenAvail = toCall;
+    packetAvail = FALSE;
+    inHdr.length = 0;
+
+    sock = OpenSocket();
+    sprintf(sockName, "SOCKET_%d", kernel->hostName);
+    AssignNameToSocket(sockName, sock);  // Bind socket to a filename
+                                         // in the current directory.
+
+    // start polling for incoming packets
+    kernel->interrupt->Schedule(this, NetworkTime, NetworkRecvInt);
+}
+
+//-----------------------------------------------------------------------
+// NetworkInput::NetworkInput
+// 	Deallocate the simulation for the network input
+//		(basically, deallocate the input mailbox)
+//-----------------------------------------------------------------------
+
+NetworkInput::~NetworkInput() {
+    CloseSocket(sock);
+    DeAssignNameToSocket(sockName);
+}
+
+//-----------------------------------------------------------------------
+// NetworkInput::CallBack
+//	Simulator calls this when a packet may be available to
+//	be read in from the simulated network.
+//
+//      First check to make sure packet is available & there's space to
+//	pull it in.  Then invoke the "callBack" registered by whoever
+//	wants the packet.
+//-----------------------------------------------------------------------
+
+void NetworkInput::CallBack() {
+    // schedule the next time to poll for a packet
+    kernel->interrupt->Schedule(this, NetworkTime, NetworkRecvInt);
+
+    if (inHdr.length != 0)  // do nothing if packet is already buffered
+        return;
+    if (!PollSocket(sock))  // do nothing if no packet to be read
+        return;
+
+    // otherwise, read packet in
+    char *buffer = new char[MaxWireSize];
+    ReadFromSocket(sock, buffer, MaxWireSize);
+
+    // divide packet into header and data
+    inHdr = *(PacketHeader *)buffer;
+    ASSERT((inHdr.to == kernel->hostName) && (inHdr.length <= MaxPacketSize));
+    bcopy(buffer + sizeof(PacketHeader), inbox, inHdr.length);
+    delete[] buffer;
+
+    DEBUG(dbgNet, "Network received packet from " << inHdr.from << ", length "
+                                                  << inHdr.length);
+    kernel->stats->numPacketsRecvd++;
+
+    // tell post office that the packet has arrived
+    callWhenAvail->CallBack();
+}
+
+//-----------------------------------------------------------------------
+// NetworkInput::Receive
+// 	Read a packet, if one is buffered
+//-----------------------------------------------------------------------
+
+PacketHeader NetworkInput::Receive(char *data) {
+    PacketHeader hdr = inHdr;
+
+    inHdr.length = 0;
+    if (hdr.length != 0) {
+        bcopy(inbox, data, hdr.length);
+    }
+    return hdr;
+}
+
+//-----------------------------------------------------------------------
+// NetworkOutput::NetworkOutput
+// 	Initialize the simulation for sending network packets
+//
+//   	"reliability" says whether we drop packets to emulate unreliable links
+//   	"toCall" is the interrupt handler to call when next packet can be sent
+//-----------------------------------------------------------------------
+
+NetworkOutput::NetworkOutput(double reliability, CallBackObj *toCall) {
+    if (reliability < 0)
+        chanceToWork = 0;
+    else if (reliability > 1)
+        chanceToWork = 1;
+    else
+        chanceToWork = reliability;
+
+    // set up the stuff to emulate asynchronous interrupts
+    callWhenDone = toCall;
+    sendBusy = FALSE;
+    sock = OpenSocket();
+}
+
+//-----------------------------------------------------------------------
+// NetworkOutput::~NetworkOutput
+// 	Deallocate the simulation for sending network packets
+//-----------------------------------------------------------------------
+
+NetworkOutput::~NetworkOutput() { CloseSocket(sock); }
+
+//-----------------------------------------------------------------------
+// NetworkOutput::CallBack
+// 	Called by simulator when another packet can be sent.
+//-----------------------------------------------------------------------
+
+void NetworkOutput::CallBack() {
+    sendBusy = FALSE;
+    kernel->stats->numPacketsSent++;
+    callWhenDone->CallBack();
+}
+
+//-----------------------------------------------------------------------
+// NetworkOutput::Send
+// 	Send a packet into the simulated network, to the destination in hdr.
+// 	Concatenate hdr and data, and schedule an interrupt to tell the user
+// 	when the next packet can be sent
+//
+// 	Note we always pad out a packet to MaxWireSize before putting it into
+// 	the socket, because it's simpler at the receive end.
+//-----------------------------------------------------------------------
+
+void NetworkOutput::Send(PacketHeader hdr, char *data) {
+    char toName[32];
+
+    sprintf(toName, "SOCKET_%d", (int)hdr.to);
+
+    ASSERT((sendBusy == FALSE) && (hdr.length > 0) &&
+           (hdr.length <= MaxPacketSize) && (hdr.from == kernel->hostName));
+    DEBUG(dbgNet, "Sending to addr " << hdr.to << ", length " << hdr.length);
+
+    kernel->interrupt->Schedule(this, NetworkTime, NetworkSendInt);
+
+    if (RandomNumber() % 100 >= chanceToWork * 100) {  // emulate a lost packet
+        DEBUG(dbgNet, "oops, lost it!");
+        return;
+    }
+
+    // concatenate hdr and data into a single buffer, and send it out
+    char *buffer = new char[MaxWireSize];
+    *(PacketHeader *)buffer = hdr;
+    bcopy(data, buffer + sizeof(PacketHeader), hdr.length);
+    SendToSocket(sock, buffer, MaxWireSize, toName);
+    delete[] buffer;
+}
diff --git a/code/machine/network.h b/code/machine/network.h
new file mode 100644
index 0000000..27a61ac
--- /dev/null
+++ b/code/machine/network.h
@@ -0,0 +1,109 @@
+// network.h
+//	Data structures to emulate a physical network connection.
+//	The network provides the abstraction of ordered, unreliable,
+//	fixed-size packet delivery to other machines on the network.
+//
+//	You may note that the interface to the network is similar to
+//	the console device -- both are full duplex channels.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef NETWORK_H
+#define NETWORK_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+
+// Network address -- uniquely identifies a machine.  This machine's ID
+//  is given on the command line.
+typedef int NetworkAddress;
+
+// The following class defines the network packet header.
+// The packet header is prepended to the data payload by the Network driver,
+// before the packet is sent over the wire.  The format on the wire is:
+//	packet header (PacketHeader)
+//	data (containing MailHeader from the PostOffice!)
+
+class PacketHeader {
+   public:
+    NetworkAddress to;    // Destination machine ID
+    NetworkAddress from;  // source machine ID
+    unsigned length;      // bytes of packet data, excluding the
+                          // packet header (but including the
+                          // MailHeader prepended by the post office)
+};
+
+#define MaxWireSize 64  // largest packet that can go out on the wire
+#define MaxPacketSize (MaxWireSize - sizeof(struct PacketHeader))
+// data "payload" of the largest packet
+
+// The following two classes defines a physical network device.  The network
+// is capable of delivering fixed sized packets, in order but unreliably,
+// to other machines connected to the network.
+//
+// The "reliability" of the network can be specified to the constructor.
+// This number, between 0 and 1, is the chance that the network will lose
+// a packet.  Note that you can change the seed for the random number
+// generator, by changing the arguments to RandomInit() in Initialize().
+// The random number generator is used to choose which packets to drop.
+
+class NetworkInput : public CallBackObj {
+   public:
+    NetworkInput(CallBackObj *toCall);
+    // Allocate and initialize network input driver
+    ~NetworkInput();  // De-allocate the network input driver data
+
+    PacketHeader Receive(char *data);
+    // Poll the network for incoming messages.
+    // If there is a packet waiting, copy the
+    // packet into "data" and return the header.
+    // If no packet is waiting, return a header
+    // with length 0.
+
+    void CallBack();  // A packet may have arrived.
+
+   private:
+    int sock;           // UNIX socket number for incoming packets
+    char sockName[32];  // File name corresponding to UNIX socket
+
+    CallBackObj *callWhenAvail;  // Interrupt handler, signalling packet has
+                                 // 	arrived.
+    bool packetAvail;            // Packet has arrived, can be pulled off of
+                                 //   network
+    PacketHeader inHdr;          // Information about arrived packet
+    char inbox[MaxPacketSize];   // Data for arrived packet
+};
+
+class NetworkOutput : public CallBackObj {
+   public:
+    NetworkOutput(double reliability, CallBackObj *toCall);
+    // Allocate and initialize network output driver
+    ~NetworkOutput();  // De-allocate the network input driver data
+
+    void Send(PacketHeader hdr, char *data);
+    // Send the packet data to a remote machine,
+    // specified by "hdr".  Returns immediately.
+    // "callWhenDone" is invoked once the next
+    // packet can be sent.  Note that callWhenDone
+    // is called whether or not the packet is
+    // dropped, and note that the "from" field of
+    // the PacketHeader is filled in automatically
+    // by Send().
+
+    void CallBack();  // Interrupt handler, called when message is
+                      // sent
+
+   private:
+    int sock;                   // UNIX socket number for outgoing packets
+    double chanceToWork;        // Likelihood packet will be dropped
+    CallBackObj *callWhenDone;  // Interrupt handler, signalling next packet
+                                //      can be sent.
+    bool sendBusy;              // Packet is being sent.
+};
+
+#endif  // NETWORK_H
diff --git a/code/machine/stats.cc b/code/machine/stats.cc
new file mode 100644
index 0000000..6fb0e64
--- /dev/null
+++ b/code/machine/stats.cc
@@ -0,0 +1,42 @@
+// stats.h
+//	Routines for managing statistics about Nachos performance.
+//
+// DO NOT CHANGE -- these stats are maintained by the machine emulation.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "debug.h"
+#include "stats.h"
+
+//----------------------------------------------------------------------
+// Statistics::Statistics
+// 	Initialize performance metrics to zero, at system startup.
+//----------------------------------------------------------------------
+
+Statistics::Statistics() {
+    totalTicks = idleTicks = systemTicks = userTicks = 0;
+    numDiskReads = numDiskWrites = 0;
+    numConsoleCharsRead = numConsoleCharsWritten = 0;
+    numPageFaults = numPacketsSent = numPacketsRecvd = 0;
+}
+
+//----------------------------------------------------------------------
+// Statistics::Print
+// 	Print performance metrics, when we've finished everything
+//	at system shutdown.
+//----------------------------------------------------------------------
+
+void Statistics::Print() {
+    cout << "Ticks: total " << totalTicks << ", idle " << idleTicks;
+    cout << ", system " << systemTicks << ", user " << userTicks << "\n";
+    cout << "Disk I/O: reads " << numDiskReads;
+    cout << ", writes " << numDiskWrites << "\n";
+    cout << "Console I/O: reads " << numConsoleCharsRead;
+    cout << ", writes " << numConsoleCharsWritten << "\n";
+    cout << "Paging: faults " << numPageFaults << "\n";
+    cout << "Network I/O: packets received " << numPacketsRecvd;
+    cout << ", sent " << numPacketsSent << "\n";
+}
diff --git a/code/machine/stats.h b/code/machine/stats.h
new file mode 100644
index 0000000..db2cbf3
--- /dev/null
+++ b/code/machine/stats.h
@@ -0,0 +1,60 @@
+// stats.h
+//	Data structures for gathering statistics about Nachos performance.
+//
+// DO NOT CHANGE -- these stats are maintained by the machine emulation
+//
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef STATS_H
+#define STATS_H
+
+#include "copyright.h"
+
+// The following class defines the statistics that are to be kept
+// about Nachos behavior -- how much time (ticks) elapsed, how
+// many user instructions executed, etc.
+//
+// The fields in this class are public to make it easier to update.
+
+class Statistics {
+   public:
+    int totalTicks;   // Total time running Nachos
+    int idleTicks;    // Time spent idle (no threads to run)
+    int systemTicks;  // Time spent executing system code
+    int userTicks;    // Time spent executing user code
+                      // (this is also equal to # of
+                      // user instructions executed)
+
+    int numDiskReads;            // number of disk read requests
+    int numDiskWrites;           // number of disk write requests
+    int numConsoleCharsRead;     // number of characters read from the keyboard
+    int numConsoleCharsWritten;  // number of characters written to the display
+    int numPageFaults;           // number of virtual memory page faults
+    int numPacketsSent;          // number of packets sent over the network
+    int numPacketsRecvd;         // number of packets received over the network
+
+    Statistics();  // initialize everything to zero
+
+    void Print();  // print collected statistics
+};
+
+// Constants used to reflect the relative time an operation would
+// take in a real system.  A "tick" is a just a unit of time -- if you
+// like, a microsecond.
+//
+// Since Nachos kernel code is directly executed, and the time spent
+// in the kernel measured by the number of calls to enable interrupts,
+// these time constants are none too exact.
+
+const int UserTick = 1;        // advance for each user-level instruction
+const int SystemTick = 10;     // advance each time interrupts are enabled
+const int RotationTime = 500;  // time disk takes to rotate one sector
+const int SeekTime = 500;      // time disk takes to seek past one track
+const int ConsoleTime = 100;   // time to read or write one character
+const int NetworkTime = 100;   // time to send or receive one packet
+const int TimerTicks = 100;    // (average) time between timer interrupts
+
+#endif  // STATS_H
diff --git a/code/machine/timer.cc b/code/machine/timer.cc
new file mode 100644
index 0000000..c18c317
--- /dev/null
+++ b/code/machine/timer.cc
@@ -0,0 +1,76 @@
+// timer.cc
+//	Routines to emulate a hardware timer device.
+//
+//      A hardware timer generates a CPU interrupt every X milliseconds.
+//      This means it can be used for implementing time-slicing.
+//
+//      We emulate a hardware timer by scheduling an interrupt to occur
+//      every time stats->totalTicks has increased by TimerTicks.
+//
+//      In order to introduce some randomness into time-slicing, if "doRandom"
+//      is set, then the interrupt is comes after a random number of ticks.
+//
+//	Remember -- nothing in here is part of Nachos.  It is just
+//	an emulation for the hardware that Nachos is running on top of.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "timer.h"
+#include "main.h"
+#include "sysdep.h"
+
+//----------------------------------------------------------------------
+// Timer::Timer
+//      Initialize a hardware timer device.  Save the place to call
+//	on each interrupt, and then arrange for the timer to start
+//	generating interrupts.
+//
+//      "doRandom" -- if true, arrange for the interrupts to occur
+//		at random, instead of fixed, intervals.
+//      "toCall" is the interrupt handler to call when the timer expires.
+//----------------------------------------------------------------------
+
+Timer::Timer(bool doRandom, CallBackObj *toCall) {
+    randomize = doRandom;
+    callPeriodically = toCall;
+    disable = FALSE;
+    SetInterrupt();
+}
+
+//----------------------------------------------------------------------
+// Timer::CallBack
+//      Routine called when interrupt is generated by the hardware
+//	timer device.  Schedule the next interrupt, and invoke the
+//	interrupt handler.
+//----------------------------------------------------------------------
+void Timer::CallBack() {
+    // invoke the Nachos interrupt handler for this device
+    callPeriodically->CallBack();
+
+    SetInterrupt();  // do last, to let software interrupt handler
+                     // decide if it wants to disable future interrupts
+}
+
+//----------------------------------------------------------------------
+// Timer::SetInterrupt
+//      Cause a timer interrupt to occur in the future, unless
+//	future interrupts have been disabled.  The delay is either
+//	fixed or random.
+//----------------------------------------------------------------------
+
+void Timer::SetInterrupt() {
+    if (!disable) {
+        int delay = TimerTicks;
+
+        if (randomize) {
+            delay = 1 + (RandomNumber() % (TimerTicks * 2));
+        }
+        // schedule the next timer device interrupt
+        kernel->interrupt->Schedule(this, delay, TimerInt);
+    }
+}
diff --git a/code/machine/timer.h b/code/machine/timer.h
new file mode 100644
index 0000000..e262ff5
--- /dev/null
+++ b/code/machine/timer.h
@@ -0,0 +1,53 @@
+// timer.h
+//	Data structures to emulate a hardware timer.
+//
+//	A hardware timer generates a CPU interrupt every X milliseconds.
+//	This means it can be used for implementing time-slicing, or for
+//	having a thread go to sleep for a specific period of time.
+//
+//	We emulate a hardware timer by scheduling an interrupt to occur
+//	every time stats->totalTicks has increased by TimerTicks.
+//
+//	In order to introduce some randomness into time-slicing, if "doRandom"
+//	is set, then the interrupt comes after a random number of ticks.
+//
+//  DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef TIMER_H
+#define TIMER_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+
+// The following class defines a hardware timer.
+class Timer : public CallBackObj {
+   public:
+    Timer(bool doRandom, CallBackObj *toCall);
+    // Initialize the timer, and callback to "toCall"
+    // every time slice.
+    virtual ~Timer() {}
+
+    void Disable() { disable = TRUE; }
+    // Turn timer device off, so it doesn't
+    // generate any more interrupts.
+
+   private:
+    bool randomize;  // set if we need to use a random timeout delay
+    CallBackObj *callPeriodically;  // call this every TimerTicks time units
+    bool disable;                   // turn off the timer device after next
+                                    // interrupt.
+
+    void CallBack();  // called internally when the hardware
+                      // timer generates an interrupt
+
+    void SetInterrupt();  // cause an interrupt to occur in the
+                          // the future after a fixed or random
+    // delay
+};
+
+#endif  // TIMER_H
diff --git a/code/machine/translate.cc b/code/machine/translate.cc
new file mode 100644
index 0000000..631f32e
--- /dev/null
+++ b/code/machine/translate.cc
@@ -0,0 +1,248 @@
+// translate.cc
+//	Routines to translate virtual addresses to physical addresses.
+//	Software sets up a table of legal translations.  We look up
+//	in the table on every memory reference to find the true physical
+//	memory location.
+//
+// Two types of translation are supported here.
+//
+//	Linear page table -- the virtual page # is used as an index
+//	into the table, to find the physical page #.
+//
+//	Translation lookaside buffer -- associative lookup in the table
+//	to find an entry with the same virtual page #.  If found,
+//	this entry is used for the translation.
+//	If not, it traps to software with an exception.
+//
+//	In practice, the TLB is much smaller than the amount of physical
+//	memory (16 entries is common on a machine that has 1000's of
+//	pages).  Thus, there must also be a backup translation scheme
+//	(such as page tables), but the hardware doesn't need to know
+//	anything at all about that.
+//
+//	Note that the contents of the TLB are specific to an address space.
+//	If the address space changes, so does the contents of the TLB!
+//
+// DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "main.h"
+
+// Routines for converting Words and Short Words to and from the
+// simulated machine's format of little endian.  These end up
+// being NOPs when the host machine is also little endian (DEC and Intel).
+
+unsigned int WordToHost(unsigned int word) {
+#ifdef HOST_IS_BIG_ENDIAN
+    register unsigned long result;
+    result = (word >> 24) & 0x000000ff;
+    result |= (word >> 8) & 0x0000ff00;
+    result |= (word << 8) & 0x00ff0000;
+    result |= (word << 24) & 0xff000000;
+    return result;
+#else
+    return word;
+#endif /* HOST_IS_BIG_ENDIAN */
+}
+
+unsigned short ShortToHost(unsigned short shortword) {
+#ifdef HOST_IS_BIG_ENDIAN
+    register unsigned short result;
+    result = (shortword << 8) & 0xff00;
+    result |= (shortword >> 8) & 0x00ff;
+    return result;
+#else
+    return shortword;
+#endif /* HOST_IS_BIG_ENDIAN */
+}
+
+unsigned int WordToMachine(unsigned int word) { return WordToHost(word); }
+
+unsigned short ShortToMachine(unsigned short shortword) {
+    return ShortToHost(shortword);
+}
+
+//----------------------------------------------------------------------
+// Machine::ReadMem
+//      Read "size" (1, 2, or 4) bytes of virtual memory at "addr" into
+//	the location pointed to by "value".
+//
+//   	Returns FALSE if the translation step from virtual to physical memory
+//   	failed.
+//
+//	"addr" -- the virtual address to read from
+//	"size" -- the number of bytes to read (1, 2, or 4)
+//	"value" -- the place to write the result
+//----------------------------------------------------------------------
+
+bool Machine::ReadMem(int addr, int size, int *value) {
+    int data;
+    ExceptionType exception;
+    int physicalAddress;
+
+    DEBUG(dbgAddr, "Reading VA " << addr << ", size " << size);
+
+    exception = Translate(addr, &physicalAddress, size, FALSE);
+    if (exception != NoException) {
+        RaiseException(exception, addr);
+        return FALSE;
+    }
+    switch (size) {
+        case 1:
+            data = mainMemory[physicalAddress];
+            *value = data;
+            break;
+
+        case 2:
+            data = *(unsigned short *)&mainMemory[physicalAddress];
+            *value = ShortToHost(data);
+            break;
+
+        case 4:
+            data = *(unsigned int *)&mainMemory[physicalAddress];
+            *value = WordToHost(data);
+            break;
+
+        default:
+            ASSERT(FALSE);
+    }
+
+    DEBUG(dbgAddr, "\tvalue read = " << *value);
+    return (TRUE);
+}
+
+//----------------------------------------------------------------------
+// Machine::WriteMem
+//      Write "size" (1, 2, or 4) bytes of the contents of "value" into
+//	virtual memory at location "addr".
+//
+//   	Returns FALSE if the translation step from virtual to physical memory
+//   	failed.
+//
+//	"addr" -- the virtual address to write to
+//	"size" -- the number of bytes to be written (1, 2, or 4)
+//	"value" -- the data to be written
+//----------------------------------------------------------------------
+
+bool Machine::WriteMem(int addr, int size, int value) {
+    ExceptionType exception;
+    int physicalAddress;
+
+    DEBUG(dbgAddr,
+          "Writing VA " << addr << ", size " << size << ", value " << value);
+
+    exception = Translate(addr, &physicalAddress, size, TRUE);
+    if (exception != NoException) {
+        RaiseException(exception, addr);
+        return FALSE;
+    }
+    switch (size) {
+        case 1:
+            mainMemory[physicalAddress] = (unsigned char)(value & 0xff);
+            break;
+
+        case 2:
+            *(unsigned short *)&mainMemory[physicalAddress] =
+                ShortToMachine((unsigned short)(value & 0xffff));
+            break;
+
+        case 4:
+            *(unsigned int *)&mainMemory[physicalAddress] =
+                WordToMachine((unsigned int)value);
+            break;
+
+        default:
+            ASSERT(FALSE);
+    }
+
+    return TRUE;
+}
+
+//----------------------------------------------------------------------
+// Machine::Translate
+// 	Translate a virtual address into a physical address, using
+//	either a page table or a TLB.  Check for alignment and all sorts
+//	of other errors, and if everything is ok, set the use/dirty bits in
+//	the translation table entry, and store the translated physical
+//	address in "physAddr".  If there was an error, returns the type
+//	of the exception.
+//
+//	"virtAddr" -- the virtual address to translate
+//	"physAddr" -- the place to store the physical address
+//	"size" -- the amount of memory being read or written
+// 	"writing" -- if TRUE, check the "read-only" bit in the TLB
+//----------------------------------------------------------------------
+
+ExceptionType Machine::Translate(int virtAddr, int *physAddr, int size,
+                                 bool writing) {
+    int i;
+    unsigned int vpn, offset;
+    TranslationEntry *entry;
+    unsigned int pageFrame;
+
+    DEBUG(dbgAddr,
+          "\tTranslate " << virtAddr << (writing ? " , write" : " , read"));
+
+    // check for alignment errors
+    if (((size == 4) && (virtAddr & 0x3)) ||
+        ((size == 2) && (virtAddr & 0x1))) {
+        DEBUG(dbgAddr,
+              "Alignment problem at " << virtAddr << ", size " << size);
+        return AddressErrorException;
+    }
+
+    // we must have either a TLB or a page table, but not both!
+    ASSERT(tlb == NULL || pageTable == NULL);
+    ASSERT(tlb != NULL || pageTable != NULL);
+
+    // calculate the virtual page number, and offset within the page,
+    // from the virtual address
+    vpn = (unsigned)virtAddr / PageSize;
+    offset = (unsigned)virtAddr % PageSize;
+
+    if (tlb == NULL) {  // => page table => vpn is index into table
+        if (vpn >= pageTableSize) {
+            DEBUG(dbgAddr, "Illegal virtual page # " << virtAddr);
+            return AddressErrorException;
+        } else if (!pageTable[vpn].valid) {
+            DEBUG(dbgAddr, "Invalid virtual page # " << virtAddr);
+            return PageFaultException;
+        }
+        entry = &pageTable[vpn];
+    } else {
+        for (entry = NULL, i = 0; i < TLBSize; i++)
+            if (tlb[i].valid && (tlb[i].virtualPage == ((int)vpn))) {
+                entry = &tlb[i];  // FOUND!
+                break;
+            }
+        if (entry == NULL) {  // not found
+            DEBUG(dbgAddr, "Invalid TLB entry for this virtual page!");
+            return PageFaultException;  // really, this is a TLB fault,
+                                        // the page may be in memory,
+                                        // but not in the TLB
+        }
+    }
+
+    if (entry->readOnly && writing) {  // trying to write to a read-only page
+        DEBUG(dbgAddr, "Write to read-only page at " << virtAddr);
+        return ReadOnlyException;
+    }
+    pageFrame = entry->physicalPage;
+
+    // if the pageFrame is too big, there is something really wrong!
+    // An invalid translation was loaded into the page table or TLB.
+    if (pageFrame >= NumPhysPages) {
+        DEBUG(dbgAddr, "Illegal pageframe " << pageFrame);
+        return BusErrorException;
+    }
+    entry->use = TRUE;  // set the use, dirty bits
+    if (writing) entry->dirty = TRUE;
+    *physAddr = pageFrame * PageSize + offset;
+    ASSERT((*physAddr >= 0) && ((*physAddr + size) <= MemorySize));
+    DEBUG(dbgAddr, "phys addr = " << *physAddr);
+    return NoException;
+}
diff --git a/code/machine/translate.h b/code/machine/translate.h
new file mode 100644
index 0000000..50fbb2b
--- /dev/null
+++ b/code/machine/translate.h
@@ -0,0 +1,45 @@
+// translate.h
+//	Data structures for managing the translation from
+//	virtual page # -> physical page #, used for managing
+//	physical memory on behalf of user programs.
+//
+//	The data structures in this file are "dual-use" - they
+//	serve both as a page table entry, and as an entry in
+//	a software-managed translation lookaside buffer (TLB).
+//	Either way, each entry is of the form:
+//	<virtual page #, physical page #>.
+//
+// DO NOT CHANGE -- part of the machine emulation
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef TLB_H
+#define TLB_H
+
+#include "copyright.h"
+#include "utility.h"
+
+// The following class defines an entry in a translation table -- either
+// in a page table or a TLB.  Each entry defines a mapping from one
+// virtual page to one physical page.
+// In addition, there are some extra bits for access control (valid and
+// read-only) and some bits for usage information (use and dirty).
+
+class TranslationEntry {
+   public:
+    int virtualPage;   // The page number in virtual memory.
+    int physicalPage;  // The page number in real memory (relative to the
+                       //  start of "mainMemory"
+    bool valid;        // If this bit is set, the translation is ignored.
+                       // (In other words, the entry hasn't been initialized.)
+    bool readOnly;     // If this bit is set, the user program is not allowed
+                       // to modify the contents of the page.
+    bool use;          // This bit is set by the hardware every time the
+                       // page is referenced or modified.
+    bool dirty;        // This bit is set by the hardware every time the
+                       // page is modified.
+};
+
+#endif
diff --git a/code/network/post.cc b/code/network/post.cc
new file mode 100644
index 0000000..84e8b67
--- /dev/null
+++ b/code/network/post.cc
@@ -0,0 +1,314 @@
+// post.cc
+// 	Routines to deliver incoming network messages to the correct
+//	"address" -- a mailbox, or a holding area for incoming messages.
+//	This module operates just like the US postal service (in other
+//	words, it works, but it's slow, and you can't really be sure if
+//	your mail really got through!).
+//
+//	Note that once we prepend the MailHdr to the outgoing message data,
+//	the combination (MailHdr plus data) looks like "data" to the Network
+//	device.
+//
+// 	The implementation synchronizes incoming messages with threads
+//	waiting for those messages.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "post.h"
+
+//----------------------------------------------------------------------
+// Mail::Mail
+//      Initialize a single mail message, by concatenating the headers to
+//	the data.
+//
+//	"pktH" -- source, destination machine ID's
+//	"mailH" -- source, destination mailbox ID's
+//	"data" -- payload data
+//----------------------------------------------------------------------
+
+Mail::Mail(PacketHeader pktH, MailHeader mailH, char *msgData) {
+    ASSERT(mailH.length <= MaxMailSize);
+
+    pktHdr = pktH;
+    mailHdr = mailH;
+    bcopy(msgData, data, mailHdr.length);
+}
+
+//----------------------------------------------------------------------
+// MailBox::MailBox
+//      Initialize a single mail box within the post office, so that it
+//	can receive incoming messages.
+//
+//	Just initialize a list of messages, representing the mailbox.
+//----------------------------------------------------------------------
+
+MailBox::MailBox() { messages = new SynchList<Mail *>(); }
+
+//----------------------------------------------------------------------
+// MailBox::~MailBox
+//      De-allocate a single mail box within the post office.
+//
+//	Just delete the mailbox, and throw away all the queued messages
+//	in the mailbox.
+//----------------------------------------------------------------------
+
+MailBox::~MailBox() { delete messages; }
+
+//----------------------------------------------------------------------
+// PrintHeader
+// 	Print the message header -- the destination machine ID and mailbox
+//	#, source machine ID and mailbox #, and message length.
+//
+//	"pktHdr" -- source, destination machine ID's
+//	"mailHdr" -- source, destination mailbox ID's
+//----------------------------------------------------------------------
+
+static void PrintHeader(PacketHeader pktHdr, MailHeader mailHdr) {
+    cout << "From (" << pktHdr.from << ", " << mailHdr.from << ") to ("
+         << pktHdr.to << ", " << mailHdr.to << ") bytes " << mailHdr.length
+         << "\n";
+}
+
+//----------------------------------------------------------------------
+// MailBox::Put
+// 	Add a message to the mailbox.  If anyone is waiting for message
+//	arrival, wake them up!
+//
+//	We need to reconstruct the Mail message (by concatenating the headers
+//	to the data), to simplify queueing the message on the SynchList.
+//
+//	"pktHdr" -- source, destination machine ID's
+//	"mailHdr" -- source, destination mailbox ID's
+//	"data" -- payload message data
+//----------------------------------------------------------------------
+
+void MailBox::Put(PacketHeader pktHdr, MailHeader mailHdr, char *data) {
+    Mail *mail = new Mail(pktHdr, mailHdr, data);
+
+    messages->Append(mail);  // put on the end of the list of
+                             // arrived messages, and wake up
+                             // any waiters
+}
+
+//----------------------------------------------------------------------
+// MailBox::Get
+// 	Get a message from a mailbox, parsing it into the packet header,
+//	mailbox header, and data.
+//
+//	The calling thread waits if there are no messages in the mailbox.
+//
+//	"pktHdr" -- address to put: source, destination machine ID's
+//	"mailHdr" -- address to put: source, destination mailbox ID's
+//	"data" -- address to put: payload message data
+//----------------------------------------------------------------------
+
+void MailBox::Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data) {
+    DEBUG(dbgNet, "Waiting for mail in mailbox");
+    Mail *mail = messages->RemoveFront();  // remove message from list;
+                                           // will wait if list is empty
+
+    *pktHdr = mail->pktHdr;
+    *mailHdr = mail->mailHdr;
+    if (debug->IsEnabled('n')) {
+        cout << "Got mail from mailbox: ";
+        PrintHeader(*pktHdr, *mailHdr);
+    }
+    bcopy(mail->data, data, mail->mailHdr.length);
+    // copy the message data into
+    // the caller's buffer
+    delete mail;  // we've copied out the stuff we
+                  // need, we can now discard the message
+}
+
+//----------------------------------------------------------------------
+// PostOfficeInput::PostOfficeInput
+// 	Initialize the post office input queues as a collection of mailboxes.
+//	Also initialize the network device, to allow post offices
+//	on different machines to deliver messages to one another.
+//
+//      We use a separate thread "the postal worker" to wait for messages
+//	to arrive, and deliver them to the correct mailbox.  Note that
+//	delivering messages to the mailboxes can't be done directly
+//	by the interrupt handlers, because it requires a Lock.
+//
+//	"nBoxes" is the number of mail boxes in this Post Office
+//----------------------------------------------------------------------
+
+PostOfficeInput::PostOfficeInput(int nBoxes) {
+    messageAvailable = new Semaphore("message available", 0);
+
+    numBoxes = nBoxes;
+    boxes = new MailBox[nBoxes];
+
+    network = new NetworkInput(this);
+
+    Thread *t = new Thread("postal worker");
+
+    t->Fork(PostOfficeInput::PostalDelivery, this);
+}
+
+//----------------------------------------------------------------------
+// PostOfficeInput::~PostOfficeInput
+// 	De-allocate the post office data structures.
+//
+//	Since the postal helper is waiting on the "messageAvail" semaphore,
+//	we don't deallocate it!  This leaves garbage lying about,
+//	but the alternative is worse!
+//----------------------------------------------------------------------
+
+PostOfficeInput::~PostOfficeInput() {
+    delete network;
+    delete[] boxes;
+}
+
+//----------------------------------------------------------------------
+// PostOffice::PostalDelivery
+// 	Wait for incoming messages, and put them in the right mailbox.
+//
+//      Incoming messages have had the PacketHeader stripped off,
+//	but the MailHeader is still tacked on the front of the data.
+//----------------------------------------------------------------------
+
+void PostOfficeInput::PostalDelivery(void *data) {
+    PostOfficeInput *_this = (PostOfficeInput *)data;
+    PacketHeader pktHdr;
+    MailHeader mailHdr;
+    char *buffer = new char[MaxPacketSize];
+
+    for (;;) {
+        // first, wait for a message
+        _this->messageAvailable->P();
+        pktHdr = _this->network->Receive(buffer);
+
+        mailHdr = *(MailHeader *)buffer;
+        if (debug->IsEnabled('n')) {
+            cout << "Putting mail into mailbox: ";
+            PrintHeader(pktHdr, mailHdr);
+        }
+
+        // check that arriving message is legal!
+        ASSERT(0 <= mailHdr.to && mailHdr.to < _this->numBoxes);
+        ASSERT(mailHdr.length <= MaxMailSize);
+
+        // put into mailbox
+        _this->boxes[mailHdr.to].Put(pktHdr, mailHdr,
+                                     buffer + sizeof(MailHeader));
+    }
+}
+
+//----------------------------------------------------------------------
+// PostOfficeInput::Receive
+// 	Retrieve a message from a specific box if one is available,
+//	otherwise wait for a message to arrive in the box.
+//
+//	Note that the MailHeader + data looks just like normal payload
+//	data to the Network.
+//
+//
+//	"box" -- mailbox ID in which to look for message
+//	"pktHdr" -- address to put: source, destination machine ID's
+//	"mailHdr" -- address to put: source, destination mailbox ID's
+//	"data" -- address to put: payload message data
+//----------------------------------------------------------------------
+
+void PostOfficeInput::Receive(int box, PacketHeader *pktHdr,
+                              MailHeader *mailHdr, char *data) {
+    ASSERT((box >= 0) && (box < numBoxes));
+
+    boxes[box].Get(pktHdr, mailHdr, data);
+    ASSERT(mailHdr->length <= MaxMailSize);
+}
+
+//----------------------------------------------------------------------
+// PostOffice::CallBack
+// 	Interrupt handler, called when a packet arrives from the network.
+//
+//	Signal the PostalDelivery routine that it is time to get to work!
+//----------------------------------------------------------------------
+
+void PostOfficeInput::CallBack() { messageAvailable->V(); }
+
+//----------------------------------------------------------------------
+// PostOfficeOutput::PostOfficeOutput
+// 	Initialize the post office output queue.
+//
+//	"reliability" is the probability that a network packet will
+//	  be delivered (e.g., reliability = 1 means the network never
+//	  drops any packets; reliability = 0 means the network never
+//	  delivers any packets)
+//----------------------------------------------------------------------
+
+PostOfficeOutput::PostOfficeOutput(double reliability) {
+    messageSent = new Semaphore("message sent", 0);
+    sendLock = new Lock("message send lock");
+
+    network = new NetworkOutput(reliability, this);
+}
+
+//----------------------------------------------------------------------
+// PostOfficeOutput::~PostOfficeOutput
+// 	De-allocate the post office data structures.
+//----------------------------------------------------------------------
+
+PostOfficeOutput::~PostOfficeOutput() {
+    delete network;
+    delete messageSent;
+    delete sendLock;
+}
+
+//----------------------------------------------------------------------
+// PostOfficeOutput::Send
+// 	Concatenate the MailHeader to the front of the data, and pass
+//	the result to the Network for delivery to the destination machine.
+//
+//	Note that the MailHeader + data looks just like normal payload
+//	data to the Network.
+//
+//	"pktHdr" -- source, destination machine ID's
+//	"mailHdr" -- source, destination mailbox ID's
+//	"data" -- payload message data
+//----------------------------------------------------------------------
+
+void PostOfficeOutput::Send(PacketHeader pktHdr, MailHeader mailHdr,
+                            char *data) {
+    char *buffer = new char[MaxPacketSize];  // space to hold concatenated
+                                             // mailHdr + data
+
+    if (debug->IsEnabled('n')) {
+        cout << "Post send: ";
+        PrintHeader(pktHdr, mailHdr);
+    }
+    ASSERT(mailHdr.length <= MaxMailSize);
+    ASSERT(0 <= mailHdr.to);
+
+    // fill in pktHdr, for the Network layer
+    pktHdr.from = kernel->hostName;
+    pktHdr.length = mailHdr.length + sizeof(MailHeader);
+
+    // concatenate MailHeader and data
+    bcopy((char *)&mailHdr, buffer, sizeof(MailHeader));
+    bcopy(data, buffer + sizeof(MailHeader), mailHdr.length);
+
+    sendLock->Acquire();  // only one message can be sent
+                          // to the network at any one time
+    network->Send(pktHdr, buffer);
+    messageSent->P();  // wait for interrupt to tell us
+                       // ok to send the next message
+    sendLock->Release();
+
+    delete[] buffer;  // we've sent the message, so
+                      // we can delete our buffer
+}
+
+//----------------------------------------------------------------------
+// PostOfficeOutput::CallBack
+// 	Interrupt handler, called when the next packet can be put onto the
+//	network.
+//
+//	Called even if the previous packet was dropped.
+//----------------------------------------------------------------------
+
+void PostOfficeOutput::CallBack() { messageSent->V(); }
diff --git a/code/network/post.h b/code/network/post.h
new file mode 100644
index 0000000..ed0b19d
--- /dev/null
+++ b/code/network/post.h
@@ -0,0 +1,151 @@
+// post.h
+//	Data structures for providing the abstraction of unreliable,
+//	ordered, fixed-size message delivery to mailboxes on other
+//	(directly connected) machines.  Messages can be dropped by
+//	the network, but they are never corrupted.
+//
+// 	The US Post Office (and Canada Post! -KMS)
+//      delivers mail to the addressed mailbox.
+// 	By analogy, our post office delivers packets to a specific buffer
+// 	(MailBox), based on the mailbox number stored in the packet header.
+// 	Mail waits in the box until a thread asks for it; if the mailbox
+//      is empty, threads can wait for mail to arrive in it.
+//
+// 	Thus, the service our post office provides is to de-multiplex
+// 	incoming packets, delivering them to the appropriate thread.
+//
+//      With each message, you get a return address, which consists of a "from
+// 	address", which is the id of the machine that sent the message, and
+// 	a "from box", which is the number of a mailbox on the sending machine
+//	to which you can send an acknowledgement, if your protocol requires
+//	this.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef POST_H
+#define POST_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+#include "network.h"
+#include "synchlist.h"
+#include "synch.h"
+
+// Mailbox address -- uniquely identifies a mailbox on a given machine.
+// A mailbox is just a place for temporary storage for messages.
+typedef int MailBoxAddress;
+
+// The following class defines part of the message header.
+// This is prepended to the message by the PostOffice, before the message
+// is sent to the Network.
+
+class MailHeader {
+   public:
+    MailBoxAddress to;    // Destination mail box
+    MailBoxAddress from;  // Mail box to reply to
+    unsigned length;      // Bytes of message data (excluding the
+                          // mail header)
+};
+
+// Maximum "payload" -- real data -- that can included in a single message
+// Excluding the MailHeader and the PacketHeader
+
+#define MaxMailSize (MaxPacketSize - sizeof(MailHeader))
+
+// The following class defines the format of an incoming/outgoing
+// "Mail" message.  The message format is layered:
+//	network header (PacketHeader)
+//	post office header (MailHeader)
+//	data
+
+class Mail {
+   public:
+    Mail(PacketHeader pktH, MailHeader mailH, char *msgData);
+    // Initialize a mail message by
+    // concatenating the headers to the data
+
+    PacketHeader pktHdr;     // Header appended by Network
+    MailHeader mailHdr;      // Header appended by PostOffice
+    char data[MaxMailSize];  // Payload -- message data
+};
+
+// The following class defines a single mailbox, or temporary storage
+// for messages.   Incoming messages are put by the PostOffice into the
+// appropriate mailbox, and these messages can then be retrieved by
+// threads on this machine.
+
+class MailBox {
+   public:
+    MailBox();   // Allocate and initialize mail box
+    ~MailBox();  // De-allocate mail box
+
+    void Put(PacketHeader pktHdr, MailHeader mailHdr, char *data);
+    // Atomically put a message into the mailbox
+    void Get(PacketHeader *pktHdr, MailHeader *mailHdr, char *data);
+    // Atomically get a message out of the
+    // mailbox (and wait if there is no message
+    // to get!)
+   private:
+    SynchList<Mail *>
+        *messages;  // A mailbox is just a list of arrived messages
+};
+
+// The following two classes defines a "Post Office", or a collection of
+// mailboxes.  The Post Office provides two main operations:
+//	Send -- send a message to a mailbox on a remote machine
+//	Receive -- wait until a message is in the mailbox, then remove and
+//		return it.
+//
+// Incoming messages are put by the PostOffice into the
+// appropriate mailbox, waking up any threads waiting on Receive.
+
+class PostOfficeInput : public CallBackObj {
+   public:
+    PostOfficeInput(int nBoxes);  // Allocate and initialize Post Office
+    ~PostOfficeInput();           // De-allocate Post Office data
+
+    void Receive(int box, PacketHeader *pktHdr, MailHeader *mailHdr,
+                 char *data);
+    // Retrieve a message from "box".  Wait if
+    // there is no message in the box.
+
+    static void PostalDelivery(void *data);
+    // Wait for incoming messages,
+    // and then put them in the correct mailbox
+
+    void CallBack();  // Called when incoming packet has arrived
+                      // and can be pulled off of network
+                      // (i.e., time to call PostalDelivery)
+
+   private:
+    NetworkInput *network;        // Physical network connection
+    MailBox *boxes;               // Table of mail boxes to hold incoming mail
+    int numBoxes;                 // Number of mail boxes
+    Semaphore *messageAvailable;  // V'ed when message has arrived from network
+};
+
+class PostOfficeOutput : public CallBackObj {
+   public:
+    PostOfficeOutput(double reliability);
+    // Allocate and initialize output
+    //   "reliability" is how many packets
+    //   get dropped by the underlying network
+    ~PostOfficeOutput();  // De-allocate Post Office data
+
+    void Send(PacketHeader pktHdr, MailHeader mailHdr, char *data);
+    // Send a message to a mailbox on a remote
+    // machine.  The fromBox in the MailHeader is
+    // the return box for ack's.
+
+    void CallBack();  // Called when outgoing packet has been
+                      // put on network; next packet can now be sent
+
+   private:
+    NetworkOutput *network;  // Physical network connection
+    Semaphore *messageSent;  // V'ed when next message can be sent to network
+    Lock *sendLock;          // Only one outgoing message at a time
+};
+#endif
diff --git a/code/test/Makefile b/code/test/Makefile
new file mode 100644
index 0000000..f7b5063
--- /dev/null
+++ b/code/test/Makefile
@@ -0,0 +1,274 @@
+#
+# Makefile for building user programs to run on top of Nachos
+#
+#  Use "make" to build the test executable(s)
+#  Use "make clean" to remove .o files and .coff files
+#  Use "make distclean" to remove all files produced by make, including
+#     the test executables
+#
+# This is a GNU Makefile.  It must be used with the GNU make program.
+# At UW, the GNU make program is /software/gnu/bin/make.
+# In many other places it is known as "gmake".
+# You may wish to include /software/gnu/bin/ early in your command
+# search path, so that you will be using GNU make when you type "make".
+#
+# Several things to be aware of:
+#
+#    It should not be necessary to build the test executables for
+#     every type of host machine on which Nachos runs.  You should
+#     be able to build them once, and then use them regardless of
+#     the host machine type.  That is because the test executables
+#     run on the simulated MIPS machine, and not on the host.
+#
+#    However:
+#	(1) if you are experiencing problems with the test executables,
+#	    it would be prudent to rebuild them on the host machine
+#	    on which you are currently running Nachos.  To do this,
+#    	    just type "make distclean", and then "make"
+#
+#	(2) the procedure used to build the test executables does
+#	    depend on the host machine you are on.  All of the machine
+#	    dependencies are isolated in the Makefile.dep file.
+#	    It should be possible to build the test executables on
+#	    any MFCF machine.   In the MFCF environment, this makefile
+#           should automatically figure out what type of host you are
+#	    on, and should use the appropriate procedure.
+#           However, if you are working outside the MFCF environment,
+#           you will need to build a cross-compiler, build coff2noff,
+#           and edit Makefile.dep in this directory before you
+#           can build the test programs.
+#
+#    Nachos assumes that the location of the program startup routine (the
+# 	location the kernel jumps to when the program initially starts up)
+#       is at location 0.  This means: start.o must be the first .o passed
+# 	to ld, in order for the routine "Start" to be loaded at location 0
+#
+#    When you make the test programs, you will see messages like these:
+#		numsections 3
+#		Loading 3 sections:
+#		        ".text", filepos 0xd0, mempos 0x0, size 0x440
+#		        ".data", filepos 0x510, mempos 0x440, size 0x0
+#		        ".bss", filepos 0x0, mempos 0x440, size 0x12c0
+#    These messages are normal.  They come from the coff2noff program.
+#    They are useful in that they tell you how big the various parts of your
+#     compiled user program are, and where in the address space
+#     coff2noff is going to place them.   This information is also
+#     recorded in the header of the executable file that coff2noff
+#     creates.  See the method AddrSpace::Load (in userprog/addrspace.cc)
+#     for an example of how this header is used by the Nachos OS to set up the
+#     address space for a new process that will run the executable.
+#
+#
+# Adding New Test Programs:
+#
+#     You are free to write new test programs, and to modify the
+#	existing programs.   If you write a new program, you will
+# 	need to modify this makefile so that the new program will
+#       get built.
+#     You will need to make the following changes for each program
+#       you add:
+#		(1) add the program's name to PROGRAMS variable definition
+#	 	(2) add dependencies and build commands for the new
+#			program.  The easiest way to do this is to
+#			copy the dependencies and commands for an
+#			existing program, and then change the names.
+#
+#	For example, if you write a test program in foo.c, for which
+#	the executable is to be called foo, you should do the following:
+#
+#	change the PROGRAMS definition to look like this:
+#
+#		PROGRAMS = halt shell matmult sort foo
+#
+#	add these dependencies/commands:
+#
+#		foo.o: foo.c
+#			$(CC) $(CFLAGS) -c foo.c
+#		foo: foo.o start.o
+#			$(LD) $(LDFLAGS) start.o foo.o -o foo.coff
+#			$(COFF2NOFF) foo.coff foo
+#
+#       Be careful when you copy the commands!  The commands
+# 	must be indented with a *TAB*, not a bunch of spaces.
+#
+#
+#############################################################################
+# Makefile.dep contains all machine-dependent definitions
+# If you are trying to build coff2noff somewhere outside
+# of the MFCF environment, you will almost certainly want
+# to visit and edit Makefile.dep before doing so
+#############################################################################
+
+include Makefile.dep
+
+CC = $(GCCDIR)gcc
+AS = $(GCCDIR)as
+LD = $(GCCDIR)ld
+
+INCDIR =-I../userprog -I../lib
+CFLAGS = -G 0 -c $(INCDIR) -B/home/ssl41/usr/local/nachos/lib/gcc-lib/decstation-ultrix/2.95.2/ -B/home/ssl41/usr/local/nachos/decstation-ultrix/bin/
+
+ifeq ($(hosttype),unknown)
+PROGRAMS = unknownhost
+else
+# change this if you create a new test program!
+PROGRAMS = add abs halt shell matmult sort segments test_syscall num_io char_io random str_io ascii bubblesort help create_file open_file readwrite exec test_sem sinhvien voinuoc main
+endif
+
+all: $(PROGRAMS)
+
+start.o: start.S ../userprog/syscall.h
+	$(CC) $(CFLAGS) $(ASFLAGS) -c start.S
+
+halt.o: halt.c
+	$(CC) $(CFLAGS) -c halt.c
+halt: halt.o start.o
+	$(LD) $(LDFLAGS) start.o halt.o -o halt.coff
+	$(COFF2NOFF) halt.coff halt
+
+add.o: add.c
+	$(CC) $(CFLAGS) -c add.c
+
+add: add.o start.o
+	$(LD) $(LDFLAGS) start.o add.o -o add.coff
+	$(COFF2NOFF) add.coff add
+
+abs.o: abs.c
+	$(CC) $(CFLAGS) -c abs.c
+
+abs: abs.o start.o
+	$(LD) $(LDFLAGS) start.o abs.o -o abs.coff
+	$(COFF2NOFF) abs.coff abs
+
+shell.o: shell.c
+	$(CC) $(CFLAGS) -c shell.c
+shell: shell.o start.o
+	$(LD) $(LDFLAGS) start.o shell.o -o shell.coff
+	$(COFF2NOFF) shell.coff shell
+
+sort.o: sort.c
+	$(CC) $(CFLAGS) -c sort.c
+sort: sort.o start.o
+	$(LD) $(LDFLAGS) start.o sort.o -o sort.coff
+	$(COFF2NOFF) sort.coff sort
+
+segments.o: segments.c
+	$(CC) $(CFLAGS) -c segments.c
+segments: segments.o start.o
+	$(LD) $(LDFLAGS) start.o segments.o -o segments.coff
+	$(COFF2NOFF) segments.coff segments
+
+matmult.o: matmult.c
+	$(CC) $(CFLAGS) -c matmult.c
+matmult: matmult.o start.o
+	$(LD) $(LDFLAGS) start.o matmult.o -o matmult.coff
+	$(COFF2NOFF) matmult.coff matmult
+
+test_syscall.o: test_syscall.c
+	$(CC) $(CFLAGS) -c test_syscall.c
+test_syscall: test_syscall.o start.o
+	$(LD) $(LDFLAGS) start.o test_syscall.o -o test_syscall.coff
+	$(COFF2NOFF) test_syscall.coff test_syscall
+
+num_io.o: num_io.c
+	$(CC) $(CFLAGS) -c num_io.c
+num_io: num_io.o start.o
+	$(LD) $(LDFLAGS) start.o num_io.o -o num_io.coff
+	$(COFF2NOFF) num_io.coff num_io
+
+char_io.o: char_io.c
+	$(CC) $(CFLAGS) -c char_io.c
+char_io: char_io.o start.o
+	$(LD) $(LDFLAGS) start.o char_io.o -o char_io.coff
+	$(COFF2NOFF) char_io.coff char_io
+
+random.o: random.c
+	$(CC) $(CFLAGS) -c random.c
+random: random.o start.o
+	$(LD) $(LDFLAGS) start.o random.o -o random.coff
+	$(COFF2NOFF) random.coff random
+
+str_io.o: str_io.c
+	$(CC) $(CFLAGS) -c str_io.c
+str_io: str_io.o start.o
+	$(LD) $(LDFLAGS) start.o str_io.o -o str_io.coff
+	$(COFF2NOFF) str_io.coff str_io
+
+ascii.o: ascii.c
+	$(CC) $(CFLAGS) -c ascii.c
+ascii: ascii.o start.o
+	$(LD) $(LDFLAGS) start.o ascii.o -o ascii.coff
+	$(COFF2NOFF) ascii.coff ascii
+
+bubblesort.o: bubblesort.c
+	$(CC) $(CFLAGS) -c bubblesort.c
+bubblesort: bubblesort.o start.o
+	$(LD) $(LDFLAGS) start.o bubblesort.o -o bubblesort.coff
+	$(COFF2NOFF) bubblesort.coff bubblesort
+
+help.o: help.c
+	$(CC) $(CFLAGS) -c help.c
+help: help.o start.o
+	$(LD) $(LDFLAGS) start.o help.o -o help.coff
+	$(COFF2NOFF) help.coff help
+
+create_file.o: create_file.c
+	$(CC) $(CFLAGS) -c create_file.c
+create_file: create_file.o start.o
+	$(LD) $(LDFLAGS) start.o create_file.o -o create_file.coff
+	$(COFF2NOFF) create_file.coff create_file
+
+open_file.o: open_file.c
+	$(CC) $(CFLAGS) -c open_file.c
+open_file: open_file.o start.o
+	$(LD) $(LDFLAGS) start.o open_file.o -o open_file.coff
+	$(COFF2NOFF) open_file.coff open_file
+
+readwrite.o: readwrite.c
+	$(CC) $(CFLAGS) -c readwrite.c
+readwrite: readwrite.o start.o
+	$(LD) $(LDFLAGS) start.o readwrite.o -o readwrite.coff
+	$(COFF2NOFF) readwrite.coff readwrite
+
+exec.o: exec.c
+	$(CC) $(CFLAGS) -c exec.c
+exec: exec.o start.o
+	$(LD) $(LDFLAGS) start.o exec.o -o exec.coff
+	$(COFF2NOFF) exec.coff exec
+
+test_sem.o: test_sem.c
+	$(CC) $(CFLAGS) -c test_sem.c
+test_sem: test_sem.o start.o
+	$(LD) $(LDFLAGS) start.o test_sem.o -o test_sem.coff
+	$(COFF2NOFF) test_sem.coff test_sem
+
+sinhvien.o: sinhvien.c
+	$(CC) $(CFLAGS) -c sinhvien.c
+sinhvien: sinhvien.o start.o
+	$(LD) $(LDFLAGS) start.o sinhvien.o -o sinhvien.coff
+	$(COFF2NOFF) sinhvien.coff sinhvien
+
+voinuoc.o: voinuoc.c
+	$(CC) $(CFLAGS) -c voinuoc.c
+voinuoc: voinuoc.o start.o
+	$(LD) $(LDFLAGS) start.o voinuoc.o -o voinuoc.coff
+	$(COFF2NOFF) voinuoc.coff voinuoc
+
+main.o: main.c
+	$(CC) $(CFLAGS) -c main.c
+main: main.o start.o
+	$(LD) $(LDFLAGS) start.o main.o -o main.coff
+	$(COFF2NOFF) main.coff main
+
+clean:
+	$(RM) -f *.o *.ii
+	$(RM) -f *.coff
+
+distclean: clean
+	$(RM) -f $(PROGRAMS)
+
+unknownhost:
+	@echo Host type could not be determined.
+	@echo make is terminating.
+	@echo If you are on an MFCF machine, contact the instructor to report this problem
+	@echo Otherwise, edit Makefile.dep and try again.
diff --git a/code/test/abs.c b/code/test/abs.c
new file mode 100644
index 0000000..24b13fa
--- /dev/null
+++ b/code/test/abs.c
@@ -0,0 +1,10 @@
+#include "syscall.h"
+
+int main() {
+    int x= -10;
+    int y;
+    y= Abs(x);
+    PrintNum(y);
+    /* not reached */
+}
+
diff --git a/code/test/add.c b/code/test/add.c
new file mode 100644
index 0000000..9bb9aa1
--- /dev/null
+++ b/code/test/add.c
@@ -0,0 +1,18 @@
+/* add.c
+ *	Simple program to test whether the systemcall interface works.
+ *
+ *	Just do a add syscall that adds two values and returns the result.
+ *
+ */
+
+#include "syscall.h"
+
+int main() {
+    int result;
+
+    result = Add(40, 23);
+    //PrintNum(result);
+
+    Halt();
+    /* not reached */
+}
diff --git a/code/test/ascii.c b/code/test/ascii.c
new file mode 100644
index 0000000..4bd0664
--- /dev/null
+++ b/code/test/ascii.c
@@ -0,0 +1,11 @@
+#include "syscall.h"
+
+int main() {
+    int i;
+    for (i = 32; i <= 126; i++) {
+        PrintNum(i);
+        PrintChar(' ');
+        PrintChar((char)i);
+        PrintChar('\n');
+    }
+}
diff --git a/code/test/bubblesort.c b/code/test/bubblesort.c
new file mode 100644
index 0000000..0f88fb5
--- /dev/null
+++ b/code/test/bubblesort.c
@@ -0,0 +1,52 @@
+#include "syscall.h"
+#define SIZE (100)
+
+int main() {
+    int n, a[SIZE + 1], order, temp, i, j;
+    do {
+        PrintString("Enter n (0 <= n <= 100): ");
+        n = ReadNum();
+        if (n < 0 || n > 100)
+            PrintString(
+                "n has to be an integer between 1 and 100 (inclusive), please "
+                "try again\n");
+    } while (n < 0 || n > 100);
+
+    for (i = 0; i < n; i++) {
+        PrintString("Enter a[");
+        PrintNum(i);
+        PrintString("]: ");
+        a[i] = ReadNum();
+    }
+
+    do {
+        PrintString("Enter sort order (1: increasing, 2: decreasing): ");
+        order = ReadNum();
+        if (order != 1 && order != 2)
+            PrintString("Wrong input, please try again\n");
+    } while (order != 1 && order != 2);
+
+    for (i = 0; i < n; i++) {
+        for (j = 0; j < n - 1; j++) {
+            if (order == 1) {
+                if (a[j] > a[j + 1]) {
+                    temp = a[j];
+                    a[j] = a[j + 1];
+                    a[j + 1] = temp;
+                }
+            } else if (order == 2) {
+                if (a[j] < a[j + 1]) {
+                    temp = a[j];
+                    a[j] = a[j + 1];
+                    a[j + 1] = temp;
+                }
+            }
+        }
+    }
+
+    PrintString("Sorted array: ");
+    for (i = 0; i < n; i++) {
+        PrintNum(a[i]);
+        PrintChar(' ');
+    }
+}
diff --git a/code/test/char_io.c b/code/test/char_io.c
new file mode 100644
index 0000000..fecaa50
--- /dev/null
+++ b/code/test/char_io.c
@@ -0,0 +1,10 @@
+/* char_io.c
+ *	Simple program to test whether the systemcall interface works.
+ *
+ *	Just do a add syscall that read a character and print it
+ *
+ */
+
+#include "syscall.h"
+
+int main() { PrintChar(ReadChar()); }
diff --git a/code/test/create_file.c b/code/test/create_file.c
new file mode 100644
index 0000000..4537b31
--- /dev/null
+++ b/code/test/create_file.c
@@ -0,0 +1,18 @@
+#include "syscall.h"
+
+int main() {
+    char fileName[256];
+    int length;
+
+    PrintString("Enter file's name's length: ");
+    length = ReadNum();
+    PrintString("Enter file's name: ");
+    ReadString(fileName, length);
+
+    if (CreateFile(fileName) == 0) {
+        PrintString("File ");
+        PrintString(fileName);
+        PrintString(" created successfully!\n");
+    } else
+        PrintString("Create file failed\n");
+}
diff --git a/code/test/exec.c b/code/test/exec.c
new file mode 100644
index 0000000..feadac1
--- /dev/null
+++ b/code/test/exec.c
@@ -0,0 +1,17 @@
+/* exec.c
+ *	Simple program to test the exec system call.
+ */
+
+#include "syscall.h"
+#define stdin 0
+#define stdout 1
+
+int main() {
+    int pid;
+    pid = Exec("num_io");
+    if (pid < 0) {
+        Write("Exec failed: ", 14, stdout);
+        PrintNum(pid);
+    } else
+        Join(pid);
+}
diff --git a/code/test/halt.c b/code/test/halt.c
new file mode 100644
index 0000000..7d1a374
--- /dev/null
+++ b/code/test/halt.c
@@ -0,0 +1,18 @@
+/* halt.c
+ *	Simple program to test whether running a user program works.
+ *
+ *	Just do a "syscall" that shuts down the OS.
+ *
+ * 	NOTE: for some reason, user programs with global data structures
+ *	sometimes haven't worked in the Nachos environment.  So be careful
+ *	out there!  One option is to allocate data structures as
+ * 	automatics within a procedure, but if you do this, you have to
+ *	be careful to allocate a big enough stack to hold the automatics!
+ */
+
+#include "syscall.h"
+
+int main() {
+    Halt();
+    /* not reached */
+}
diff --git a/code/test/help.c b/code/test/help.c
new file mode 100644
index 0000000..ef06497
--- /dev/null
+++ b/code/test/help.c
@@ -0,0 +1,21 @@
+#include "syscall.h"
+
+int main() {
+    PrintString("Our team:\n");
+    PrintString("19120037 Le Duy Thuc\n");
+    PrintString("19120395 Tran Duy Tien\n");
+    PrintString("19120219 Ha Chi Hao\n\n");
+    PrintString(
+        "ASCII: at directory code, run build.linux/nachos -x test/ascii to "
+        "print the ASCII table\n");
+    PrintString(
+        "Sort: at directory code, run build.linux/nachos -x test/bubblesort to "
+        "start the sort program\n");
+    PrintString("\t- Enter n (the length of the array, 0 <= n <= 100)\n");
+    PrintString("\t- Enter n elements of the array\n");
+    PrintString(
+        "\t- Enter the order you want to sort the array with (1: increasing, "
+        "2: decreasing)\n");
+    PrintString(
+        "\t- The program will print out the sorted array and then exit\n");
+}
diff --git a/code/test/input.txt b/code/test/input.txt
new file mode 100644
index 0000000..7ed6ff8
--- /dev/null
+++ b/code/test/input.txt
@@ -0,0 +1 @@
+5
diff --git a/code/test/main.c b/code/test/main.c
new file mode 100644
index 0000000..b91b823
--- /dev/null
+++ b/code/test/main.c
@@ -0,0 +1,102 @@
+#include "syscall.h"
+
+#define MAX_LENGTH 20
+#define MAX_STUDENT 5
+
+int main() {
+    int file_input, file_output;  // file descriptor for input, output
+    int f_shared;                 // file descriptor for shared variable
+    int n;                        // n students
+    char buffer[MAX_LENGTH];      // For reading stuff
+    int students[MAX_STUDENT];    // Array of students
+    int water_machine;            // Water machine
+    int tmp, i;                   // tempurary variable, index variable
+
+    /***********Read the number of students***********/
+    file_input = Open("input.txt", 0);
+    if (file_input == -1) {
+        PrintString("Cannot open file input.txt\n");
+        return 1;
+    }
+    Read(buffer, 1, file_input);
+    n = buffer[0] - '0';
+    Close(file_input);
+
+    if (n > 5) {
+        PrintString("Too many students\n");
+        return 1;
+    }
+
+    PrintString("Number of students: ");
+    PrintNum(n);
+    PrintString("\n");
+    /***********END OF Read the number of students***********/
+
+    /***********Create output file***********/
+    if (CreateFile("output.txt")) {
+        PrintString("Cannot create file output.txt\n");
+        return 1;
+    }
+    /***********END OF Create output file***********/
+
+    /***********Create shared file***********/
+    if (CreateFile("shared.txt")) {
+        PrintString("Cannot create file shared.txt\n");
+        return 1;
+    }
+    /***********END OF shared output file***********/
+
+    /***********Create Semaphore***********/
+    // only 1 student can put his/her cup in the machine at a time
+    tmp = CreateSemaphore("putcup", 1);
+    if (tmp == -1) {
+        PrintString("Create Semaphore for putcup failed\n");
+        return 1;
+    }
+    // for waiting for the water machine to fill the cup
+    tmp = CreateSemaphore("fill", 0);
+    if (tmp == -1) {
+        PrintString("Create Semaphore for fill failed\n");
+        return 1;
+    }
+    // this is for the water machine to wait for the cup
+    tmp = CreateSemaphore("cup", 0);
+    if (tmp == -1) {
+        PrintString("Create Semaphore for cup failed\n");
+        return 1;
+    }
+    /***********END OF Create Semaphore***********/
+
+    /***********Spawn child process**********/
+    for (i = 0; i < n; i++) {
+        students[i] = Exec("sinhvien");
+        if (students[i] == -1) {
+            PrintString("Create student failed\n");
+            return 1;
+        }
+    }
+    water_machine = Exec("voinuoc");
+    if (water_machine == 1) {
+        PrintString("Create water machine failed\n");
+        return 1;
+    }
+    for (i = 0; i < n; i++) {
+        Join(students[i]);
+    }
+    Join(water_machine);
+    /***********END OF Spawn child process**********/
+
+    /***********Remove the last `,` in output file**********/
+    file_output = Open("output.txt", 0);
+    if (file_output == -1) {
+        PrintString("Cannot open file output.txt\n");
+    } else {
+        int tmp = Seek(-1, file_output);
+        Seek(tmp - 2, file_output);
+        Write("  ", 2, file_output);
+        Close(file_output);
+    }
+    /***********End of Remove the last `,` in output file**********/
+    PrintString("\nDone\n");
+    return 0;
+}
diff --git a/code/test/matmult.c b/code/test/matmult.c
new file mode 100644
index 0000000..103db17
--- /dev/null
+++ b/code/test/matmult.c
@@ -0,0 +1,36 @@
+/* matmult.c
+ *    Test program to do matrix multiplication on large arrays.
+ *
+ *    Intended to stress virtual memory system.
+ *
+ *    Ideally, we could read the matrices off of the file system,
+ *	and store the result back to the file system!
+ */
+
+#include "syscall.h"
+
+#define Dim                                      \
+    20 /* sum total of the arrays doesn't fit in \
+        * physical memory                        \
+        */
+
+int A[Dim][Dim];
+int B[Dim][Dim];
+int C[Dim][Dim];
+
+int main() {
+    int i, j, k;
+
+    for (i = 0; i < Dim; i++) /* first initialize the matrices */
+        for (j = 0; j < Dim; j++) {
+            A[i][j] = i;
+            B[i][j] = j;
+            C[i][j] = 0;
+        }
+
+    for (i = 0; i < Dim; i++) /* then multiply them together */
+        for (j = 0; j < Dim; j++)
+            for (k = 0; k < Dim; k++) C[i][j] += A[i][k] * B[k][j];
+
+    Exit(C[Dim - 1][Dim - 1]); /* and then we're done */
+}
diff --git a/code/test/num_io.c b/code/test/num_io.c
new file mode 100644
index 0000000..87d3f5b
--- /dev/null
+++ b/code/test/num_io.c
@@ -0,0 +1,10 @@
+/* num_io.c
+ *	Simple program to test whether the systemcall interface works.
+ *
+ *	Just do a syscall that read an interger and print it
+ *
+ */
+
+#include "syscall.h"
+
+int main() { PrintNum(ReadNum()); }
diff --git a/code/test/open_file.c b/code/test/open_file.c
new file mode 100644
index 0000000..8f860f6
--- /dev/null
+++ b/code/test/open_file.c
@@ -0,0 +1,21 @@
+#include "syscall.h"
+
+int main() {
+    char fileName[] = "abc";
+    int length, id;
+    int i;
+
+    for (i = 0; i < 9; i++) {
+        if ((id = Open(fileName, 0)) != -1) {
+            PrintString("File ");
+            PrintString(fileName);
+            PrintString(" opened successfully!\n");
+            PrintString("Id: ");
+            PrintNum(id);
+            PrintString("\n");
+
+            Close(id);
+        } else
+            PrintString("Open file failed\n");
+    }
+}
diff --git a/code/test/random.c b/code/test/random.c
new file mode 100644
index 0000000..d284275
--- /dev/null
+++ b/code/test/random.c
@@ -0,0 +1,11 @@
+/* random.c
+ *	Test RandomNum()
+ */
+
+#include "syscall.h"
+
+int main() {
+    int result;
+    result = RandomNum();
+    PrintNum(result);
+}
diff --git a/code/test/readwrite.c b/code/test/readwrite.c
new file mode 100644
index 0000000..5612ffd
--- /dev/null
+++ b/code/test/readwrite.c
@@ -0,0 +1,62 @@
+#include "syscall.h"
+
+#define MODE_READWRITE 0
+#define MODE_READ 1
+
+#define stdin 0
+#define stdout 1
+
+int main() {
+    char buffer[100];
+    int i;
+    int write;
+
+    int fileid = Open("abc.txt", MODE_READ);
+    int read = Read(buffer, 50, fileid);
+    int len = 0;
+    while (buffer[len] != '\0') ++len;
+    PrintString("Read ");
+    PrintNum(len);
+    PrintString(" characters: ");
+    PrintString(buffer);
+    PrintString("\n");
+    Close(fileid);
+
+    fileid = Open("abc1.txt", MODE_READWRITE);
+    write = Write(buffer, len, fileid);
+
+    PrintString("Write ");
+    PrintNum(write);
+    PrintString(" characters: ");
+    PrintString(buffer);
+    PrintString("\n");
+    Close(fileid);
+
+    fileid = Open("abc2.txt", MODE_READWRITE);
+    read = Read(buffer, 50, fileid);
+    len = 0;
+    while (buffer[len] != '\0') ++len;
+
+    PrintString("Read ");
+    PrintNum(len);
+    PrintString(" characters: ");
+    PrintString(buffer);
+    PrintString("\n");
+    // Write to the same file
+    write = Write(buffer, len, fileid);
+    PrintString("Write ");
+    PrintNum(write);
+    PrintString(" characters: ");
+    PrintString(buffer);
+    PrintString("\n");
+    Close(fileid);
+
+    PrintString("Type a string (use ctrl+D to end typing):\n");
+    for (i = 0; i < len; ++i) {
+        buffer[i] = 0;
+    }
+    Read(buffer, 50, stdin);
+    len = 0;
+    while (buffer[len] != '\0') ++len;
+    PrintNum(Write(buffer, len, stdout));
+}
diff --git a/code/test/script b/code/test/script
new file mode 100644
index 0000000..54e3215
--- /dev/null
+++ b/code/test/script
@@ -0,0 +1,36 @@
+OUTPUT_FORMAT("ecoff-littlemips")
+ENTRY(__start)
+SECTIONS
+{
+  .text  0 : {
+     _ftext = . ;
+    *(.init)
+     eprol  =  .;
+    *(.text)
+    *(.fini)
+     etext  =  .;
+     _etext  =  .;
+  }
+  .rdata  . : {
+    *(.rdata)
+  }
+   _fdata = .;
+  .data  . : {
+    *(.data)
+    CONSTRUCTORS
+  }
+   edata  =  .;
+   _edata  =  .;
+   _fbss = .;
+  .sbss  . : {
+    *(.sbss)
+    *(.scommon)
+  }
+  .bss  . : {
+    *(.bss)
+    *(COMMON)
+  }
+   end = .;
+   _end = .;
+}
+ 
diff --git a/code/test/segments.c b/code/test/segments.c
new file mode 100644
index 0000000..7c2eec1
--- /dev/null
+++ b/code/test/segments.c
@@ -0,0 +1,40 @@
+
+/* segments.c
+ *	Simple program to illustrate different segments and to show
+ *      how parameters are passed and the syscall is generated.
+ *
+ * objdump below refers to:
+ * /software/gcc_nachos/bin/decstation-ultrix-objdump
+ *
+ * Compile this "gmake segments"
+ * Then use objdump to examine output.
+ *          objdump -d segments.coff  - to disassemble
+ *          objdump -s segments.coff  - to see contents of segments
+ *          objdump -x segments.coff  - to see symbol table information
+ *          nachos -d m -s -x segments
+ */
+
+#define N (5) /* N is replaced by the preprocessor */
+
+unsigned int initdata1 = 0xdeadbeef; /* initialized data put in .data segment */
+int initdata2 = 0xbb;                /* same as above                         */
+const int blah = 0xff;               /* into .rdata segment                   */
+int uninitdata[N];                   /* allocate space in .bss segment        */
+
+main() {
+    /* automatic variable stored on stack or in register */
+    int i;
+    int stack1 = 0xaa;
+    int stack2;
+    const int stack3 = 0xee; /* in reg or on stack not .rdata */
+    char *str = "Hello World .rdata segment\n";
+
+    /* str is stored on the stack or in a register
+     * but text that is initialized is stored in .rdata
+     */
+
+    for (i = 0; i < N; i++) {
+        uninitdata[i] = i;
+    }
+    Halt();
+}
diff --git a/code/test/shell.c b/code/test/shell.c
new file mode 100644
index 0000000..a1d8011
--- /dev/null
+++ b/code/test/shell.c
@@ -0,0 +1,30 @@
+#include "syscall.h"
+
+int main() {
+    SpaceId newProc;
+    OpenFileId input = _ConsoleInput;
+    OpenFileId output = _ConsoleOutput;
+    char prompt[2], ch, buffer[60];
+    int i;
+
+    prompt[0] = '-';
+    prompt[1] = '-';
+
+    while (1) {
+        Write(prompt, 2, output);
+
+        i = 0;
+
+        do {
+            Read(&buffer[i], 1, input);
+
+        } while (buffer[i++] != '\n');
+
+        buffer[--i] = '\0';
+
+        if (i > 0) {
+            newProc = Exec(buffer);
+            Join(newProc);
+        }
+    }
+}
diff --git a/code/test/sinhvien.c b/code/test/sinhvien.c
new file mode 100644
index 0000000..76c4012
--- /dev/null
+++ b/code/test/sinhvien.c
@@ -0,0 +1,30 @@
+#include "syscall.h"
+
+#define CUP_SIZE 10
+
+void main() {
+    int pid = GetPid();
+    int file_descriptor;
+    char buffer;
+    int i = 0;
+
+    for (i = 0; i < CUP_SIZE; ++i) {
+        Wait("putcup");
+
+        // Write to the shared file to notify the water machine
+        file_descriptor = Open("shared.txt", 0);
+        if (file_descriptor == -1) {
+            PrintString("Cannot open file shared.txt\n");
+        } else {
+            buffer = pid + '0';
+            Write(&buffer, 1, file_descriptor);
+            Close(file_descriptor);
+        }
+        // notify the water machine
+        Signal("cup");
+        // wait for the water machine to filling the cup
+        Wait("fill");
+
+        Signal("putcup");
+    }
+}
diff --git a/code/test/sort.c b/code/test/sort.c
new file mode 100644
index 0000000..e1dd29f
--- /dev/null
+++ b/code/test/sort.c
@@ -0,0 +1,66 @@
+/* sort.c
+ *    Test program to sort a large number of integers.
+ *
+ *    Intention is to stress virtual memory system.
+ *
+ *    Ideally, we could read the unsorted array off of the file system,
+ *	and store the result back to the file system!
+ */
+
+/*
+#define UNIX
+#define UNIX_DEBUG
+*/
+
+#ifdef UNIX
+#include <stdio.h>
+#define Exit exit
+#else
+#include "syscall.h"
+#endif /* UNIX */
+
+#define SIZE (1024)
+
+int A[SIZE]; /* size of physical memory; with code, we'll run out of space!*/
+
+int main() {
+    int i, j, tmp;
+
+    /* first initialize the array, in reverse sorted order */
+    for (i = 0; i < SIZE; i++) {
+        A[i] = (SIZE - 1) - i;
+    }
+
+    /* then sort! */
+    for (i = 0; i < SIZE; i++) {
+        for (j = 0; j < (SIZE - 1); j++) {
+            if (A[j] > A[j + 1]) { /* out of order -> need to swap ! */
+                tmp = A[j];
+                A[j] = A[j + 1];
+                A[j + 1] = tmp;
+            }
+        }
+    }
+
+#ifdef UNIX_DEBUG
+    for (i = 0; i < SIZE; i++) {
+        printf("%4d ", A[i]);
+        if (((i + 1) % 15) == 0) {
+            printf("\n");
+        }
+        if (A[i] != i) {
+            fprintf(stderr, "Out of order A[%d] = %d\n", i, A[i]);
+            Exit(1);
+        }
+    }
+    printf("\n");
+#endif /* UNIX_DEBUG */
+
+    for (i = 0; i < SIZE; i++) {
+        if (A[i] != i) {
+            Exit(1);
+        }
+    }
+
+    Exit(0);
+}
diff --git a/code/test/str_io.c b/code/test/str_io.c
new file mode 100644
index 0000000..0c8f002
--- /dev/null
+++ b/code/test/str_io.c
@@ -0,0 +1,14 @@
+/* str_io.c
+ *	Simple program to test whether the systemcall interface works.
+ *
+ *	Just do a syscall that read a string and print it
+ *
+ */
+
+#include "syscall.h"
+char a[256];
+int main() {
+    PrintString("String length: (<= 255):\n");
+    ReadString(a, ReadNum());
+    PrintString(a);
+}
diff --git a/code/test/test_sem.c b/code/test/test_sem.c
new file mode 100644
index 0000000..2facb40
--- /dev/null
+++ b/code/test/test_sem.c
@@ -0,0 +1,16 @@
+/* test_semaphore.c
+ * Simple program to test whether the CreateSemaphore, Wait, Signal system call
+ * works.
+ */
+
+#include "syscall.h"
+int main() {
+    int f_success = CreateSemaphore("testSem", 1);
+    if (f_success == -1) {
+        PrintString("CreateSemaphore failed\n");
+        return 1;
+    }
+    Wait("testSem");
+    Signal("testSem");
+    PrintString("testSemaphore passed\n");
+}
diff --git a/code/test/test_syscall.c b/code/test/test_syscall.c
new file mode 100644
index 0000000..0a11bb1
--- /dev/null
+++ b/code/test/test_syscall.c
@@ -0,0 +1,12 @@
+/* test_syscall.c
+ *	Simple program to test whether the systemcall interface works.
+ */
+
+#include "syscall.h"
+
+int main() {
+    int result = Add(1, 2);
+    /* Don't need to Halt() anymore because the PC will increase automatically
+     */
+    result = Add(2, 3);
+}
diff --git a/code/test/voinuoc.c b/code/test/voinuoc.c
new file mode 100644
index 0000000..defec39
--- /dev/null
+++ b/code/test/voinuoc.c
@@ -0,0 +1,63 @@
+#include "syscall.h"
+
+#define CUP_SIZE 10
+
+void main() {
+    int studentId;  // student id
+    int fillTime;   // number of time that the machine need to fill the cup
+    int file_descriptor, file_input;  // file descriptor for shared file, file
+                                      // descriptor for input file
+    char buffer[4] = " , ";           // for write and reading stuff
+    int j = 0;
+    int tmp;
+
+    /***********Read the number of students***********/
+    file_input = Open("input.txt", 0);
+    if (file_input == -1) {
+        PrintString("Cannot open file input.txt\n");
+        return 1;
+    }
+    Read(buffer, 1, file_input);
+    fillTime = (buffer[0] - '0') * CUP_SIZE;
+    Close(file_input);
+    /***********END OF Read the number of students***********/
+
+    while (fillTime > 0) {
+        --fillTime;
+        // wait until there is a student want to drink
+        Wait("cup");
+
+        // Read the student number from shared file
+        file_descriptor = Open("shared.txt", 1);
+        if (file_descriptor == -1) {
+            PrintString("Cannot open file shared.txt\n");
+            return;
+        } else {
+            Read(buffer, 1, file_descriptor);
+            Close(file_descriptor);
+            studentId = buffer[0] - '0';
+        }
+
+        // Loop to simulate the filling warter process
+        PrintString("Filling water for student ");
+        PrintNum(studentId);
+        PrintString("\n");
+
+        for (j = RandomNum() % 10000; j >= 0; --j) {
+            ;
+        }
+
+        file_descriptor = Open("output.txt", 0);
+        if (file_descriptor == -1) {
+            PrintString("Cannot open file output.txt\n");
+        } else {
+            tmp = Seek(-1, file_descriptor);
+            buffer[0] = studentId + '0';
+            buffer[1] = ',';
+            Write(buffer, 3, file_descriptor);
+            Close(file_descriptor);
+        }
+
+        Signal("fill");
+    }
+}
diff --git a/code/threads/alarm.cc b/code/threads/alarm.cc
new file mode 100644
index 0000000..ce30385
--- /dev/null
+++ b/code/threads/alarm.cc
@@ -0,0 +1,50 @@
+// alarm.cc
+//	Routines to use a hardware timer device to provide a
+//	software alarm clock.  For now, we just provide time-slicing.
+//
+//	Not completely implemented.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "alarm.h"
+#include "main.h"
+
+//----------------------------------------------------------------------
+// Alarm::Alarm
+//      Initialize a software alarm clock.  Start up a timer device
+//
+//      "doRandom" -- if true, arrange for the hardware interrupts to
+//		occur at random, instead of fixed, intervals.
+//----------------------------------------------------------------------
+
+Alarm::Alarm(bool doRandom) { timer = new Timer(doRandom, this); }
+
+//----------------------------------------------------------------------
+// Alarm::CallBack
+//	Software interrupt handler for the timer device. The timer device is
+//	set up to interrupt the CPU periodically (once every TimerTicks).
+//	This routine is called each time there is a timer interrupt,
+//	with interrupts disabled.
+//
+//	Note that instead of calling Yield() directly (which would
+//	suspend the interrupt handler, not the interrupted thread
+//	which is what we wanted to context switch), we set a flag
+//	so that once the interrupt handler is done, it will appear as
+//	if the interrupted thread called Yield at the point it is
+//	was interrupted.
+//
+//	For now, just provide time-slicing.  Only need to time slice
+//      if we're currently running something (in other words, not idle).
+//----------------------------------------------------------------------
+
+void Alarm::CallBack() {
+    Interrupt *interrupt = kernel->interrupt;
+    MachineStatus status = interrupt->getStatus();
+
+    if (status != IdleMode) {
+        interrupt->YieldOnReturn();
+    }
+}
diff --git a/code/threads/alarm.h b/code/threads/alarm.h
new file mode 100644
index 0000000..af6dd02
--- /dev/null
+++ b/code/threads/alarm.h
@@ -0,0 +1,42 @@
+// alarm.h
+//	Data structures for a software alarm clock.
+//
+//	We make use of a hardware timer device, that generates
+//	an interrupt every X time ticks (on real systems, X is
+//	usually between 0.25 - 10 milliseconds).
+//
+//	From this, we provide the ability for a thread to be
+//	woken up after a delay; we also provide time-slicing.
+//
+//	NOTE: this abstraction is not completely implemented.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef ALARM_H
+#define ALARM_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+#include "timer.h"
+
+// The following class defines a software alarm clock.
+class Alarm : public CallBackObj {
+   public:
+    Alarm(bool doRandomYield);  // Initialize the timer, and callback
+                                // to "toCall" every time slice.
+    ~Alarm() { delete timer; }
+
+    void WaitUntil(int x);  // suspend execution until time > now + x
+                            // this method is not yet implemented
+
+   private:
+    Timer *timer;  // the hardware timer device
+
+    void CallBack();  // called when the hardware
+                      // timer generates an interrupt
+};
+
+#endif  // ALARM_H
diff --git a/code/threads/kernel.cc b/code/threads/kernel.cc
new file mode 100644
index 0000000..7136b45
--- /dev/null
+++ b/code/threads/kernel.cc
@@ -0,0 +1,244 @@
+// kernel.cc
+//	Initialization and cleanup routines for the Nachos kernel.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "debug.h"
+#include "main.h"
+#include "kernel.h"
+#include "sysdep.h"
+#include "synch.h"
+#include "synchlist.h"
+#include "libtest.h"
+#include "string.h"
+#include "synchconsole.h"
+#include "synchdisk.h"
+#include "post.h"
+
+#define MAX_PROCESS 10
+//----------------------------------------------------------------------
+// Kernel::Kernel
+// 	Interpret command line arguments in order to determine flags
+//	for the initialization (see also comments in main.cc)
+//----------------------------------------------------------------------
+
+Kernel::Kernel(int argc, char **argv) {
+    randomSlice = FALSE;
+    debugUserProg = FALSE;
+    consoleIn = NULL;   // default is stdin
+    consoleOut = NULL;  // default is stdout
+#ifndef FILESYS_STUB
+    formatFlag = FALSE;
+#endif
+    reliability = 1;  // network reliability, default is 1.0
+    hostName = 0;     // machine id, also UNIX socket name
+                      // 0 is the default machine id
+    for (int i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-rs") == 0) {
+            ASSERT(i + 1 < argc);
+            RandomInit(atoi(argv[i + 1]));  // initialize pseudo-random
+                                            // number generator
+            randomSlice = TRUE;
+            i++;
+        } else if (strcmp(argv[i], "-s") == 0) {
+            debugUserProg = TRUE;
+        } else if (strcmp(argv[i], "-ci") == 0) {
+            ASSERT(i + 1 < argc);
+            consoleIn = argv[i + 1];
+            i++;
+        } else if (strcmp(argv[i], "-co") == 0) {
+            ASSERT(i + 1 < argc);
+            consoleOut = argv[i + 1];
+            i++;
+#ifndef FILESYS_STUB
+        } else if (strcmp(argv[i], "-f") == 0) {
+            formatFlag = TRUE;
+#endif
+        } else if (strcmp(argv[i], "-n") == 0) {
+            ASSERT(i + 1 < argc);  // next argument is float
+            reliability = atof(argv[i + 1]);
+            i++;
+        } else if (strcmp(argv[i], "-m") == 0) {
+            ASSERT(i + 1 < argc);  // next argument is int
+            hostName = atoi(argv[i + 1]);
+            i++;
+        } else if (strcmp(argv[i], "-u") == 0) {
+            cout << "Partial usage: nachos [-rs randomSeed]\n";
+            cout << "Partial usage: nachos [-s]\n";
+            cout << "Partial usage: nachos [-ci consoleIn] [-co consoleOut]\n";
+#ifndef FILESYS_STUB
+            cout << "Partial usage: nachos [-nf]\n";
+#endif
+            cout << "Partial usage: nachos [-n #] [-m #]\n";
+        }
+    }
+}
+
+//----------------------------------------------------------------------
+// Kernel::Initialize
+// 	Initialize Nachos global data structures.  Separate from the
+//	constructor because some of these refer to earlier initialized
+//	data via the "kernel" global variable.
+//----------------------------------------------------------------------
+
+void Kernel::Initialize(char *userProgName /*=NULL*/) {
+    // We didn't explicitly allocate the current thread we are running in.
+    // But if it ever tries to give up the CPU, we better have a Thread
+    // object to save its state.
+    currentThread = new Thread(userProgName);
+    currentThread->setStatus(RUNNING);
+
+    stats = new Statistics();        // collect statistics
+    interrupt = new Interrupt;       // start up interrupt handling
+    scheduler = new Scheduler();     // initialize the ready queue
+    alarm = new Alarm(randomSlice);  // start up time slicing
+    machine = new Machine(debugUserProg);
+    synchConsoleIn = new SynchConsoleInput(consoleIn);     // input from stdin
+    synchConsoleOut = new SynchConsoleOutput(consoleOut);  // output to stdout
+    synchDisk = new SynchDisk();                           //
+#ifdef FILESYS_STUB
+    fileSystem = new FileSystem();
+#else
+    fileSystem = new FileSystem(formatFlag);
+#endif  // FILESYS_STUB
+    postOfficeIn = new PostOfficeInput(10);
+    postOfficeOut = new PostOfficeOutput(reliability);
+
+    addrLock = new Semaphore("addrLock", 1);
+    gPhysPageBitMap = new Bitmap(128);
+    semTab = new STable();
+    pTab = new PTable(MAX_PROCESS);
+
+    interrupt->Enable();
+}
+
+//----------------------------------------------------------------------
+// Kernel::~Kernel
+// 	Nachos is halting.  De-allocate global data structures.
+//----------------------------------------------------------------------
+
+Kernel::~Kernel() {
+    delete stats;
+    delete interrupt;
+    delete scheduler;
+    delete alarm;
+    delete machine;
+    delete synchConsoleIn;
+    delete synchConsoleOut;
+    delete synchDisk;
+    delete fileSystem;
+    delete postOfficeIn;
+    delete postOfficeOut;
+    delete pTab;
+    delete gPhysPageBitMap;
+    delete semTab;
+    delete addrLock;
+
+    Exit(0);
+}
+
+//----------------------------------------------------------------------
+// Kernel::ThreadSelfTest
+//      Test threads, semaphores, synchlists
+//----------------------------------------------------------------------
+
+void Kernel::ThreadSelfTest() {
+    Semaphore *semaphore;
+    SynchList<int> *synchList;
+
+    LibSelfTest();  // test library routines
+
+    currentThread->SelfTest();  // test thread switching
+
+    // test semaphore operation
+    semaphore = new Semaphore("test", 0);
+    semaphore->SelfTest();
+    delete semaphore;
+
+    // test locks, condition variables
+    // using synchronized lists
+    synchList = new SynchList<int>;
+    synchList->SelfTest(9);
+    delete synchList;
+}
+
+//----------------------------------------------------------------------
+// Kernel::ConsoleTest
+//      Test the synchconsole
+//----------------------------------------------------------------------
+
+void Kernel::ConsoleTest() {
+    char ch;
+
+    cout << "Testing the console device.\n"
+         << "Typed characters will be echoed, until ^D is typed.\n"
+         << "Note newlines are needed to flush input through UNIX.\n";
+    cout.flush();
+
+    do {
+        ch = synchConsoleIn->GetChar();
+        if (ch != EOF) synchConsoleOut->PutChar(ch);  // echo it!
+    } while (ch != EOF);
+
+    cout << "\n";
+}
+
+//----------------------------------------------------------------------
+// Kernel::NetworkTest
+//      Test whether the post office is working. On machines #0 and #1, do:
+//
+//      1. send a message to the other machine at mail box #0
+//      2. wait for the other machine's message to arrive (in our mailbox #0)
+//      3. send an acknowledgment for the other machine's message
+//      4. wait for an acknowledgement from the other machine to our
+//          original message
+//
+//  This test works best if each Nachos machine has its own window
+//----------------------------------------------------------------------
+
+void Kernel::NetworkTest() {
+    if (hostName == 0 || hostName == 1) {
+        // if we're machine 1, send to 0 and vice versa
+        int farHost = (hostName == 0 ? 1 : 0);
+        PacketHeader outPktHdr, inPktHdr;
+        MailHeader outMailHdr, inMailHdr;
+        char *data = "Hello there!";
+        char *ack = "Got it!";
+        char buffer[MaxMailSize];
+
+        // construct packet, mail header for original message
+        // To: destination machine, mailbox 0
+        // From: our machine, reply to: mailbox 1
+        outPktHdr.to = farHost;
+        outMailHdr.to = 0;
+        outMailHdr.from = 1;
+        outMailHdr.length = strlen(data) + 1;
+
+        // Send the first message
+        postOfficeOut->Send(outPktHdr, outMailHdr, data);
+
+        // Wait for the first message from the other machine
+        postOfficeIn->Receive(0, &inPktHdr, &inMailHdr, buffer);
+        cout << "Got: " << buffer << " : from " << inPktHdr.from << ", box "
+             << inMailHdr.from << "\n";
+        cout.flush();
+
+        // Send acknowledgement to the other machine (using "reply to" mailbox
+        // in the message that just arrived
+        outPktHdr.to = inPktHdr.from;
+        outMailHdr.to = inMailHdr.from;
+        outMailHdr.length = strlen(ack) + 1;
+        postOfficeOut->Send(outPktHdr, outMailHdr, ack);
+
+        // Wait for the ack from the other machine to the first message we sent
+        postOfficeIn->Receive(1, &inPktHdr, &inMailHdr, buffer);
+        cout << "Got: " << buffer << " : from " << inPktHdr.from << ", box "
+             << inMailHdr.from << "\n";
+        cout.flush();
+    }
+
+    // Then we're done!
+}
diff --git a/code/threads/kernel.h b/code/threads/kernel.h
new file mode 100644
index 0000000..7e5e030
--- /dev/null
+++ b/code/threads/kernel.h
@@ -0,0 +1,83 @@
+// kernel.h
+//	Global variables for the Nachos kernel.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef KERNEL_H
+#define KERNEL_H
+
+#include "copyright.h"
+#include "debug.h"
+#include "utility.h"
+#include "thread.h"
+#include "scheduler.h"
+#include "interrupt.h"
+#include "stats.h"
+#include "alarm.h"
+#include "filesys.h"
+#include "machine.h"
+
+class PostOfficeInput;
+class PostOfficeOutput;
+class SynchConsoleInput;
+class SynchConsoleOutput;
+class SynchDisk;
+class Semaphore;
+#include "bitmap.h"
+#include "stable.h"
+#include "ptable.h"
+
+class Kernel {
+   public:
+    Kernel(int argc, char **argv);
+    // Interpret command line arguments
+    ~Kernel();  // deallocate the kernel
+
+    void Initialize(
+        char *userProgName = NULL);  // initialize the kernel -- separated
+                                     // from constructor because
+                                     // refers to "kernel" as a global
+
+    void ThreadSelfTest();  // self test of threads and synchronization
+
+    void ConsoleTest();  // interactive console self test
+
+    void NetworkTest();  // interactive 2-machine network test
+
+    // These are public for notational convenience; really,
+    // they're global variables used everywhere.
+
+    Thread *currentThread;  // the thread holding the CPU
+    Scheduler *scheduler;   // the ready list
+    Interrupt *interrupt;   // interrupt status
+    Statistics *stats;      // performance metrics
+    Alarm *alarm;           // the software alarm clock
+    Machine *machine;       // the simulated CPU
+    SynchConsoleInput *synchConsoleIn;
+    SynchConsoleOutput *synchConsoleOut;
+    SynchDisk *synchDisk;
+    FileSystem *fileSystem;
+    PostOfficeInput *postOfficeIn;
+    PostOfficeOutput *postOfficeOut;
+
+    Semaphore *addrLock;
+    Bitmap *gPhysPageBitMap;
+    STable *semTab;
+    PTable *pTab;
+
+    int hostName;  // machine identifier
+
+   private:
+    bool randomSlice;    // enable pseudo-random time slicing
+    bool debugUserProg;  // single step user program
+    double reliability;  // likelihood messages are dropped
+    char *consoleIn;     // file to read console input from
+    char *consoleOut;    // file to send console output to
+#ifndef FILESYS_STUB
+    bool formatFlag;  // format the disk if this is true
+#endif
+};
+
+#endif  // KERNEL_H
diff --git a/code/threads/main.cc b/code/threads/main.cc
new file mode 100644
index 0000000..cab8ce4
--- /dev/null
+++ b/code/threads/main.cc
@@ -0,0 +1,281 @@
+// main.cc
+//	Driver code to initialize, selftest, and run the
+//	operating system kernel.
+//
+// Usage: nachos -d <debugflags> -rs <random seed #>
+//              -s -x <nachos file> -ci <consoleIn> -co <consoleOut>
+//              -f -cp <unix file> <nachos file>
+//              -p <nachos file> -r <nachos file> -l -D
+//              -n <network reliability> -m <machine id>
+//              -z -K -C -N
+//
+//    -d causes certain debugging messages to be printed (see debug.h)
+//    -rs causes Yield to occur at random (but repeatable) spots
+//    -z prints the copyright message
+//    -s causes user programs to be executed in single-step mode
+//    -x runs a user program
+//    -ci specify file for console input (stdin is the default)
+//    -co specify file for console output (stdout is the default)
+//    -n sets the network reliability
+//    -m sets this machine's host id (needed for the network)
+//    -K run a simple self test of kernel threads and synchronization
+//    -C run an interactive console test
+//    -N run a two-machine network test (see Kernel::NetworkTest)
+//
+//    Filesystem-related flags:
+//    -f forces the Nachos disk to be formatted
+//    -cp copies a file from UNIX to Nachos
+//    -p prints a Nachos file to stdout
+//    -r removes a Nachos file from the file system
+//    -l lists the contents of the Nachos directory
+//    -D prints the contents of the entire file system
+//
+//  Note: the file system flags are not used if the stub filesystem
+//        is being used
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#define MAIN
+#include "copyright.h"
+#undef MAIN
+
+#include "main.h"
+#include "filesys.h"
+#include "openfile.h"
+#include "sysdep.h"
+
+// global variables
+Kernel *kernel;
+Debug *debug;
+
+//----------------------------------------------------------------------
+// Cleanup
+//	Delete kernel data structures; called when user hits "ctl-C".
+//----------------------------------------------------------------------
+
+static void Cleanup(int x) {
+    cerr << "\nCleaning up after signal " << x << "\n";
+    delete kernel;
+}
+
+//-------------------------------------------------------------------
+// Constant used by "Copy" and "Print"
+//   It is the number of bytes read from the Unix file (for Copy)
+//   or the Nachos file (for Print) by each read operation
+//-------------------------------------------------------------------
+static const int TransferSize = 128;
+
+#ifndef FILESYS_STUB
+//----------------------------------------------------------------------
+// Copy
+//      Copy the contents of the UNIX file "from" to the Nachos file "to"
+//----------------------------------------------------------------------
+
+static void Copy(char *from, char *to) {
+    int fd;
+    OpenFile *openFile;
+    int amountRead, fileLength;
+    char *buffer;
+
+    // Open UNIX file
+    if ((fd = OpenForReadWrite(from, FALSE)) < 0) {
+        printf("Copy: couldn't open input file %s\n", from);
+        return;
+    }
+
+    // Figure out length of UNIX file
+    Lseek(fd, 0, 2);
+    fileLength = Tell(fd);
+    Lseek(fd, 0, 0);
+
+    // Create a Nachos file of the same length
+    DEBUG('f', "Copying file " << from << " of size " << fileLength
+                               << " to file " << to);
+    if (!kernel->fileSystem->Create(to, fileLength)) {  // Create Nachos file
+        printf("Copy: couldn't create output file %s\n", to);
+        Close(fd);
+        return;
+    }
+
+    openFile = kernel->fileSystem->Open(to);
+    ASSERT(openFile != NULL);
+
+    // Copy the data in TransferSize chunks
+    buffer = new char[TransferSize];
+    while ((amountRead = ReadPartial(fd, buffer, sizeof(char) * TransferSize)) >
+           0)
+        openFile->Write(buffer, amountRead);
+    delete[] buffer;
+
+    // Close the UNIX and the Nachos files
+    delete openFile;
+    Close(fd);
+}
+
+#endif  // FILESYS_STUB
+
+//----------------------------------------------------------------------
+// Print
+//      Print the contents of the Nachos file "name".
+//----------------------------------------------------------------------
+
+void Print(char *name) {
+    OpenFile *openFile;
+    int i, amountRead;
+    char *buffer;
+
+    if ((openFile = kernel->fileSystem->Open(name)) == NULL) {
+        printf("Print: unable to open file %s\n", name);
+        return;
+    }
+
+    buffer = new char[TransferSize];
+    while ((amountRead = openFile->Read(buffer, TransferSize)) > 0)
+        for (i = 0; i < amountRead; i++) printf("%c", buffer[i]);
+    delete[] buffer;
+
+    delete openFile;  // close the Nachos file
+    return;
+}
+
+//----------------------------------------------------------------------
+// main
+// 	Bootstrap the operating system kernel.
+//
+//	Initialize kernel data structures
+//	Call some test routines
+//	Call "Run" to start an initial user program running
+//
+//	"argc" is the number of command line arguments (including the name
+//		of the command) -- ex: "nachos -d +" -> argc = 3
+//	"argv" is an array of strings, one for each command line argument
+//		ex: "nachos -d +" -> argv = {"nachos", "-d", "+"}
+//----------------------------------------------------------------------
+
+int main(int argc, char **argv) {
+    int i;
+    char *debugArg = "";
+    char *userProgName = NULL;  // default is not to execute a user prog
+    bool threadTestFlag = false;
+    bool consoleTestFlag = false;
+    bool networkTestFlag = false;
+#ifndef FILESYS_STUB
+    char *copyUnixFileName = NULL;    // UNIX file to be copied into Nachos
+    char *copyNachosFileName = NULL;  // name of copied file in Nachos
+    char *printFileName = NULL;
+    char *removeFileName = NULL;
+    bool dirListFlag = false;
+    bool dumpFlag = false;
+#endif  // FILESYS_STUB
+
+    // some command line arguments are handled here.
+    // those that set kernel parameters are handled in
+    // the Kernel constructor
+    for (i = 1; i < argc; i++) {
+        if (strcmp(argv[i], "-d") == 0) {
+            ASSERT(i + 1 < argc);  // next argument is debug string
+            debugArg = argv[i + 1];
+            i++;
+        } else if (strcmp(argv[i], "-z") == 0) {
+            cout << copyright << "\n";
+        } else if (strcmp(argv[i], "-x") == 0) {
+            ASSERT(i + 1 < argc);
+            userProgName = argv[i + 1];
+            i++;
+        } else if (strcmp(argv[i], "-K") == 0) {
+            threadTestFlag = TRUE;
+        } else if (strcmp(argv[i], "-C") == 0) {
+            consoleTestFlag = TRUE;
+        } else if (strcmp(argv[i], "-N") == 0) {
+            networkTestFlag = TRUE;
+        }
+#ifndef FILESYS_STUB
+        else if (strcmp(argv[i], "-cp") == 0) {
+            ASSERT(i + 2 < argc);
+            copyUnixFileName = argv[i + 1];
+            copyNachosFileName = argv[i + 2];
+            i += 2;
+        } else if (strcmp(argv[i], "-p") == 0) {
+            ASSERT(i + 1 < argc);
+            printFileName = argv[i + 1];
+            i++;
+        } else if (strcmp(argv[i], "-r") == 0) {
+            ASSERT(i + 1 < argc);
+            removeFileName = argv[i + 1];
+            i++;
+        } else if (strcmp(argv[i], "-l") == 0) {
+            dirListFlag = true;
+        } else if (strcmp(argv[i], "-D") == 0) {
+            dumpFlag = true;
+        }
+#endif  // FILESYS_STUB
+        else if (strcmp(argv[i], "-u") == 0) {
+            cout << "Partial usage: nachos [-z -d debugFlags]\n";
+            cout << "Partial usage: nachos [-x programName]\n";
+            cout << "Partial usage: nachos [-K] [-C] [-N]\n";
+#ifndef FILESYS_STUB
+            cout << "Partial usage: nachos [-cp UnixFile NachosFile]\n";
+            cout << "Partial usage: nachos [-p fileName] [-r fileName]\n";
+            cout << "Partial usage: nachos [-l] [-D]\n";
+#endif  // FILESYS_STUB
+        }
+    }
+    debug = new Debug(debugArg);
+
+    DEBUG(dbgThread, "Entering main");
+
+    kernel = new Kernel(argc, argv);
+
+    kernel->Initialize(userProgName);
+
+    CallOnUserAbort(Cleanup);  // if user hits ctl-C
+
+    // at this point, the kernel is ready to do something
+    // run some tests, if requested
+    if (threadTestFlag) {
+        kernel->ThreadSelfTest();  // test threads and synchronization
+    }
+    if (consoleTestFlag) {
+        kernel->ConsoleTest();  // interactive test of the synchronized console
+    }
+    if (networkTestFlag) {
+        kernel->NetworkTest();  // two-machine test of the network
+    }
+
+#ifndef FILESYS_STUB
+    if (removeFileName != NULL) {
+        kernel->fileSystem->Remove(removeFileName);
+    }
+    if (copyUnixFileName != NULL && copyNachosFileName != NULL) {
+        Copy(copyUnixFileName, copyNachosFileName);
+    }
+    if (dumpFlag) {
+        kernel->fileSystem->Print();
+    }
+    if (dirListFlag) {
+        kernel->fileSystem->List();
+    }
+    if (printFileName != NULL) {
+        Print(printFileName);
+    }
+#endif  // FILESYS_STUB
+
+    // finally, run an initial user program if requested to do so
+    if (userProgName != NULL) {
+        AddrSpace *space =
+            new AddrSpace(userProgName);  // load the program into the space
+        ASSERT(space != (AddrSpace *)NULL);
+        space->Execute();    // run the program
+        ASSERTNOTREACHED();  // Execute never returns
+    }
+
+    // If we don't run a user program, we may get here.
+    // Calling "return" would terminate the program.
+    // Instead, call Halt, which will first clean up, then
+    //  terminate.
+    kernel->interrupt->Halt();
+
+    ASSERTNOTREACHED();
+}
diff --git a/code/threads/main.h b/code/threads/main.h
new file mode 100644
index 0000000..82ff125
--- /dev/null
+++ b/code/threads/main.h
@@ -0,0 +1,18 @@
+// main.h
+//	This file defines the Nachos global variables
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef MAIN_H
+#define MAIN_H
+
+#include "copyright.h"
+#include "debug.h"
+#include "kernel.h"
+
+extern Kernel *kernel;
+extern Debug *debug;
+
+#endif  // MAIN_H
diff --git a/code/threads/pcb.cc b/code/threads/pcb.cc
new file mode 100644
index 0000000..a740854
--- /dev/null
+++ b/code/threads/pcb.cc
@@ -0,0 +1,126 @@
+#include "synch.h"
+#include "pcb.h"
+
+PCB::PCB(int id) {
+    this->processID = kernel->currentThread->processID;
+    joinsem = new Semaphore("joinsem", 0);
+    exitsem = new Semaphore("exitsem", 0);
+    multex = new Semaphore("multex", 1);
+}
+
+PCB::~PCB() {
+    delete joinsem;
+    delete exitsem;
+    delete multex;
+
+    if (thread) {
+        thread->FreeSpace();
+        thread->Finish();
+        // delete thread;
+    }
+
+    delete[] filename;
+}
+
+void StartProcess_2(void* pid) {
+    int id;
+    id = *((int*)pid);
+    // Lay fileName cua process id nay
+    char* fileName = kernel->pTab->GetFileName(id);
+
+    AddrSpace* space;
+    space = new AddrSpace(fileName);
+
+    if (space == NULL) {
+        printf("\nPCB::Exec: Can't create AddSpace.");
+        return;
+    }
+
+    space->Execute();
+    // kernel->currentThread->space = space;
+
+    // space->InitRegisters();	// set the initial register values
+    // space->RestoreState();	// load page table register
+
+    // kernel->machine->Run();	// jump to the user progam
+    ASSERT(FALSE);  // machine->Run never returns;
+                    // the address space exits
+                    // by doing the syscall "exit"
+}
+
+int PCB::Exec(char* filename, int id) {
+    // cerr << filename << ' ' << pid << endl;
+    multex->P();
+
+    this->thread = new Thread(filename, true);
+    if (this->thread == NULL) {
+        printf("\nPCB::Exec: Not enough memory!\n");
+        multex->V();  // Nha CPU de nhuong CPU cho tien trinh khac
+        return -1;    // Tra ve -1 neu that bai
+    }
+
+    //  t processID ca thread ny l id.
+    this->thread->processID = id;
+    // t parrentID ca thread ny l processID ca thread gi thc thi Exec
+    this->parentID = kernel->currentThread->processID;
+    // Gi thc thi Fork(StartProcess_2,id) => Ta cast thread thnh kiu int,
+    // sau  khi x k hm StartProcess ta cast Thread v ng kiu ca n.
+
+    // Khng c s dng bin id  y, v bin id l bin cc b,
+    // nn khi hm ny kt thc th gi tr ca bin ny cng b xa
+    // ng hi ti  mt bao lu  nhn ra iu ny :)
+    this->thread->Fork(StartProcess_2, &this->thread->processID);
+
+    multex->V();
+    // Tr v id.
+    return id;
+}
+
+int PCB::GetID() { return thread->processID; }
+
+int PCB::GetNumWait() { return numwait; }
+
+void PCB::JoinWait() {
+    // Gi joinsem->P()  tin trnh chuyn sang trng thi block v ngng li,
+    // ch JoinRelease  thc hin tip.
+    joinsem->P();
+}
+
+void PCB::ExitWait() {
+    // Gi exitsem-->V()  tin trnh chuyn sang trng thi block v ngng
+    // li, ch ExitRelease thc hin tip.
+    exitsem->P();
+}
+
+void PCB::JoinRelease() {
+    // Gi joinsem->V()  gii phng tin trnh gi JoinWait().
+    joinsem->V();
+}
+
+void PCB::ExitRelease() {
+    // Gi exitsem->V()  gii phng tin trnh ang ch.
+    exitsem->V();
+}
+
+void PCB::IncNumWait() {
+    multex->P();
+    ++numwait;
+    multex->V();
+}
+
+void PCB::DecNumWait() {
+    multex->P();
+    if (numwait > 0) --numwait;
+    multex->V();
+}
+
+void PCB::SetExitCode(int ec) { exitcode = ec; }
+
+int PCB::GetExitCode() { return exitcode; }
+
+void PCB::SetFileName(char* fn) { strcpy(filename, fn); }
+
+char* PCB::GetFileName() {
+    // cerr << "get file name" << ' ' << filename << endl;
+    return filename;
+}
diff --git a/code/threads/pcb.h b/code/threads/pcb.h
new file mode 100644
index 0000000..dcab368
--- /dev/null
+++ b/code/threads/pcb.h
@@ -0,0 +1,42 @@
+#ifndef PCB_H
+#define PCB_H
+
+class PCB {
+   private:
+    Semaphore *joinsem;
+    Semaphore *exitsem;
+    Semaphore *multex;
+
+    int exitcode;
+    int numwait;
+
+    Thread *thread;
+    char filename[128];
+
+   public:
+    int parentID;
+    int processID;
+    PCB();
+    PCB(int id);
+    ~PCB();
+
+    int Exec(char *filename, int pid);
+    int GetID();
+    int GetNumWait();
+
+    void JoinWait();
+    void ExitWait();
+    void JoinRelease();
+    void ExitRelease();
+
+    void IncNumWait();
+    void DecNumWait();
+
+    void SetExitCode(int ec);
+    int GetExitCode();
+
+    void SetFileName(char *fn);
+    char *GetFileName();
+};
+
+#endif
diff --git a/code/threads/ptable.cc b/code/threads/ptable.cc
new file mode 100644
index 0000000..89f8486
--- /dev/null
+++ b/code/threads/ptable.cc
@@ -0,0 +1,138 @@
+#include "synch.h"
+#include "ptable.h"
+
+PTable::PTable(int size) {
+    int i;
+    psize = size;
+    for (i = 0; i < size; i++) {
+        pcb[i] = NULL;
+    }
+    bmsem = new Semaphore("bmsem", 1);
+    pcb[0] = new PCB(0);
+    pcb[0]->parentID = -1;
+}
+
+PTable::~PTable() {
+    int i;
+    for (i = 0; i < psize; i++) {
+        if (!pcb[i]) delete pcb[i];
+    }
+    delete bmsem;
+}
+
+int PTable::ExecUpdate(char* name) {
+    // Gi mutex->P();  gip trnh tnh trng np 2 tin trnh cng 1 lc.
+    bmsem->P();
+
+    // Kim tra tnh hp l ca chng trnh name.
+    // Kim tra s tn ti ca chng trnh name bng cch gi phng thc
+    // Open ca lp fileSystem.
+    if (name == NULL) {
+        DEBUG(dbgSys, "\nPTable::Exec : Can't not execute name is NULL.\n");
+        bmsem->V();
+        return -1;
+    }
+    // So snh tn chng trnh v tn ca currentThread  chc chn rng
+    // chng trnh ny khng gi thc thi chnh n.
+    if (strcmp(name, kernel->currentThread->getName()) == 0) {
+        DEBUG(dbgSys, "\nPTable::Exec : Can't not execute itself.\n");
+        bmsem->V();
+        return -1;
+    }
+
+    // Tm slot trng trong bng Ptable.
+    int index = this->GetFreeSlot();
+
+    // Check if have free slot
+    if (index < 0) {
+        DEBUG(dbgSys, "\nPTable::Exec :There is no free slot.\n");
+        bmsem->V();
+        return -1;
+    }
+
+    // Nu c slot trng th khi to mt PCB mi vi processID chnh l index
+    // ca slot ny
+    pcb[index] = new PCB(index);
+    pcb[index]->SetFileName(name);
+    kernel->fileSystem->Renew(index);
+
+    // parrentID l processID ca currentThread
+    pcb[index]->parentID = kernel->currentThread->processID;
+
+    // Gi thc thi phng thc Exec ca lp PCB.
+    int pid = pcb[index]->Exec(name, index);
+
+    // Gi bmsem->V()
+    bmsem->V();
+    // Tr v kt qu thc thi ca PCB->Exec.
+    return pid;
+}
+
+int PTable::ExitUpdate(int exitcode) {
+    // Nu tin trnh gi l main process th gi Halt().
+    int id = kernel->currentThread->processID;
+    if (id == 0) {
+        kernel->currentThread->FreeSpace();
+        kernel->interrupt->Halt();
+        return 0;
+    }
+
+    if (!IsExist(id)) {
+        DEBUG(dbgSys, "Process " << id << " is not exist.");
+        return -1;
+    }
+
+    // Ngc li gi SetExitCode  t exitcode cho tin trnh gi.
+    pcb[id]->SetExitCode(exitcode);
+    pcb[pcb[id]->parentID]->DecNumWait();
+
+    // Gi JoinRelease  gii phng tin trnh cha ang i n (nu c)
+    // v ExitWait()  xin tin trnh cha cho php thot.
+    pcb[id]->JoinRelease();
+    pcb[id]->ExitWait();
+
+    Remove(id);
+    return exitcode;
+}
+
+int PTable::JoinUpdate(int id) {
+    // Ta kim tra tnh hp l ca processID id v kim tra tin trnh gi Join
+    // c phi l cha ca tin trnh c processID l id hay khng. Nu khng
+    // tha, ta bo li hp l v tr v -1.
+    if (id < 0 || id >= psize || pcb[id] == NULL ||
+        pcb[id]->parentID != kernel->currentThread->processID) {
+        DEBUG(dbgSys, "\nPTable::Join : Can't not join.\n");
+        return -1;
+    }
+
+    // Tng numwait v gi JoinWait()  ch tin trnh con thc hin.
+    pcb[pcb[id]->parentID]->IncNumWait();
+    pcb[id]->JoinWait();
+
+    // Sau khi tin trnh con thc hin xong, tin trnh  c gii phng
+
+    // X l exitcode.
+    int exit_code = pcb[id]->GetExitCode();
+    // ExitRelease()  cho php tin trnh con thot.
+    pcb[id]->ExitRelease();
+    return exit_code;
+}
+
+int PTable::GetFreeSlot() {
+    int i;
+    for (i = 0; i < psize; i++) {
+        if (!pcb[i]) return i;
+    }
+    return -1;
+}
+
+bool PTable::IsExist(int pid) { return pcb[pid] != NULL; }
+
+void PTable::Remove(int pid) {
+    if (pcb[pid] != NULL) {
+        delete pcb[pid];
+        pcb[pid] = NULL;
+    }
+}
+
+char* PTable::GetFileName(int id) { return pcb[id]->GetFileName(); }
diff --git a/code/threads/ptable.h b/code/threads/ptable.h
new file mode 100644
index 0000000..23b2f46
--- /dev/null
+++ b/code/threads/ptable.h
@@ -0,0 +1,28 @@
+#ifndef PTABLE_H
+#define PTABLE_H
+
+#include "bitmap.h"
+#include "pcb.h"
+
+#define MAX_PROCESS 10
+
+class PTable {
+   private:
+    Bitmap* bm;
+    PCB* pcb[MAX_PROCESS];
+    int psize;
+    Semaphore* bmsem;
+
+   public:
+    PTable(int size);
+    ~PTable();
+    int ExecUpdate(char* name);
+    int ExitUpdate(int ec);
+    int JoinUpdate(int id);
+    int GetFreeSlot();
+    bool IsExist(int pid);
+    void Remove(int pid);
+    char* GetFileName(int id);
+};
+
+#endif
\ No newline at end of file
diff --git a/code/threads/scheduler.cc b/code/threads/scheduler.cc
new file mode 100644
index 0000000..1d52916
--- /dev/null
+++ b/code/threads/scheduler.cc
@@ -0,0 +1,166 @@
+// scheduler.cc
+//	Routines to choose the next thread to run, and to dispatch to
+//	that thread.
+//
+// 	These routines assume that interrupts are already disabled.
+//	If interrupts are disabled, we can assume mutual exclusion
+//	(since we are on a uniprocessor).
+//
+// 	NOTE: We can't use Locks to provide mutual exclusion here, since
+// 	if we needed to wait for a lock, and the lock was busy, we would
+//	end up calling FindNextToRun(), and that would put us in an
+//	infinite loop.
+//
+// 	Very simple implementation -- no priorities, straight FIFO.
+//	Might need to be improved in later assignments.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "debug.h"
+#include "scheduler.h"
+#include "main.h"
+
+//----------------------------------------------------------------------
+// Scheduler::Scheduler
+// 	Initialize the list of ready but not running threads.
+//	Initially, no ready threads.
+//----------------------------------------------------------------------
+
+Scheduler::Scheduler() {
+    readyList = new List<Thread *>;
+    toBeDestroyed = NULL;
+}
+
+//----------------------------------------------------------------------
+// Scheduler::~Scheduler
+// 	De-allocate the list of ready threads.
+//----------------------------------------------------------------------
+
+Scheduler::~Scheduler() { delete readyList; }
+
+//----------------------------------------------------------------------
+// Scheduler::ReadyToRun
+// 	Mark a thread as ready, but not running.
+//	Put it on the ready list, for later scheduling onto the CPU.
+//
+//	"thread" is the thread to be put on the ready list.
+//----------------------------------------------------------------------
+
+void Scheduler::ReadyToRun(Thread *thread) {
+    ASSERT(kernel->interrupt->getLevel() == IntOff);
+    DEBUG(dbgThread, "Putting thread on ready list: " << thread->getName());
+
+    thread->setStatus(READY);
+    readyList->Append(thread);
+}
+
+//----------------------------------------------------------------------
+// Scheduler::FindNextToRun
+// 	Return the next thread to be scheduled onto the CPU.
+//	If there are no ready threads, return NULL.
+// Side effect:
+//	Thread is removed from the ready list.
+//----------------------------------------------------------------------
+
+Thread *Scheduler::FindNextToRun() {
+    ASSERT(kernel->interrupt->getLevel() == IntOff);
+
+    if (readyList->IsEmpty()) {
+        return NULL;
+    } else {
+        return readyList->RemoveFront();
+    }
+}
+
+//----------------------------------------------------------------------
+// Scheduler::Run
+// 	Dispatch the CPU to nextThread.  Save the state of the old thread,
+//	and load the state of the new thread, by calling the machine
+//	dependent context switch routine, SWITCH.
+//
+//      Note: we assume the state of the previously running thread has
+//	already been changed from running to blocked or ready (depending).
+// Side effect:
+//	The global variable kernel->currentThread becomes nextThread.
+//
+//	"nextThread" is the thread to be put into the CPU.
+//	"finishing" is set if the current thread is to be deleted
+//		once we're no longer running on its stack
+//		(when the next thread starts running)
+//----------------------------------------------------------------------
+
+void Scheduler::Run(Thread *nextThread, bool finishing) {
+    Thread *oldThread = kernel->currentThread;
+
+    ASSERT(kernel->interrupt->getLevel() == IntOff);
+
+    if (finishing) {  // mark that we need to delete current thread
+        ASSERT(toBeDestroyed == NULL);
+        toBeDestroyed = oldThread;
+    }
+
+    if (oldThread->space != NULL) {  // if this thread is a user program,
+        oldThread->SaveUserState();  // save the user's CPU registers
+        oldThread->space->SaveState();
+    }
+
+    oldThread->CheckOverflow();  // check if the old thread
+                                 // had an undetected stack overflow
+
+    kernel->currentThread = nextThread;  // switch to the next thread
+    nextThread->setStatus(RUNNING);      // nextThread is now running
+
+    DEBUG(dbgThread, "Switching from: " << oldThread->getName()
+                                        << " to: " << nextThread->getName());
+
+    // This is a machine-dependent assembly language routine defined
+    // in switch.s.  You may have to think
+    // a bit to figure out what happens after this, both from the point
+    // of view of the thread and from the perspective of the "outside world".
+
+    SWITCH(oldThread, nextThread);
+
+    // we're back, running oldThread
+
+    // interrupts are off when we return from switch!
+    ASSERT(kernel->interrupt->getLevel() == IntOff);
+
+    DEBUG(dbgThread, "Now in thread: " << oldThread->getName());
+
+    CheckToBeDestroyed();  // check if thread we were running
+                           // before this one has finished
+                           // and needs to be cleaned up
+
+    if (oldThread->space != NULL) {     // if there is an address space
+        oldThread->RestoreUserState();  // to restore, do it.
+        oldThread->space->RestoreState();
+    }
+}
+
+//----------------------------------------------------------------------
+// Scheduler::CheckToBeDestroyed
+// 	If the old thread gave up the processor because it was finishing,
+// 	we need to delete its carcass.  Note we cannot delete the thread
+// 	before now (for example, in Thread::Finish()), because up to this
+// 	point, we were still running on the old thread's stack!
+//----------------------------------------------------------------------
+
+void Scheduler::CheckToBeDestroyed() {
+    if (toBeDestroyed != NULL) {
+        delete toBeDestroyed;
+        toBeDestroyed = NULL;
+    }
+}
+
+//----------------------------------------------------------------------
+// Scheduler::Print
+// 	Print the scheduler state -- in other words, the contents of
+//	the ready list.  For debugging.
+//----------------------------------------------------------------------
+void Scheduler::Print() {
+    cout << "Ready list contents:\n";
+    readyList->Apply(ThreadPrint);
+}
diff --git a/code/threads/scheduler.h b/code/threads/scheduler.h
new file mode 100644
index 0000000..a96f228
--- /dev/null
+++ b/code/threads/scheduler.h
@@ -0,0 +1,44 @@
+// scheduler.h
+//	Data structures for the thread dispatcher and scheduler.
+//	Primarily, the list of threads that are ready to run.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef SCHEDULER_H
+#define SCHEDULER_H
+
+#include "copyright.h"
+#include "list.h"
+#include "thread.h"
+
+// The following class defines the scheduler/dispatcher abstraction --
+// the data structures and operations needed to keep track of which
+// thread is running, and which threads are ready but not running.
+
+class Scheduler {
+   public:
+    Scheduler();   // Initialize list of ready threads
+    ~Scheduler();  // De-allocate ready list
+
+    void ReadyToRun(Thread* thread);
+    // Thread can be dispatched.
+    Thread* FindNextToRun();  // Dequeue first thread on the ready
+                              // list, if any, and return thread.
+    void Run(Thread* nextThread, bool finishing);
+    // Cause nextThread to start running
+    void CheckToBeDestroyed();  // Check if thread that had been
+                                // running needs to be deleted
+    void Print();               // Print contents of ready list
+
+    // SelfTest for scheduler is implemented in class Thread
+
+   private:
+    List<Thread*>* readyList;  // queue of threads that are ready to run,
+                               // but not running
+    Thread* toBeDestroyed;     // finishing thread to be destroyed
+                               // by the next thread that runs
+};
+
+#endif  // SCHEDULER_H
diff --git a/code/threads/sem.cc b/code/threads/sem.cc
new file mode 100644
index 0000000..3ad254c
--- /dev/null
+++ b/code/threads/sem.cc
@@ -0,0 +1,17 @@
+#include "sem.h"
+#include "synch.h"
+
+Sem::Sem(char* na, int i) {
+    strcpy(this->name, na);
+    sem = new Semaphore(this->name, i);
+}
+
+Sem::~Sem() {
+    if (sem) delete sem;
+}
+
+void Sem::wait() { sem->P(); }  // Down(sem)
+
+void Sem::signal() { sem->V(); }  // Up(sem)
+
+char* Sem::GetName() { return this->name; }
diff --git a/code/threads/sem.h b/code/threads/sem.h
new file mode 100644
index 0000000..dc67bc3
--- /dev/null
+++ b/code/threads/sem.h
@@ -0,0 +1,22 @@
+#ifndef SEM_H
+#define SEM_H
+
+class Semaphore;
+
+class Sem {
+   private:
+    Semaphore* sem;
+    char name[50];
+
+   public:
+    Sem(char* na, int i);
+    ~Sem();
+
+    void wait();
+
+    void signal();
+
+    char* GetName();
+};
+
+#endif
\ No newline at end of file
diff --git a/code/threads/stable.cc b/code/threads/stable.cc
new file mode 100644
index 0000000..4c01ce1
--- /dev/null
+++ b/code/threads/stable.cc
@@ -0,0 +1,81 @@
+#include "synch.h"
+#include "stable.h"
+
+STable::STable() {
+    this->bm = new Bitmap(MAX_SEMAPHORE);
+
+    for (int i = 0; i < MAX_SEMAPHORE; i++) {
+        this->semTab[i] = NULL;
+    }
+}
+
+STable::~STable() {
+    if (this->bm) {
+        delete this->bm;
+        this->bm = NULL;
+    }
+    for (int i = 0; i < MAX_SEMAPHORE; i++) {
+        if (this->semTab[i]) {
+            delete this->semTab[i];
+            this->semTab[i] = NULL;
+        }
+    }
+}
+
+int STable::Create(char* name,
+                   int init) {  // Check da ton tai semaphore nay chua?
+    for (int i = 0; i < MAX_SEMAPHORE; i++) {
+        if (bm->Test(i)) {
+            if (strcmp(name, semTab[i]->GetName()) == 0) {
+                return -1;
+            }
+        }
+    }
+    // Tim slot tren bang semTab trong
+    int id = this->FindFreeSlot();
+
+    // Neu k tim thay thi tra ve -1
+    if (id < 0) {
+        return -1;
+    }
+
+    // Neu tim thay slot trong thi nap Semaphore vao semTab[id]
+    this->semTab[id] = new Sem(name, init);
+    return 0;
+}
+
+int STable::Wait(char* name) {
+    for (int i = 0; i < MAX_SEMAPHORE; i++) {
+        // Kiem tra o thu i da duoc nap semaphore chua
+        if (bm->Test(i)) {
+            // Neu co thi tien hanh so sanh name voi name cua semaphore trong
+            // semTab
+            if (strcmp(name, semTab[i]->GetName()) == 0) {
+                // Neu ton tai thi cho semaphore down();
+                semTab[i]->wait();
+                return 0;
+            }
+        }
+    }
+    printf("Khong ton tai semaphore");
+    return -1;
+}
+
+int STable::Signal(char* name) {
+    for (int i = 0; i < MAX_SEMAPHORE; i++) {
+        // Kiem tra o thu i da duoc nap semaphore chua
+        if (bm->Test(i)) {
+            // Neu co thi tien hanh so sanh name voi name cua semaphore trong
+            // semTab
+            if (strcmp(name, semTab[i]->GetName()) == 0) {
+                // Neu ton tai thi cho semaphore up();
+                semTab[i]->signal();
+                return 0;
+            }
+        }
+    }
+    printf("Khong ton tai semaphore");
+    return -1;
+}
+
+int STable::FindFreeSlot() { return this->bm->FindAndSet(); }
diff --git a/code/threads/stable.h b/code/threads/stable.h
new file mode 100644
index 0000000..8afe62f
--- /dev/null
+++ b/code/threads/stable.h
@@ -0,0 +1,22 @@
+#ifndef STABLE_H
+#define STABLE_H
+
+#include "bitmap.h"
+#include "sem.h"
+#define MAX_SEMAPHORE 10
+
+class STable {
+   private:
+    Bitmap* bm;
+    Sem* semTab[MAX_SEMAPHORE];
+
+   public:
+    STable();
+    ~STable();
+    int Create(char* name, int init);
+    int Wait(char* name);
+    int Signal(char* name);
+    int FindFreeSlot();
+};
+
+#endif
\ No newline at end of file
diff --git a/code/threads/switch.S b/code/threads/switch.S
new file mode 100644
index 0000000..770609a
--- /dev/null
+++ b/code/threads/switch.S
@@ -0,0 +1,750 @@
+/* switch.s 
+ *   	Machine dependent context switch routines.  DO NOT MODIFY THESE! 
+ *
+ *	Context switching is inherently machine dependent, since
+ *	the registers to be saved, how to set up an initial
+ *	call frame, etc, are all specific to a processor architecture.
+ *
+ * 	This file currently supports the following architectures:
+ *	    DEC MIPS  (DECMIPS)
+ *	    DEC Alpha  (ALPHA)
+ *	    SUN SPARC (SPARC)
+ *	    HP PA-RISC (PARISC)
+ *	    Intel 386 (x86)
+ *	    IBM RS6000 (PowerPC) -- I hope it will also work for Mac PowerPC
+ *
+ * We define two routines for each architecture:
+ *
+ * ThreadRoot(InitialPC, InitialArg, WhenDonePC, StartupPC)
+ *	InitialPC  - The program counter of the procedure to run
+ *			in this thread.
+ *      InitialArg - The single argument to the thread.
+ *	WhenDonePC - The routine to call when the thread returns.
+ *	StartupPC  - Routine to call when the thread is started.
+ *
+ *	ThreadRoot is called from the SWITCH() routine to start
+ *	a thread for the first time. 
+ *
+ * SWITCH(oldThread, newThread)
+ * 	oldThread  - The current thread that was running, where the
+ *		CPU register state is to be saved.
+ * 	newThread  - The new thread to be run, where the CPU register
+ *		state is to be loaded from.
+ */
+
+/*
+ Copyright (c) 1992-1996 The Regents of the University of California.
+ All rights reserved.  See copyright.h for copyright notice and limitation 
+ of liability and disclaimer of warranty provisions.
+ */
+
+#include "copyright.h"
+#include "switch.h"
+
+
+#ifdef DECMIPS
+
+/* Symbolic register names */
+#define z       $0      /* zero register */
+#define a0      $4      /* argument registers */
+#define a1      $5
+#define s0      $16     /* callee saved */
+#define s1      $17
+#define s2      $18
+#define s3      $19
+#define s4      $20
+#define s5      $21
+#define s6      $22
+#define s7      $23
+#define sp      $29     /* stack pointer */
+#define fp      $30     /* frame pointer */
+#define ra      $31     /* return address */
+
+        .text   
+        .align  2
+
+	.globl ThreadRoot
+	.ent	ThreadRoot,0
+ThreadRoot:
+	or	fp,z,z		# Clearing the frame pointer here
+				# makes gdb backtraces of thread stacks 
+				# end here (I hope!)
+
+	jal	StartupPC	# call startup procedure
+	move	a0, InitialArg
+	jal	InitialPC	# call main procedure
+	jal 	WhenDonePC	# when done, call clean up procedure
+
+	# NEVER REACHED
+	.end ThreadRoot
+
+	# a0 -- pointer to old Thread
+	# a1 -- pointer to new Thread
+	.globl SWITCH
+	.ent	SWITCH,0
+SWITCH:
+	sw	sp, SP(a0)		# save new stack pointer
+	sw	s0, S0(a0)		# save all the callee-save registers
+	sw	s1, S1(a0)
+	sw	s2, S2(a0)
+	sw	s3, S3(a0)
+	sw	s4, S4(a0)
+	sw	s5, S5(a0)
+	sw	s6, S6(a0)
+	sw	s7, S7(a0)
+	sw	fp, FP(a0)		# save frame pointer
+	sw	ra, PC(a0)		# save return address
+	
+	lw	sp, SP(a1)		# load the new stack pointer
+	lw	s0, S0(a1)		# load the callee-save registers
+	lw	s1, S1(a1)
+	lw	s2, S2(a1)
+	lw	s3, S3(a1)
+	lw	s4, S4(a1)
+	lw	s5, S5(a1)
+	lw	s6, S6(a1)
+	lw	s7, S7(a1)
+	lw	fp, FP(a1)
+	lw	ra, PC(a1)		# load the return address	
+
+	j	ra
+	.end SWITCH
+
+#endif // DECMIPS
+
+
+
+#ifdef SPARC
+
+/* NOTE!  These files appear not to exist on Solaris --
+ *  you need to find where (the SPARC-specific) MINFRAME, ST_FLUSH_WINDOWS, ...
+ *  are defined.  (I don't have a Solaris machine, so I have no way to tell.)
+ */
+#ifdef SOLARIS
+#include <sys/trap.h>
+#include <sys/asm_linkage.h>
+#else
+#include <sun4/trap.h>
+#include <sun4/asm_linkage.h>
+#endif
+.seg    "text"
+
+/* SPECIAL to the SPARC:
+ *	The first two instruction of ThreadRoot are skipped because
+ *	the address of ThreadRoot is made the return address of SWITCH()
+ *	by the routine Thread::StackAllocate.  SWITCH() jumps here on the
+ *	"ret" instruction which is really at "jmp %o7+8".  The 8 skips the
+ *	two nops at the beginning of the routine.
+ */
+
+#ifdef SOLARIS
+.globl	ThreadRoot
+ThreadRoot:
+#else
+.globl	_ThreadRoot
+_ThreadRoot:
+#endif
+	nop  ; nop         /* These 2 nops are skipped because we are called
+			    * with a jmp+8 instruction. */
+	clr	%fp        /* Clearing the frame pointer makes gdb backtraces 
+	                    * of thread stacks end here. */
+			   /* Currently the arguments are in out registers we
+			    * save them into local registers so they won't be 
+			    * trashed during the calls we make. */
+	mov	InitialPC, %l0  
+	mov	InitialArg, %l1
+	mov	WhenDonePC, %l2
+			   /* Execute the code:
+			   *	call StartupPC();
+			   *	call InitialPC(InitialArg);
+			   *	call WhenDonePC();
+			   */
+	call	StartupPC,0
+	nop
+	call	%l0, 1	
+	mov	%l1, %o0   /* Using delay slot to setup argument to InitialPC */
+	call	%l2, 0
+	nop
+			   /* WhenDonePC call should never return.  If it does
+			    * we execute a trap into the debugger.  */
+	ta	ST_BREAKPOINT
+
+
+#ifdef SOLARIS
+.globl	SWITCH
+SWITCH:
+#else
+.globl	_SWITCH
+_SWITCH:
+#endif
+	save	%sp, -SA(MINFRAME), %sp
+	st	%fp, [%i0]
+	st	%i0, [%i0+I0]
+	st	%i1, [%i0+I1]
+	st	%i2, [%i0+I2]
+	st	%i3, [%i0+I3]
+	st	%i4, [%i0+I4]
+	st	%i5, [%i0+I5]
+	st	%i7, [%i0+I7]
+	ta	ST_FLUSH_WINDOWS
+	nop
+	mov	%i1, %l0
+	ld	[%l0+I0], %i0
+	ld	[%l0+I1], %i1
+	ld	[%l0+I2], %i2
+	ld	[%l0+I3], %i3
+	ld	[%l0+I4], %i4
+	ld	[%l0+I5], %i5
+	ld	[%l0+I7], %i7
+	ld	[%l0], %i6
+	ret
+	restore
+
+#endif // SPARC
+
+
+
+#ifdef PARISC
+
+    ;rp = r2,   sp = r30
+    ;arg0 = r26,  arg1 = r25,  arg2 = r24,  arg3 = r23
+
+	.SPACE  $TEXT$
+	.SUBSPA $CODE$
+ThreadRoot
+	.PROC
+	.CALLINFO CALLER,FRAME=0
+	.ENTER
+
+	    .CALL
+	    ble  0(%r6)             ;call StartupPC
+	    stw  %r31, -24(%sp)     ;put return address in proper stack
+				    ;location for StartupPC export stub.
+
+	    or   %r4, 0, %arg0      ;load InitialArg
+	    .CALL   ;in=26
+	    ble  0(%r3)             ;call InitialPC
+	    stw  %r31, -24(%sp)     ;put return address in proper stack
+				    ;location for InitialPC export stub.
+
+	    .CALL
+	    ble  0(%r5)             ;call WhenDonePC
+	    stw  %r31, -24(%sp)     ;put return address in proper stack
+				    ;location for StartupPC export stub.
+	    .LEAVE
+
+	.PROCEND
+
+
+SWITCH
+	.PROC
+	.CALLINFO CALLER,FRAME=0
+	.ENTRY
+
+    ; save process state of oldThread
+	stw  %sp, SP(%arg0)	;save stack pointer
+	stw  %r3, S0(%arg0)	;save callee-save registers
+	stw  %r4, S1(%arg0)
+	stw  %r5, S2(%arg0)
+	stw  %r6, S3(%arg0)
+	stw  %r7, S4(%arg0)
+	stw  %r8, S5(%arg0)
+	stw  %r9, S6(%arg0)
+	stw  %r10, S7(%arg0)
+	stw  %r11, S8(%arg0)
+	stw  %r12, S9(%arg0)
+	stw  %r13, S10(%arg0)
+	stw  %r14, S11(%arg0)
+	stw  %r15, S12(%arg0)
+	stw  %r16, S13(%arg0)
+	stw  %r17, S14(%arg0)
+	stw  %r18, S15(%arg0)
+	stw  %rp, PC(%arg0)	;save program counter
+
+    ; restore process state of nextThread
+	ldw  SP(%arg1), %sp	;restore stack pointer
+	ldw  S0(%arg1), %r3	;restore callee-save registers
+	ldw  S1(%arg1), %r4
+	ldw  S2(%arg1), %r5
+	ldw  S3(%arg1), %r6
+	ldw  S4(%arg1), %r7
+	ldw  S5(%arg1), %r8
+	ldw  S6(%arg1), %r9
+	ldw  S7(%arg1), %r10
+	ldw  S8(%arg1), %r11
+	ldw  S9(%arg1), %r12
+	ldw  S10(%arg1), %r13
+	ldw  S11(%arg1), %r14
+	ldw  S12(%arg1), %r15
+	ldw  S13(%arg1), %r16
+	ldw  S14(%arg1), %r17
+	ldw  PC(%arg1), %rp	;save program counter
+	bv   0(%rp)
+	.EXIT
+	ldw  S15(%arg1), %r18
+
+	.PROCEND
+
+	.EXPORT SWITCH,ENTRY,PRIV_LEV=3,RTNVAL=GR
+	.EXPORT ThreadRoot,ENTRY,PRIV_LEV=3,RTNVAL=GR
+
+#endif // PARISC
+
+
+
+#ifdef x86
+
+        .text
+        .align  2
+
+        .globl  ThreadRoot
+        .globl  _ThreadRoot	
+
+/* void ThreadRoot( void )
+**
+** expects the following registers to be initialized:
+**      eax     points to startup function (interrupt enable)
+**      edx     contains inital argument to thread function
+**      esi     points to thread function
+**      edi     point to Thread::Finish()
+*/
+_ThreadRoot:	
+ThreadRoot:
+        pushl   %ebp
+        movl    %esp,%ebp
+        pushl   InitialArg
+        call    *StartupPC
+        call    *InitialPC
+        call    *WhenDonePC
+
+        # NOT REACHED
+        movl    %ebp,%esp
+        popl    %ebp
+        ret
+
+
+
+/* void SWITCH( thread *t1, thread *t2 )
+**
+** on entry, stack looks like this:
+**      8(esp)  ->              thread *t2
+**      4(esp)  ->              thread *t1
+**       (esp)  ->              return address
+**
+** we push the current eax on the stack so that we can use it as
+** a pointer to t1, this decrements esp by 4, so when we use it
+** to reference stuff on the stack, we add 4 to the offset.
+*/
+        .comm   _eax_save,4
+
+        .globl  SWITCH
+	.globl  _SWITCH
+_SWITCH:		
+SWITCH:
+        movl    %eax,_eax_save          # save the value of eax
+        movl    4(%esp),%eax            # move pointer to t1 into eax
+        movl    %ebx,_EBX(%eax)         # save registers
+        movl    %ecx,_ECX(%eax)
+        movl    %edx,_EDX(%eax)
+        movl    %esi,_ESI(%eax)
+        movl    %edi,_EDI(%eax)
+        movl    %ebp,_EBP(%eax)
+        movl    %esp,_ESP(%eax)         # save stack pointer
+        movl    _eax_save,%ebx          # get the saved value of eax
+        movl    %ebx,_EAX(%eax)         # store it
+        movl    0(%esp),%ebx            # get return address from stack into ebx
+        movl    %ebx,_PC(%eax)          # save it into the pc storage
+
+        movl    8(%esp),%eax            # move pointer to t2 into eax
+
+        movl    _EAX(%eax),%ebx         # get new value for eax into ebx
+        movl    %ebx,_eax_save          # save it
+        movl    _EBX(%eax),%ebx         # retore old registers
+        movl    _ECX(%eax),%ecx
+        movl    _EDX(%eax),%edx
+        movl    _ESI(%eax),%esi
+        movl    _EDI(%eax),%edi
+        movl    _EBP(%eax),%ebp
+        movl    _ESP(%eax),%esp         # restore stack pointer
+        movl    _PC(%eax),%eax          # restore return address into eax
+        movl    %eax,4(%esp)            # copy over the ret address on the stack
+        movl    _eax_save,%eax
+
+        ret
+
+#endif // x86
+
+
+#if defined(ApplePowerPC)
+
+	/* The AIX PowerPC code is incompatible with the assembler on MacOS X
+	 * and Linux.  So the SWITCH code was adapted for IBM 750 compatible
+	 * processors, and ThreadRoot is modeled after the more reasonable
+	 * looking ThreadRoot's in this file.
+	 *
+	 * Joshua LeVasseur <jtl@ira.uka.de>
+	 */
+
+	.align	2
+	.globl	_SWITCH
+_SWITCH:
+	stw	r1, 0(r3)	/* Store stack pointer. */
+	stmw	r13, 20(r3)	/* Store general purpose registers 13 - 31. */
+	stfd	f14, 96(r3)	/* Store floating point registers 14 -31. */
+	stfd	f15,  104(r3)
+	stfd	f16,  112(r3)
+	stfd	f17,  120(r3) 
+	stfd	f18,  128(r3) 
+	stfd	f19,  136(r3) 
+	stfd	f20,  144(r3) 
+	stfd	f21,  152(r3) 
+	stfd	f22,  160(r3) 
+	stfd	f23,  168(r3) 
+	stfd	f24,  176(r3) 
+	stfd	f25,  184(r3) 
+	stfd	f26,  192(r3) 
+	stfd	f27,  200(r3) 
+	stfd	f28,  208(r3) 
+	stfd	f29,  216(r3) 
+	stfd	f30,  224(r3) 
+	stfd	f31,  232(r3) 
+
+	mflr	r0
+	stw	r0, 244(r3)	/* Spill the link register. */
+
+	mfcr	r12
+	stw	r12, 240(r3)	/* Spill the condition register. */
+
+	lwz	r1, 0(r4)	/* Load the incoming stack pointer. */
+
+	lwz	r0, 244(r4)	/* Load the incoming link register. */
+	mtlr	r0		/* Restore the link register. */
+
+	lwz	r12, 240(r4)	/* Load the condition register value. */
+	mtcrf	0xff, r12	/* Restore the condition register. */
+
+	lmw	r13, 20(r4)	/* Restore registers r13 - r31. */
+
+	lfd	f14,  96(r4)	/* Restore floating point register f14 - f31. */
+	lfd	f15,  104(r4)
+	lfd	f16,  112(r4)
+	lfd	f17,  120(r4)
+	lfd	f18,  128(r4) 
+	lfd	f19,  136(r4) 
+	lfd	f20,  144(r4) 
+	lfd	f21,  152(r4) 
+	lfd	f22,  160(r4) 
+	lfd	f23,  168(r4) 
+	lfd	f24,  176(r4) 
+	lfd	f25,  184(r4) 
+	lfd	f26,  192(r4) 
+	lfd	f27,  200(r4) 
+	lfd	f28,  208(r4) 
+	lfd	f29,  216(r4) 
+	lfd	f30,  224(r4) 
+	lfd	f31,  232(r4) 
+
+	/* When a thread first starts, the following blr instruction jumps
+	 * to ThreadRoot.  ThreadRoot expects the incoming thread block
+	 * in r4.
+	 */
+	blr	/* Branch to the address held in link register. */
+
+
+	.align	2
+	.globl	_ThreadRoot
+_ThreadRoot:
+	lwz	r20, 16(r4)	/* StartupPCState - ThreadBegin		*/
+	lwz	r21, 8(r4)	/* InitialArgState - arg		*/
+	lwz	r22, 4(r4)	/* InitialPCState - func		*/
+	lwz	r23, 12(r4)	/* WhenDonePCState - ThreadFinish	*/
+
+	/* Call ThreadBegin function. */
+	mtctr	r20		/* The function pointer. */
+	bctrl
+
+	/* Call the target function. */
+	mr	r3, r21		/* Function arg. */
+	mtctr	r22		/* Function pointer. */
+	bctrl
+
+	/* Call the ThreadFinish function. */
+	mtctr	r23
+	bctrl
+
+	/* We shouldn't execute here. */
+1:	b	1b
+
+
+#endif
+
+
+#if defined(PowerPC) && !defined(ApplePowerPC)
+                .globl branch[ds]
+                .csect branch[ds]
+                .long  .branch[PR]
+                .long  TOC[tc0]
+                .long  0
+                .toc
+ T.branch:      .tc    .branch[tc], branch[ds]
+                .globl .branch[PR]
+                .csect .branch[PR]
+
+         l      0, 0x0(11)        #  load function address into r0
+         mtctr  0                 #  move r0 into counter register
+         l      2, 0x4(11)        #  move new TOC address into r2
+         l      11, 0x8(11)       #  reset function address
+         bctr                     #  branch to the counter register
+
+
+                .globl ThreadRoot[ds]
+                .csect ThreadRoot[ds]
+                .long  .ThreadRoot[PR]
+                .long  TOC[tc0]
+                .long  0
+                .toc
+ T.ThreadRoot:  .tc    .ThreadRoot[tc], ThreadRoot[ds]
+                .globl .ThreadRoot[PR]
+                .csect .ThreadRoot[PR]
+ 
+                .set argarea,      32
+                .set linkarea,     24
+                .set locstckarea,   0
+                .set nfprs,        18
+                .set ngprs,        19
+                .set szdsa,        8*nfprs+4*ngprs+linkarea+argarea+locstckarea
+                
+
+         mflr    0
+         mfcr    12
+         bl      ._savef14
+         cror   0xf, 0xf, 0xf
+         stm    13, -8*nfprs-4*ngprs(1)
+         st     0, 8(1)
+         st     12, 4(1)
+         st     4,  24(1)
+         st     5,  28(1)
+         st     6,  32(1)
+         stu    1, -szdsa(1) 
+
+         muli   11,3,1          #  copy contents of register r24 to r11
+         bl     .branch[PR]      #  call function branch
+         cror   0xf, 0xf, 0xf    #  no operation
+         
+         ai     1,1,szdsa
+         lm     13, -8*nfprs-4*ngprs(1)
+         bl     ._restf14
+         cror   0xf, 0xf, 0xf
+         l      0, 8(1)
+         l      12, 4(1)
+         mtlr   0
+         mtcrf  0x38, 12
+         l      4, 24(1)
+         l      5, 28(1)
+         l      6, 32(1)
+  
+         mflr    0
+         mfcr    12
+         bl      ._savef14
+         cror   0xf, 0xf, 0xf
+         stm    13, -8*nfprs-4*ngprs(1)
+         st     0, 8(1)
+         st     12, 4(1)
+         st     6,  24(1)
+         stu    1, -szdsa(1)
+ 
+         muli   3, 4,1          #  load user function parameter r22 to r3                     
+         muli   11,5,1          #  copy contents of register r21 to r11
+         bl     .branch[PR]      #  call function branch
+         cror   0xf, 0xf, 0xf    #  no operation
+
+         ai     1,1,szdsa
+         lm     13, -8*nfprs-4*ngprs(1)
+         bl     ._restf14
+         cror   0xf, 0xf, 0xf
+         l      0, 8(1)
+         l      12, 4(1)
+         mtlr   0
+         mtcrf  0x38, 12
+         l      6, 24(1)
+
+         muli   11,6,1          #  copy contents of register r23 to r11
+         bl     .branch[PR]      #  call function branch
+         cror   0xf, 0xf, 0xf    #  no operation 
+         brl                     #  the programme should not return here.
+
+         .extern ._savef14
+         .extern ._restf14
+
+
+
+         
+            .globl SWITCH[ds]
+            .csect SWITCH[ds]
+            .long  .SWITCH[PR]
+            .long  TOC[tc0]
+            .long  0
+            .toc
+ T.SWITCH:  .tc    .SWITCH[tc], SWITCH[ds]
+            .globl .SWITCH[PR]
+            .csect .SWITCH[PR]
+
+         st     1,   0(3)       # store stack pointer
+         stm    13,  20(3)      # store general purpose registers (13 -31)
+         stfd   14,  96(3)      # store floating point registers (14 -31) 
+         stfd   15,  104(3)     # there is no single instruction to do for
+         stfd   16,  112(3)     # floating point registers. so do one by one
+         stfd   17,  120(3) 
+         stfd   18,  128(3) 
+         stfd   19,  136(3) 
+         stfd   20,  144(3) 
+         stfd   21,  152(3) 
+         stfd   22,  160(3) 
+         stfd   23,  168(3) 
+         stfd   24,  176(3) 
+         stfd   25,  184(3) 
+         stfd   26,  192(3) 
+         stfd   27,  200(3) 
+         stfd   28,  208(3) 
+         stfd   29,  216(3) 
+         stfd   30,  224(3) 
+         stfd   31,  232(3) 
+         mflr   0               # move link register value to register 0
+         st     0,   244(3)     # store link register value
+       
+         mfcr   12              # move condition register to register 12
+         st     12,  240(3)     # store condition register value
+
+
+         l      1,   0(4)       # load stack pointer
+         l      0,   244(4)     # load link register value
+         mtlr   0         
+         l      12,  240(4)     # load condition register value
+         mtcrf  0x38,  12
+
+
+
+         lm     13,  20(4)      # load into general purpose registers (13 -31) 
+         lfd    14,  96(4)      # load into floating point registers (14 -31) 
+         lfd    15,  104(4)     # there is no single instruction for
+         lfd    16,  112(4)     # loading into more than one floating point 
+         lfd    17,  120(4)     # registers. so do one by one.
+         lfd    18,  128(4) 
+         lfd    19,  136(4) 
+         lfd    20,  144(4) 
+         lfd    21,  152(4) 
+         lfd    22,  160(4) 
+         lfd    23,  168(4) 
+         lfd    24,  176(4) 
+         lfd    25,  184(4) 
+         lfd    26,  192(4) 
+         lfd    27,  200(4) 
+         lfd    28,  208(4) 
+         lfd    29,  216(4) 
+         lfd    30,  224(4) 
+         lfd    31,  232(4) 
+         l      3,   16(4)
+         l      5,   4(4)
+         l      6,   12(4)
+         l      4,   8(4)
+
+         brl                    # branch to the address held in link register.
+#endif // PowerPC
+
+
+#ifdef ALPHA
+
+/* 
+ * Porting to Alpha was done by Shuichi Oikawa (shui@sfc.keio.ac.jp).
+ */
+
+/*
+ *	Symbolic register names and register saving rules
+ *
+ *	Legend:
+ *		T	Saved by caller (Temporaries)
+ *		S	Saved by callee (call-Safe registers)
+ */
+
+#define	v0	$0	/* (T)		return value		*/
+#define t0	$1	/* (T)		temporary registers	*/
+#define s0	$9	/* (S)		call-safe registers	*/
+#define s1	$10
+#define s2	$11
+#define s3	$12
+#define s4	$13
+#define s5	$14
+#define s6	$15
+#define a0	$16	/* (T)		argument registers	*/
+#define a1	$17
+#define ai	$25	/* (T)		argument information	*/
+#define ra	$26	/* (T)		return address		*/
+#define pv	$27	/* (T)		procedure value		*/
+#define	gp	$29	/* (T)		(local) data pointer	*/
+#define sp	$30	/* (S)		stack pointer		*/
+#define zero	$31	/* 		wired zero		*/
+
+	.set	noreorder	# unless overridden
+	.align	3
+	.text
+ 	
+	.globl ThreadRoot
+	.ent	ThreadRoot,0
+ThreadRoot:
+	.frame	sp,0,ra
+	ldgp	gp,0(pv)
+
+	mov	zero,s6		# Clearing the frame pointer here
+				# makes gdb backtraces of thread stacks 
+				# end here (I hope!)
+	mov	StartupPC,pv
+	jsr	ra,(pv)		# call startup procedure
+	ldgp	gp,0(ra)
+
+	mov	InitialArg,a0
+	mov	InitialPC,pv
+	jsr	ra,(pv)		# call main procedure
+	ldgp	gp,0(ra)
+
+	mov	WhenDonePC,pv
+	jsr 	ra,(pv)		# when done, call clean up procedure
+	ldgp	gp,0(ra)
+
+	.end ThreadRoot		# NEVER REACHED
+	
+/* a0 -- pointer to old Thread *
+ * a1 -- pointer to new Thread */
+	.globl SWITCH
+	.ent	SWITCH,0
+SWITCH:
+	.frame	sp,0,ra
+	ldgp	gp,0(pv)
+	
+	stq	ra, PC(a0)		# save return address
+	stq	gp, GP(a0)
+	stq	sp, SP(a0)		# save new stack pointer
+	stq	s0, S0(a0)		# save all the callee-save registers
+	stq	s1, S1(a0)
+	stq	s2, S2(a0)
+	stq	s3, S3(a0)
+	stq	s4, S4(a0)
+	stq	s5, S5(a0)
+	stq	s6, S6(a0)		# save frame pointer
+	
+	ldq	ra, PC(a1)		# load the return address	
+	ldq	gp, GP(a1)
+	ldq	sp, SP(a1)		# load the new stack pointer
+	ldq	s0, S0(a1)		# load the callee-save registers
+	ldq	s1, S1(a1)
+	ldq	s2, S2(a1)
+	ldq	s3, S3(a1)
+	ldq	s4, S4(a1)
+	ldq	s5, S5(a1)
+	ldq	s6, S6(a1)
+
+	mov	ra,pv
+	ret	zero,(ra)
+
+	.end SWITCH
+	
+#endif // ALPHA
diff --git a/code/threads/switch.h b/code/threads/switch.h
new file mode 100644
index 0000000..ccec732
--- /dev/null
+++ b/code/threads/switch.h
@@ -0,0 +1,268 @@
+/* switch.h
+ *	Definitions needed for implementing context switching.
+ *
+ *	Context switching is inherently machine dependent, since
+ *	the registers to be saved, how to set up an initial
+ *	call frame, etc, are all specific to a processor architecture.
+ *
+ * 	This file currently supports the DEC MIPS, DEC Alpha, SUN SPARC,
+ *  HP PARISC, IBM PowerPC, and Intel x86 architectures.
+ */
+
+/*
+ Copyright (c) 1992-1996 The Regents of the University of California.
+ All rights reserved.  See copyright.h for copyright notice and limitation
+ of liability and disclaimer of warranty provisions.
+ */
+
+#ifndef SWITCH_H
+#define SWITCH_H
+
+#include "copyright.h"
+
+#ifdef DECMIPS
+
+/* Registers that must be saved during a context switch.
+ * These are the offsets from the beginning of the Thread object,
+ * in bytes, used in switch.s
+ */
+#define SP 0
+#define S0 4
+#define S1 8
+#define S2 12
+#define S3 16
+#define S4 20
+#define S5 24
+#define S6 28
+#define S7 32
+#define FP 36
+#define PC 40
+
+/* To fork a thread, we set up its saved register state, so that
+ * when we switch to the thread, it will start running in ThreadRoot.
+ *
+ * The following are the initial registers we need to set up to
+ * pass values into ThreadRoot (for instance, containing the procedure
+ * for the thread to run).  The first set is the registers as used
+ * by ThreadRoot; the second set is the locations for these initial
+ * values in the Thread object -- used in Thread::AllocateStack().
+ */
+
+#define InitialPC s0
+#define InitialArg s1
+#define WhenDonePC s2
+#define StartupPC s3
+
+#define PCState (PC / 4 - 1)
+#define FPState (FP / 4 - 1)
+#define InitialPCState (S0 / 4 - 1)
+#define InitialArgState (S1 / 4 - 1)
+#define WhenDonePCState (S2 / 4 - 1)
+#define StartupPCState (S3 / 4 - 1)
+
+#endif  // DECMIPS
+
+#ifdef SPARC
+
+/* Registers that must be saved during a context switch.  See comment above. */
+#define I0 4
+#define I1 8
+#define I2 12
+#define I3 16
+#define I4 20
+#define I5 24
+#define I6 28
+#define I7 32
+
+/* Aliases used for clearing code.  */
+#define FP I6
+#define PC I7
+
+/* Registers for ThreadRoot.  See comment above. */
+#define InitialPC % o0
+#define InitialArg % o1
+#define WhenDonePC % o2
+#define StartupPC % o3
+
+#define PCState (PC / 4 - 1)
+#define InitialPCState (I0 / 4 - 1)
+#define InitialArgState (I1 / 4 - 1)
+#define WhenDonePCState (I2 / 4 - 1)
+#define StartupPCState (I3 / 4 - 1)
+
+#endif  // SPARC
+
+#ifdef PARISC
+
+/* Registers that must be saved during a context switch.  See comment above. */
+#define SP 0
+#define S0 4
+#define S1 8
+#define S2 12
+#define S3 16
+#define S4 20
+#define S5 24
+#define S6 28
+#define S7 32
+#define S8 36
+#define S9 40
+#define S10 44
+#define S11 48
+#define S12 52
+#define S13 56
+#define S14 60
+#define S15 64
+#define PC 68
+
+/* Registers for ThreadRoot.  See comment above. */
+#define InitialPC % r3 /* S0 */
+#define InitialArg % r4
+#define WhenDonePC % r5
+#define StartupPC % r6
+
+#define PCState (PC / 4 - 1)
+#define InitialPCState (S0 / 4 - 1)
+#define InitialArgState (S1 / 4 - 1)
+#define WhenDonePCState (S2 / 4 - 1)
+#define StartupPCState (S3 / 4 - 1)
+
+#endif  // PARISC
+
+#ifdef x86
+
+/* the offsets of the registers from the beginning of the thread object */
+#define _ESP 0
+#define _EAX 4
+#define _EBX 8
+#define _ECX 12
+#define _EDX 16
+#define _EBP 20
+#define _ESI 24
+#define _EDI 28
+#define _PC 32
+
+/* These definitions are used in Thread::AllocateStack(). */
+#define PCState (_PC / 4 - 1)
+#define FPState (_EBP / 4 - 1)
+#define InitialPCState (_ESI / 4 - 1)
+#define InitialArgState (_EDX / 4 - 1)
+#define WhenDonePCState (_EDI / 4 - 1)
+#define StartupPCState (_ECX / 4 - 1)
+
+#define InitialPC % esi
+#define InitialArg % edx
+#define WhenDonePC % edi
+#define StartupPC % ecx
+
+#endif  // x86
+
+#ifdef PowerPC
+
+#define SP 0  // stack pointer
+#define P1 4  // parameters
+#define P2 8
+#define P3 12
+#define P4 16
+#define GP13 20  // general purpose registers 13-31
+#define GP14 24
+#define GP15 28
+#define GP16 32
+#define GP17 36
+#define GP18 40
+#define GP19 44
+#define GP20 48
+#define GP21 52
+#define GP22 56
+#define GP23 60
+#define GP24 64
+#define GP25 68
+#define GP26 72
+#define GP27 76
+#define GP28 80
+#define GP29 84
+#define GP30 88
+#define GP31 92
+#define FP13 96  // floating point registers 14-31
+#define FP15 104
+#define FP16 112
+#define FP17 120
+#define FP18 128
+#define FP19 136
+#define FP20 144
+#define FP21 152
+#define FP22 160
+#define FP23 168
+#define FP24 176
+#define FP25 184
+#define FP26 192
+#define FP27 200
+#define FP28 208
+#define FP29 216
+#define FP30 224
+#define FP31 232
+#define CR 240   // control register
+#define LR 244   // link register
+#define TOC 248  // Table Of Contents
+
+// for ThreadRoot assembly function
+
+#define InitialPCState 0   //  (P1/4 - 1)  // user function address
+#define InitialArgState 1  //  (P2/4 - 1)  // user function argument
+#define WhenDonePCState 2  //  (P3/4 - 1)  // clean up function addr
+#define StartupPCState 3   //  (P4/4 - 1)  // start up function addr
+#define PCState \
+    60  //  (LR/4 - 1)  // ThreadRoot addr (first time).
+        // Later PC addr when SWITCH
+        // occured
+
+#define InitialLR 21
+#define InitialArg 22
+#define WhenDoneLR 23
+#define StartupLR 24
+
+#endif  // PowerPC
+
+#ifdef ALPHA
+
+/*
+ * Porting to Alpha was done by Shuichi Oikawa (shui@sfc.keio.ac.jp).
+ */
+/* Registers that must be saved during a context switch.
+ * These are the offsets from the beginning of the Thread object,
+ * in bytes, used in switch.s
+ */
+#define SP (0 * 8)
+#define S0 (1 * 8)
+#define S1 (2 * 8)
+#define S2 (3 * 8)
+#define S3 (4 * 8)
+#define S4 (5 * 8)
+#define S5 (6 * 8)
+#define S6 (7 * 8) /* used as FP (Frame Pointer) */
+#define GP (8 * 8)
+#define PC (9 * 8)
+
+/* To fork a thread, we set up its saved register state, so that
+ * when we switch to the thread, it will start running in ThreadRoot.
+ *
+ * The following are the initial registers we need to set up to
+ * pass values into ThreadRoot (for instance, containing the procedure
+ * for the thread to run).  The first set is the registers as used
+ * by ThreadRoot; the second set is the locations for these initial
+ * values in the Thread object -- used in Thread::StackAllocate().
+ */
+#define InitialPC s0
+#define InitialArg s1
+#define WhenDonePC s2
+#define StartupPC s3
+
+#define PCState (PC / 8 - 1)
+#define FPState (S6 / 8 - 1)
+#define InitialPCState (S0 / 8 - 1)
+#define InitialArgState (S1 / 8 - 1)
+#define WhenDonePCState (S2 / 8 - 1)
+#define StartupPCState (S3 / 8 - 1)
+
+#endif  // HOST_ALPHA
+
+#endif  // SWITCH_H
diff --git a/code/threads/synch.cc b/code/threads/synch.cc
new file mode 100644
index 0000000..bdbea73
--- /dev/null
+++ b/code/threads/synch.cc
@@ -0,0 +1,272 @@
+// synch.cc
+//	Routines for synchronizing threads.  Three kinds of
+//	synchronization routines are defined here: semaphores, locks
+//   	and condition variables.
+//
+// Any implementation of a synchronization routine needs some
+// primitive atomic operation.  We assume Nachos is running on
+// a uniprocessor, and thus atomicity can be provided by
+// turning off interrupts.  While interrupts are disabled, no
+// context switch can occur, and thus the current thread is guaranteed
+// to hold the CPU throughout, until interrupts are reenabled.
+//
+// Because some of these routines might be called with interrupts
+// already disabled (Semaphore::V for one), instead of turning
+// on interrupts at the end of the atomic operation, we always simply
+// re-set the interrupt state back to its original value (whether
+// that be disabled or enabled).
+//
+// Once we'e implemented one set of higher level atomic operations,
+// we can implement others using that implementation.  We illustrate
+// this by implementing locks and condition variables on top of
+// semaphores, instead of directly enabling and disabling interrupts.
+//
+// Locks are implemented using a semaphore to keep track of
+// whether the lock is held or not -- a semaphore value of 0 means
+// the lock is busy; a semaphore value of 1 means the lock is free.
+//
+// The implementation of condition variables using semaphores is
+// a bit trickier, as explained below under Condition::Wait.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "synch.h"
+#include "main.h"
+
+//----------------------------------------------------------------------
+// Semaphore::Semaphore
+// 	Initialize a semaphore, so that it can be used for synchronization.
+//
+//	"debugName" is an arbitrary name, useful for debugging.
+//	"initialValue" is the initial value of the semaphore.
+//----------------------------------------------------------------------
+
+Semaphore::Semaphore(char *debugName, int initialValue) {
+    name = debugName;
+    value = initialValue;
+    queue = new List<Thread *>;
+}
+
+//----------------------------------------------------------------------
+// Semaphore::Semaphore
+// 	De-allocate semaphore, when no longer needed.  Assume no one
+//	is still waiting on the semaphore!
+//----------------------------------------------------------------------
+
+Semaphore::~Semaphore() { delete queue; }
+
+//----------------------------------------------------------------------
+// Semaphore::P
+// 	Wait until semaphore value > 0, then decrement.  Checking the
+//	value and decrementing must be done atomically, so we
+//	need to disable interrupts before checking the value.
+//
+//	Note that Thread::Sleep assumes that interrupts are disabled
+//	when it is called.
+//----------------------------------------------------------------------
+
+void Semaphore::P() {
+    Interrupt *interrupt = kernel->interrupt;
+    Thread *currentThread = kernel->currentThread;
+
+    // disable interrupts
+    IntStatus oldLevel = interrupt->SetLevel(IntOff);
+
+    while (value == 0) {               // semaphore not available
+        queue->Append(currentThread);  // so go to sleep
+        currentThread->Sleep(FALSE);
+    }
+    value--;  // semaphore available, consume its value
+
+    // re-enable interrupts
+    (void)interrupt->SetLevel(oldLevel);
+}
+
+//----------------------------------------------------------------------
+// Semaphore::V
+// 	Increment semaphore value, waking up a waiter if necessary.
+//	As with P(), this operation must be atomic, so we need to disable
+//	interrupts.  Scheduler::ReadyToRun() assumes that interrupts
+//	are disabled when it is called.
+//----------------------------------------------------------------------
+
+void Semaphore::V() {
+    Interrupt *interrupt = kernel->interrupt;
+
+    // disable interrupts
+    IntStatus oldLevel = interrupt->SetLevel(IntOff);
+
+    if (!queue->IsEmpty()) {  // make thread ready.
+        kernel->scheduler->ReadyToRun(queue->RemoveFront());
+    }
+    value++;
+
+    // re-enable interrupts
+    (void)interrupt->SetLevel(oldLevel);
+}
+
+//----------------------------------------------------------------------
+// Semaphore::SelfTest, SelfTestHelper
+// 	Test the semaphore implementation, by using a semaphore
+//	to control two threads ping-ponging back and forth.
+//----------------------------------------------------------------------
+
+static Semaphore *ping;
+static void SelfTestHelper(Semaphore *pong) {
+    for (int i = 0; i < 10; i++) {
+        ping->P();
+        pong->V();
+    }
+}
+
+void Semaphore::SelfTest() {
+    Thread *helper = new Thread("ping");
+
+    ASSERT(value == 0);  // otherwise test won't work!
+    ping = new Semaphore("ping", 0);
+    helper->Fork((VoidFunctionPtr)SelfTestHelper, this);
+    for (int i = 0; i < 10; i++) {
+        ping->V();
+        this->P();
+    }
+    delete ping;
+}
+
+//----------------------------------------------------------------------
+// Lock::Lock
+// 	Initialize a lock, so that it can be used for synchronization.
+//	Initially, unlocked.
+//
+//	"debugName" is an arbitrary name, useful for debugging.
+//----------------------------------------------------------------------
+
+Lock::Lock(char *debugName) {
+    name = debugName;
+    semaphore = new Semaphore("lock", 1);  // initially, unlocked
+    lockHolder = NULL;
+}
+
+//----------------------------------------------------------------------
+// Lock::~Lock
+// 	Deallocate a lock
+//----------------------------------------------------------------------
+Lock::~Lock() { delete semaphore; }
+
+//----------------------------------------------------------------------
+// Lock::Acquire
+//	Atomically wait until the lock is free, then set it to busy.
+//	Equivalent to Semaphore::P(), with the semaphore value of 0
+//	equal to busy, and semaphore value of 1 equal to free.
+//----------------------------------------------------------------------
+
+void Lock::Acquire() {
+    semaphore->P();
+    lockHolder = kernel->currentThread;
+}
+
+//----------------------------------------------------------------------
+// Lock::Release
+//	Atomically set lock to be free, waking up a thread waiting
+//	for the lock, if any.
+//	Equivalent to Semaphore::V(), with the semaphore value of 0
+//	equal to busy, and semaphore value of 1 equal to free.
+//
+//	By convention, only the thread that acquired the lock
+// 	may release it.
+//---------------------------------------------------------------------
+
+void Lock::Release() {
+    ASSERT(IsHeldByCurrentThread());
+    lockHolder = NULL;
+    semaphore->V();
+}
+
+//----------------------------------------------------------------------
+// Condition::Condition
+// 	Initialize a condition variable, so that it can be
+//	used for synchronization.  Initially, no one is waiting
+//	on the condition.
+//
+//	"debugName" is an arbitrary name, useful for debugging.
+//----------------------------------------------------------------------
+Condition::Condition(char *debugName) {
+    name = debugName;
+    waitQueue = new List<Semaphore *>;
+}
+
+//----------------------------------------------------------------------
+// Condition::Condition
+// 	Deallocate the data structures implementing a condition variable.
+//----------------------------------------------------------------------
+
+Condition::~Condition() { delete waitQueue; }
+
+//----------------------------------------------------------------------
+// Condition::Wait
+// 	Atomically release monitor lock and go to sleep.
+//	Our implementation uses semaphores to implement this, by
+//	allocating a semaphore for each waiting thread.  The signaller
+//	will V() this semaphore, so there is no chance the waiter
+//	will miss the signal, even though the lock is released before
+//	calling P().
+//
+//	Note: we assume Mesa-style semantics, which means that the
+//	waiter must re-acquire the monitor lock when waking up.
+//
+//	"conditionLock" -- lock protecting the use of this condition
+//----------------------------------------------------------------------
+
+void Condition::Wait(Lock *conditionLock) {
+    Semaphore *waiter;
+
+    ASSERT(conditionLock->IsHeldByCurrentThread());
+
+    waiter = new Semaphore("condition", 0);
+    waitQueue->Append(waiter);
+    conditionLock->Release();
+    waiter->P();
+    conditionLock->Acquire();
+    delete waiter;
+}
+
+//----------------------------------------------------------------------
+// Condition::Signal
+// 	Wake up a thread waiting on this condition, if any.
+//
+//	Note: we assume Mesa-style semantics, which means that the
+//	signaller doesn't give up control immediately to the thread
+//	being woken up (unlike Hoare-style).
+//
+//	Also note: we assume the caller holds the monitor lock
+//	(unlike what is described in Birrell's paper).  This allows
+//	us to access waitQueue without disabling interrupts.
+//
+//	"conditionLock" -- lock protecting the use of this condition
+//----------------------------------------------------------------------
+
+void Condition::Signal(Lock *conditionLock) {
+    Semaphore *waiter;
+
+    ASSERT(conditionLock->IsHeldByCurrentThread());
+
+    if (!waitQueue->IsEmpty()) {
+        waiter = waitQueue->RemoveFront();
+        waiter->V();
+    }
+}
+
+//----------------------------------------------------------------------
+// Condition::Broadcast
+// 	Wake up all threads waiting on this condition, if any.
+//
+//	"conditionLock" -- lock protecting the use of this condition
+//----------------------------------------------------------------------
+
+void Condition::Broadcast(Lock *conditionLock) {
+    while (!waitQueue->IsEmpty()) {
+        Signal(conditionLock);
+    }
+}
diff --git a/code/threads/synch.h b/code/threads/synch.h
new file mode 100644
index 0000000..3aedf18
--- /dev/null
+++ b/code/threads/synch.h
@@ -0,0 +1,143 @@
+// synch.h
+//	Data structures for synchronizing threads.
+//
+//	Three kinds of synchronization are defined here: semaphores,
+//	locks, and condition variables.  The implementation for
+//	semaphores is given; for the latter two, only the procedure
+//	interface is given -- they are to be implemented as part of
+//	the first assignment.
+//
+//	Note that all the synchronization objects take a "name" as
+//	part of the initialization.  This is solely for debugging purposes.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// synch.h -- synchronization primitives.
+
+#ifndef SYNCH_H
+#define SYNCH_H
+
+#include "copyright.h"
+#include "thread.h"
+#include "list.h"
+#include "main.h"
+
+// The following class defines a "semaphore" whose value is a non-negative
+// integer.  The semaphore has only two operations P() and V():
+//
+//	P() -- waits until value > 0, then decrement
+//
+//	V() -- increment, waking up a thread waiting in P() if necessary
+//
+// Note that the interface does *not* allow a thread to read the value of
+// the semaphore directly -- even if you did read the value, the
+// only thing you would know is what the value used to be.  You don't
+// know what the value is now, because by the time you get the value
+// into a register, a context switch might have occurred,
+// and some other thread might have called P or V, so the true value might
+// now be different.
+
+class Semaphore {
+   public:
+    Semaphore(char *debugName, int initialValue);  // set initial value
+    ~Semaphore();                                  // de-allocate semaphore
+    char *getName() { return name; }               // debugging assist
+
+    void P();         // these are the only operations on a semaphore
+    void V();         // they are both *atomic*
+    void SelfTest();  // test routine for semaphore implementation
+
+   private:
+    char *name;  // useful for debugging
+    int value;   // semaphore value, always >= 0
+    List<Thread *> *queue;
+    // threads waiting in P() for the value to be > 0
+};
+
+// The following class defines a "lock".  A lock can be BUSY or FREE.
+// There are only two operations allowed on a lock:
+//
+//	Acquire -- wait until the lock is FREE, then set it to BUSY
+//
+//	Release -- set lock to be FREE, waking up a thread waiting
+//		in Acquire if necessary
+//
+// In addition, by convention, only the thread that acquired the lock
+// may release it.  As with semaphores, you can't read the lock value
+// (because the value might change immediately after you read it).
+
+class Lock {
+   public:
+    Lock(char *debugName);            // initialize lock to be FREE
+    ~Lock();                          // deallocate lock
+    char *getName() { return name; }  // debugging assist
+
+    void Acquire();  // these are the only operations on a lock
+    void Release();  // they are both *atomic*
+
+    bool IsHeldByCurrentThread() { return lockHolder == kernel->currentThread; }
+    // return true if the current thread
+    // holds this lock.
+
+    // Note: SelfTest routine provided by SynchList
+
+   private:
+    char *name;            // debugging assist
+    Thread *lockHolder;    // thread currently holding lock
+    Semaphore *semaphore;  // we use a semaphore to implement lock
+};
+
+// The following class defines a "condition variable".  A condition
+// variable does not have a value, but threads may be queued, waiting
+// on the variable.  These are only operations on a condition variable:
+//
+//	Wait() -- release the lock, relinquish the CPU until signaled,
+//		then re-acquire the lock
+//
+//	Signal() -- wake up a thread, if there are any waiting on
+//		the condition
+//
+//	Broadcast() -- wake up all threads waiting on the condition
+//
+// All operations on a condition variable must be made while
+// the current thread has acquired a lock.  Indeed, all accesses
+// to a given condition variable must be protected by the same lock.
+// In other words, mutual exclusion must be enforced among threads calling
+// the condition variable operations.
+//
+// In Nachos, condition variables are assumed to obey *Mesa*-style
+// semantics.  When a Signal or Broadcast wakes up another thread,
+// it simply puts the thread on the ready list, and it is the responsibility
+// of the woken thread to re-acquire the lock (this re-acquire is
+// taken care of within Wait()).  By contrast, some define condition
+// variables according to *Hoare*-style semantics -- where the signalling
+// thread gives up control over the lock and the CPU to the woken thread,
+// which runs immediately and gives back control over the lock to the
+// signaller when the woken thread leaves the critical section.
+//
+// The consequence of using Mesa-style semantics is that some other thread
+// can acquire the lock, and change data structures, before the woken
+// thread gets a chance to run.  The advantage to Mesa-style semantics
+// is that it is a lot easier to implement than Hoare-style.
+
+class Condition {
+   public:
+    Condition(char *debugName);  // initialize condition to
+                                 // "no one waiting"
+    ~Condition();                // deallocate the condition
+    char *getName() { return (name); }
+
+    void Wait(Lock *conditionLock);       // these are the 3 operations on
+                                          // condition variables; releasing the
+                                          // lock and going to sleep are
+                                          // *atomic* in Wait()
+    void Signal(Lock *conditionLock);     // conditionLock must be held by
+    void Broadcast(Lock *conditionLock);  // the currentThread for all of
+                                          // these operations
+    // SelfTest routine provided by SyncLists
+
+   private:
+    char *name;
+    List<Semaphore *> *waitQueue;  // list of waiting threads
+};
+#endif  // SYNCH_H
diff --git a/code/threads/synchlist.cc b/code/threads/synchlist.cc
new file mode 100644
index 0000000..ed51841
--- /dev/null
+++ b/code/threads/synchlist.cc
@@ -0,0 +1,118 @@
+// synchlist.cc
+//	Routines for synchronized access to a list.
+//
+// 	Implemented in "monitor"-style -- surround each procedure with a
+// 	lock acquire and release pair, using condition signal and wait for
+// 	synchronization.
+//
+// Copyright (c) 1992-1993 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "synchlist.h"
+
+//----------------------------------------------------------------------
+// SynchList<T>::SynchList
+//	Allocate and initialize the data structures needed for a
+//	synchronized list, empty to start with.
+//	Elements can now be added to the list.
+//----------------------------------------------------------------------
+
+template <class T>
+SynchList<T>::SynchList() {
+    list = new List<T>;
+    lock = new Lock("list lock");
+    listEmpty = new Condition("list empty cond");
+}
+
+//----------------------------------------------------------------------
+// SynchList<T>::~SynchList
+//	De-allocate the data structures created for synchronizing a list.
+//----------------------------------------------------------------------
+
+template <class T>
+SynchList<T>::~SynchList() {
+    delete listEmpty;
+    delete lock;
+    delete list;
+}
+
+//----------------------------------------------------------------------
+// SynchList<T>::Append
+//      Append an "item" to the end of the list.  Wake up anyone
+//	waiting for an element to be appended.
+//
+//	"item" is the thing to put on the list.
+//----------------------------------------------------------------------
+
+template <class T>
+void SynchList<T>::Append(T item) {
+    lock->Acquire();  // enforce mutual exclusive access to the list
+    list->Append(item);
+    listEmpty->Signal(lock);  // wake up a waiter, if any
+    lock->Release();
+}
+
+//----------------------------------------------------------------------
+// SynchList<T>::RemoveFront
+//      Remove an "item" from the beginning of the list.  Wait if
+//	the list is empty.
+// Returns:
+//	The removed item.
+//----------------------------------------------------------------------
+
+template <class T>
+T SynchList<T>::RemoveFront() {
+    T item;
+
+    lock->Acquire();  // enforce mutual exclusion
+    while (list->IsEmpty())
+        listEmpty->Wait(lock);  // wait until list isn't empty
+    item = list->RemoveFront();
+    lock->Release();
+    return item;
+}
+
+//----------------------------------------------------------------------
+// SynchList<T>::Apply
+//      Apply function to every item on a list.
+//
+//      "func" -- the function to apply
+//----------------------------------------------------------------------
+
+template <class T>
+void SynchList<T>::Apply(void (*func)(T)) {
+    lock->Acquire();  // enforce mutual exclusion
+    list->Apply(func);
+    lock->Release();
+}
+
+//----------------------------------------------------------------------
+// SynchList<T>::SelfTest, SelfTestHelper
+//	Test whether the SynchList implementation is working,
+//	by having two threads ping-pong a value between them
+//	using two synchronized lists.
+//----------------------------------------------------------------------
+
+template <class T>
+void SynchList<T>::SelfTestHelper(void* data) {
+    SynchList<T>* _this = (SynchList<T>*)data;
+    for (int i = 0; i < 10; i++) {
+        _this->Append(_this->selfTestPing->RemoveFront());
+    }
+}
+
+template <class T>
+void SynchList<T>::SelfTest(T val) {
+    Thread* helper = new Thread("ping");
+
+    ASSERT(list->IsEmpty());
+    selfTestPing = new SynchList<T>;
+    helper->Fork(SynchList<T>::SelfTestHelper, this);
+    for (int i = 0; i < 10; i++) {
+        selfTestPing->Append(val);
+        ASSERT(val == this->RemoveFront());
+    }
+    delete selfTestPing;
+}
diff --git a/code/threads/synchlist.h b/code/threads/synchlist.h
new file mode 100644
index 0000000..c51935a
--- /dev/null
+++ b/code/threads/synchlist.h
@@ -0,0 +1,51 @@
+// synchlist.h
+//	Data structures for synchronized access to a list.
+//
+//	Identical interface to List, except accesses are synchronized.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef SYNCHLIST_H
+#define SYNCHLIST_H
+
+#include "copyright.h"
+#include "list.h"
+#include "synch.h"
+
+// The following class defines a "synchronized list" -- a list for which
+// these constraints hold:
+//	1. Threads trying to remove an item from a list will
+//	wait until the list has an element on it.
+//	2. One thread at a time can access list data structures
+
+template <class T>
+class SynchList {
+   public:
+    SynchList();   // initialize a synchronized list
+    ~SynchList();  // de-allocate a synchronized list
+
+    void Append(T item);  // append item to the end of the list,
+                          // and wake up any thread waiting in remove
+
+    T RemoveFront();  // remove the first item from the front of
+                      // the list, waiting if the list is empty
+
+    void Apply(void (*f)(T));  // apply function to all elements in list
+
+    void SelfTest(T value);  // test the SynchList implementation
+
+   private:
+    List<T> *list;         // the list of things
+    Lock *lock;            // enforce mutual exclusive access to the list
+    Condition *listEmpty;  // wait in Remove if the list is empty
+
+    // these are only to assist SelfTest()
+    SynchList<T> *selfTestPing;
+    static void SelfTestHelper(void *data);
+};
+
+#include "synchlist.cc"
+
+#endif  // SYNCHLIST_H
diff --git a/code/threads/thread.cc b/code/threads/thread.cc
new file mode 100644
index 0000000..be9f7d6
--- /dev/null
+++ b/code/threads/thread.cc
@@ -0,0 +1,411 @@
+// thread.cc
+//	Routines to manage threads.  These are the main operations:
+//
+//	Fork -- create a thread to run a procedure concurrently
+//		with the caller (this is done in two steps -- first
+//		allocate the Thread object, then call Fork on it)
+//	Begin -- called when the forked procedure starts up, to turn
+//		interrupts on and clean up after last thread
+//	Finish -- called when the forked procedure finishes, to clean up
+//	Yield -- relinquish control over the CPU to another ready thread
+//	Sleep -- relinquish control over the CPU, but thread is now blocked.
+//		In other words, it will not run again, until explicitly
+//		put back on the ready queue.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "thread.h"
+#include "switch.h"
+#include "synch.h"
+#include "sysdep.h"
+
+// this is put at the top of the execution stack, for detecting stack overflows
+const int STACK_FENCEPOST = 0xdedbeef;
+
+//----------------------------------------------------------------------
+// Thread::Thread
+// 	Initialize a thread control block, so that we can then call
+//	Thread::Fork.
+//
+//	"threadName" is an arbitrary string, useful for debugging.
+//----------------------------------------------------------------------
+
+Thread::Thread(char *threadName, bool _has_dynamic_name /*=false*/) {
+    has_dynamic_name = _has_dynamic_name;
+    name = threadName;
+    stackTop = NULL;
+    stack = NULL;
+    status = JUST_CREATED;
+    for (int i = 0; i < MachineStateSize; i++) {
+        machineState[i] = NULL;  // not strictly necessary, since
+                                 // new thread ignores contents
+                                 // of machine registers
+    }
+    space = NULL;
+}
+
+//----------------------------------------------------------------------
+// Thread::~Thread
+// 	De-allocate a thread.
+//
+// 	NOTE: the current thread *cannot* delete itself directly,
+//	since it is still running on the stack that we need to delete.
+//
+//      NOTE: if this is the main thread, we can't delete the stack
+//      because we didn't allocate it -- we got it automatically
+//      as part of starting up Nachos.
+//----------------------------------------------------------------------
+
+Thread::~Thread() {
+    DEBUG(dbgThread, "Deleting thread: " << name);
+
+    ASSERT(this != kernel->currentThread);
+    if (stack != NULL)
+        DeallocBoundedArray((char *)stack, StackSize * sizeof(int));
+    if (has_dynamic_name) delete[] name;
+}
+
+//----------------------------------------------------------------------
+// Thread::Fork
+// 	Invoke (*func)(arg), allowing caller and callee to execute
+//	concurrently.
+//
+//	NOTE: although our definition allows only a single argument
+//	to be passed to the procedure, it is possible to pass multiple
+//	arguments by making them fields of a structure, and passing a pointer
+//	to the structure as "arg".
+//
+// 	Implemented as the following steps:
+//		1. Allocate a stack
+//		2. Initialize the stack so that a call to SWITCH will
+//		cause it to run the procedure
+//		3. Put the thread on the ready queue
+//
+//	"func" is the procedure to run concurrently.
+//	"arg" is a single argument to be passed to the procedure.
+//----------------------------------------------------------------------
+
+void Thread::Fork(VoidFunctionPtr func, void *arg) {
+    Interrupt *interrupt = kernel->interrupt;
+    Scheduler *scheduler = kernel->scheduler;
+    IntStatus oldLevel;
+
+    DEBUG(dbgThread,
+          "Forking thread: " << name << " f(a): " << (int)func << " " << arg);
+
+    StackAllocate(func, arg);
+
+    oldLevel = interrupt->SetLevel(IntOff);
+    scheduler->ReadyToRun(this);  // ReadyToRun assumes that interrupts
+                                  // are disabled!
+    (void)interrupt->SetLevel(oldLevel);
+}
+
+//----------------------------------------------------------------------
+// Thread::CheckOverflow
+// 	Check a thread's stack to see if it has overrun the space
+//	that has been allocated for it.  If we had a smarter compiler,
+//	we wouldn't need to worry about this, but we don't.
+//
+// 	NOTE: Nachos will not catch all stack overflow conditions.
+//	In other words, your program may still crash because of an overflow.
+//
+// 	If you get bizarre results (such as seg faults where there is no code)
+// 	then you *may* need to increase the stack size.  You can avoid stack
+// 	overflows by not putting large data structures on the stack.
+// 	Don't do this: void foo() { int bigArray[10000]; ... }
+//----------------------------------------------------------------------
+
+void Thread::CheckOverflow() {
+    if (stack != NULL) {
+#ifdef HPUX  // Stacks grow upward on the Snakes
+        ASSERT(stack[StackSize - 1] == STACK_FENCEPOST);
+#else
+        ASSERT(*stack == STACK_FENCEPOST);
+#endif
+    }
+}
+
+//----------------------------------------------------------------------
+// Thread::Begin
+// 	Called by ThreadRoot when a thread is about to begin
+//	executing the forked procedure.
+//
+// 	It's main responsibilities are:
+//	1. deallocate the previously running thread if it finished
+//		(see Thread::Finish())
+//	2. enable interrupts (so we can get time-sliced)
+//----------------------------------------------------------------------
+
+void Thread::Begin() {
+    ASSERT(this == kernel->currentThread);
+    DEBUG(dbgThread, "Beginning thread: " << name);
+
+    kernel->scheduler->CheckToBeDestroyed();
+    kernel->interrupt->Enable();
+}
+
+//----------------------------------------------------------------------
+// Thread::Finish
+// 	Called by ThreadRoot when a thread is done executing the
+//	forked procedure.
+//
+// 	NOTE: we can't immediately de-allocate the thread data structure
+//	or the execution stack, because we're still running in the thread
+//	and we're still on the stack!  Instead, we tell the scheduler
+//	to call the destructor, once it is running in the context of a different
+// thread.
+//
+// 	NOTE: we disable interrupts, because Sleep() assumes interrupts
+//	are disabled.
+//----------------------------------------------------------------------
+
+//
+void Thread::Finish() {
+    (void)kernel->interrupt->SetLevel(IntOff);
+    ASSERT(this == kernel->currentThread);
+
+    DEBUG(dbgThread, "Finishing thread: " << name);
+
+    Sleep(TRUE);  // invokes SWITCH
+    // not reached
+}
+
+//----------------------------------------------------------------------
+// Thread::Yield
+// 	Relinquish the CPU if any other thread is ready to run.
+//	If so, put the thread on the end of the ready list, so that
+//	it will eventually be re-scheduled.
+//
+//	NOTE: returns immediately if no other thread on the ready queue.
+//	Otherwise returns when the thread eventually works its way
+//	to the front of the ready list and gets re-scheduled.
+//
+//	NOTE: we disable interrupts, so that looking at the thread
+//	on the front of the ready list, and switching to it, can be done
+//	atomically.  On return, we re-set the interrupt level to its
+//	original state, in case we are called with interrupts disabled.
+//
+// 	Similar to Thread::Sleep(), but a little different.
+//----------------------------------------------------------------------
+
+void Thread::Yield() {
+    Thread *nextThread;
+    IntStatus oldLevel = kernel->interrupt->SetLevel(IntOff);
+
+    ASSERT(this == kernel->currentThread);
+
+    DEBUG(dbgThread, "Yielding thread: " << name);
+
+    nextThread = kernel->scheduler->FindNextToRun();
+    if (nextThread != NULL) {
+        kernel->scheduler->ReadyToRun(this);
+        kernel->scheduler->Run(nextThread, FALSE);
+    }
+    (void)kernel->interrupt->SetLevel(oldLevel);
+}
+
+//----------------------------------------------------------------------
+// Thread::Sleep
+// 	Relinquish the CPU, because the current thread has either
+//	finished or is blocked waiting on a synchronization
+//	variable (Semaphore, Lock, or Condition).  In the latter case,
+//	eventually some thread will wake this thread up, and put it
+//	back on the ready queue, so that it can be re-scheduled.
+//
+//	NOTE: if there are no threads on the ready queue, that means
+//	we have no thread to run.  "Interrupt::Idle" is called
+//	to signify that we should idle the CPU until the next I/O interrupt
+//	occurs (the only thing that could cause a thread to become
+//	ready to run).
+//
+//	NOTE: we assume interrupts are already disabled, because it
+//	is called from the synchronization routines which must
+//	disable interrupts for atomicity.   We need interrupts off
+//	so that there can't be a time slice between pulling the first thread
+//	off the ready list, and switching to it.
+//----------------------------------------------------------------------
+void Thread::Sleep(bool finishing) {
+    Thread *nextThread;
+
+    ASSERT(this == kernel->currentThread);
+    ASSERT(kernel->interrupt->getLevel() == IntOff);
+
+    DEBUG(dbgThread, "Sleeping thread: " << name);
+
+    status = BLOCKED;
+    while ((nextThread = kernel->scheduler->FindNextToRun()) == NULL)
+        kernel->interrupt->Idle();  // no one to run, wait for an interrupt
+
+    // returns when it's time for us to run
+    kernel->scheduler->Run(nextThread, finishing);
+}
+
+//----------------------------------------------------------------------
+// ThreadBegin, ThreadFinish,  ThreadPrint
+//	Dummy functions because C++ does not (easily) allow pointers to member
+//	functions.  So we create a dummy C function
+//	(which we can pass a pointer to), that then simply calls the
+//	member function.
+//----------------------------------------------------------------------
+
+static void ThreadFinish() { kernel->currentThread->Finish(); }
+static void ThreadBegin() { kernel->currentThread->Begin(); }
+void ThreadPrint(Thread *t) { t->Print(); }
+
+#ifdef PARISC
+
+//----------------------------------------------------------------------
+// PLabelToAddr
+//	On HPUX, function pointers don't always directly point to code,
+//	so we need to do the conversion.
+//----------------------------------------------------------------------
+
+static void *PLabelToAddr(void *plabel) {
+    int funcPtr = (int)plabel;
+
+    if (funcPtr & 0x02) {
+        // L-Field is set.  This is a PLT pointer
+        funcPtr -= 2;  // Get rid of the L bit
+        return (*(void **)funcPtr);
+    } else {
+        // L-field not set.
+        return plabel;
+    }
+}
+#endif
+
+//----------------------------------------------------------------------
+// Thread::StackAllocate
+//	Allocate and initialize an execution stack.  The stack is
+//	initialized with an initial stack frame for ThreadRoot, which:
+//		enables interrupts
+//		calls (*func)(arg)
+//		calls Thread::Finish
+//
+//	"func" is the procedure to be forked
+//	"arg" is the parameter to be passed to the procedure
+//----------------------------------------------------------------------
+
+void Thread::StackAllocate(VoidFunctionPtr func, void *arg) {
+    stack = (int *)AllocBoundedArray(StackSize * sizeof(int));
+
+#ifdef PARISC
+    // HP stack works from low addresses to high addresses
+    // everyone else works the other way: from high addresses to low addresses
+    stackTop = stack + 16;  // HP requires 64-byte frame marker
+    stack[StackSize - 1] = STACK_FENCEPOST;
+#endif
+
+#ifdef SPARC
+    stackTop = stack + StackSize - 96;  // SPARC stack must contains at
+                                        // least 1 activation record
+                                        // to start with.
+    *stack = STACK_FENCEPOST;
+#endif
+
+#ifdef PowerPC                          // RS6000
+    stackTop = stack + StackSize - 16;  // RS6000 requires 64-byte frame marker
+    *stack = STACK_FENCEPOST;
+#endif
+
+#ifdef DECMIPS
+    stackTop = stack + StackSize - 4;  // -4 to be on the safe side!
+    *stack = STACK_FENCEPOST;
+#endif
+
+#ifdef ALPHA
+    stackTop = stack + StackSize - 8;  // -8 to be on the safe side!
+    *stack = STACK_FENCEPOST;
+#endif
+
+#ifdef x86
+    // the x86 passes the return address on the stack.  In order for SWITCH()
+    // to go to ThreadRoot when we switch to this thread, the return addres
+    // used in SWITCH() must be the starting address of ThreadRoot.
+    stackTop = stack + StackSize - 4;  // -4 to be on the safe side!
+    *(--stackTop) = (int)ThreadRoot;
+    *stack = STACK_FENCEPOST;
+#endif
+
+#ifdef PARISC
+    machineState[PCState] = PLabelToAddr(ThreadRoot);
+    machineState[StartupPCState] = PLabelToAddr(ThreadBegin);
+    machineState[InitialPCState] = PLabelToAddr(func);
+    machineState[InitialArgState] = arg;
+    machineState[WhenDonePCState] = PLabelToAddr(ThreadFinish);
+#else
+    machineState[PCState] = (void *)ThreadRoot;
+    machineState[StartupPCState] = (void *)ThreadBegin;
+    machineState[InitialPCState] = (void *)func;
+    machineState[InitialArgState] = (void *)arg;
+    machineState[WhenDonePCState] = (void *)ThreadFinish;
+#endif
+}
+
+#include "machine.h"
+
+//----------------------------------------------------------------------
+// Thread::SaveUserState
+//	Save the CPU state of a user program on a context switch.
+//
+//	Note that a user program thread has *two* sets of CPU registers --
+//	one for its state while executing user code, one for its state
+//	while executing kernel code.  This routine saves the former.
+//----------------------------------------------------------------------
+
+void Thread::SaveUserState() {
+    for (int i = 0; i < NumTotalRegs; i++)
+        userRegisters[i] = kernel->machine->ReadRegister(i);
+}
+
+//----------------------------------------------------------------------
+// Thread::RestoreUserState
+//	Restore the CPU state of a user program on a context switch.
+//
+//	Note that a user program thread has *two* sets of CPU registers --
+//	one for its state while executing user code, one for its state
+//	while executing kernel code.  This routine restores the former.
+//----------------------------------------------------------------------
+
+void Thread::RestoreUserState() {
+    for (int i = 0; i < NumTotalRegs; i++)
+        kernel->machine->WriteRegister(i, userRegisters[i]);
+}
+
+//----------------------------------------------------------------------
+// SimpleThread
+// 	Loop 5 times, yielding the CPU to another ready thread
+//	each iteration.
+//
+//	"which" is simply a number identifying the thread, for debugging
+//	purposes.
+//----------------------------------------------------------------------
+
+static void SimpleThread(int which) {
+    int num;
+
+    for (num = 0; num < 5; num++) {
+        cout << "*** thread " << which << " looped " << num << " times\n";
+        kernel->currentThread->Yield();
+    }
+}
+
+//----------------------------------------------------------------------
+// Thread::SelfTest
+// 	Set up a ping-pong between two threads, by forking a thread
+//	to call SimpleThread, and then calling SimpleThread ourselves.
+//----------------------------------------------------------------------
+
+void Thread::SelfTest() {
+    DEBUG(dbgThread, "Entering Thread::SelfTest");
+
+    Thread *t = new Thread("forked thread");
+
+    t->Fork((VoidFunctionPtr)SimpleThread, (void *)1);
+    kernel->currentThread->Yield();
+    SimpleThread(0);
+}
diff --git a/code/threads/thread.h b/code/threads/thread.h
new file mode 100644
index 0000000..3fbf156
--- /dev/null
+++ b/code/threads/thread.h
@@ -0,0 +1,156 @@
+// thread.h
+//	Data structures for managing threads.  A thread represents
+//	sequential execution of code within a program.
+//	So the state of a thread includes the program counter,
+//	the processor registers, and the execution stack.
+//
+// 	Note that because we allocate a fixed size stack for each
+//	thread, it is possible to overflow the stack -- for instance,
+//	by recursing to too deep a level.  The most common reason
+//	for this occuring is allocating large data structures
+//	on the stack.  For instance, this will cause problems:
+//
+//		void foo() { int buf[1000]; ...}
+//
+//	Instead, you should allocate all data structures dynamically:
+//
+//		void foo() { int *buf = new int[1000]; ...}
+//
+//
+// 	Bad things happen if you overflow the stack, and in the worst
+//	case, the problem may not be caught explicitly.  Instead,
+//	the only symptom may be bizarre segmentation faults.  (Of course,
+//	other problems can cause seg faults, so that isn't a sure sign
+//	that your thread stacks are too small.)
+//
+//	One thing to try if you find yourself with seg faults is to
+//	increase the size of thread stack -- ThreadStackSize.
+//
+//  	In this interface, forking a thread takes two steps.
+//	We must first allocate a data structure for it: "t = new Thread".
+//	Only then can we do the fork: "t->fork(f, arg)".
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef THREAD_H
+#define THREAD_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "sysdep.h"
+
+#include "machine.h"
+#include "addrspace.h"
+
+// CPU register state to be saved on context switch.
+// The x86 needs to save only a few registers,
+// SPARC and MIPS needs to save 10 registers,
+// the Snake needs 18,
+// and the RS6000 needs to save 75 (!)
+// For simplicity, I just take the maximum over all architectures.
+
+#define MachineStateSize 75
+
+// Size of the thread's private execution stack.
+// WATCH OUT IF THIS ISN'T BIG ENOUGH!!!!!
+const int StackSize = (8 * 1024);  // in words
+
+// Thread state
+enum ThreadStatus { JUST_CREATED, RUNNING, READY, BLOCKED };
+
+// The following class defines a "thread control block" -- which
+// represents a single thread of execution.
+//
+//  Every thread has:
+//     an execution stack for activation records ("stackTop" and "stack")
+//     space to save CPU registers while not running ("machineState")
+//     a "status" (running/ready/blocked)
+//
+//  Some threads also belong to a user address space; threads
+//  that only run in the kernel have a NULL address space.
+
+class Thread {
+   private:
+    // NOTE: DO NOT CHANGE the order of these first two members.
+    // THEY MUST be in this position for SWITCH to work.
+    int *stackTop;                         // the current stack pointer
+    void *machineState[MachineStateSize];  // all registers except for stackTop
+    bool has_dynamic_name;  // true if the thread name is dynamically allocated
+
+   public:
+    Thread(char *debugName,
+           bool _has_dynamic_name = false);  // initialize a Thread
+    ~Thread();                               // deallocate a Thread
+                                             // NOTE -- thread being deleted
+                                             // must not be running when delete
+                                             // is called
+
+    int processID;
+    int parrentID;
+    int exitStatus;
+    void FreeSpace() {
+        if (space != 0) delete space;
+    }
+
+    // basic thread operations
+
+    void Fork(VoidFunctionPtr func, void *arg);
+    // Make thread run (*func)(arg)
+    void Yield();                // Relinquish the CPU if any
+                                 // other thread is runnable
+    void Sleep(bool finishing);  // Put the thread to sleep and
+                                 // relinquish the processor
+    void Begin();                // Startup code for the thread
+    void Finish();               // The thread is done executing
+
+    void CheckOverflow();  // Check if thread stack has overflowed
+    void setStatus(ThreadStatus st) { status = st; }
+    char *getName() { return (name); }
+    void Print() { cout << name; }
+    void SelfTest();  // test whether thread impl is working
+
+   private:
+    // some of the private data for this class is listed above
+
+    int *stack;           // Bottom of the stack
+                          // NULL if this is the main thread
+                          // (If NULL, don't deallocate stack)
+    ThreadStatus status;  // ready, running or blocked
+    char *name;
+
+    void StackAllocate(VoidFunctionPtr func, void *arg);
+    // Allocate a stack for thread.
+    // Used internally by Fork()
+
+    // A thread running a user program actually has *two* sets of CPU registers
+    // -- one for its state while executing user code, one for its state while
+    // executing kernel code.
+
+    int userRegisters[NumTotalRegs];  // user-level CPU register state
+
+   public:
+    void SaveUserState();     // save user-level register state
+    void RestoreUserState();  // restore user-level register state
+
+    AddrSpace *space;  // User code this thread is running.
+};
+
+// external function, dummy routine whose sole job is to call Thread::Print
+extern void ThreadPrint(Thread *thread);
+
+// Magical machine-dependent routines, defined in switch.s
+
+extern "C" {
+// First frame on thread execution stack;
+//   	call ThreadBegin
+//	call "func"
+//	(when func returns, if ever) call ThreadFinish()
+void ThreadRoot();
+
+// Stop running oldThread and start running newThread
+void SWITCH(Thread *oldThread, Thread *newThread);
+}
+
+#endif  // THREAD_H
diff --git a/code/userprog/addrspace.cc b/code/userprog/addrspace.cc
new file mode 100644
index 0000000..0002d39
--- /dev/null
+++ b/code/userprog/addrspace.cc
@@ -0,0 +1,311 @@
+// addrspace.cc
+//	Routines to manage address spaces (executing user programs).
+//
+//	In order to run a user program, you must:
+//
+//	1. link with the -n -T 0 option
+//	2. run coff2noff to convert the object file to Nachos format
+//		(Nachos object code format is essentially just a simpler
+//		version of the UNIX executable object code format)
+//	3. load the NOFF file into the Nachos file system
+//		(if you are using the "stub" file system, you
+//		don't need to do this last step)
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "main.h"
+#include "addrspace.h"
+#include "machine.h"
+#include "noff.h"
+#include "synch.h"
+
+//----------------------------------------------------------------------
+// SwapHeader
+// 	Do little endian to big endian conversion on the bytes in the
+//	object file header, in case the file was generated on a little
+//	endian machine, and we're now running on a big endian machine.
+//----------------------------------------------------------------------
+
+static void SwapHeader(NoffHeader *noffH) {
+    noffH->noffMagic = WordToHost(noffH->noffMagic);
+    noffH->code.size = WordToHost(noffH->code.size);
+    noffH->code.virtualAddr = WordToHost(noffH->code.virtualAddr);
+    noffH->code.inFileAddr = WordToHost(noffH->code.inFileAddr);
+#ifdef RDATA
+    noffH->readonlyData.size = WordToHost(noffH->readonlyData.size);
+    noffH->readonlyData.virtualAddr =
+        WordToHost(noffH->readonlyData.virtualAddr);
+    noffH->readonlyData.inFileAddr = WordToHost(noffH->readonlyData.inFileAddr);
+#endif
+    noffH->initData.size = WordToHost(noffH->initData.size);
+    noffH->initData.virtualAddr = WordToHost(noffH->initData.virtualAddr);
+    noffH->initData.inFileAddr = WordToHost(noffH->initData.inFileAddr);
+    noffH->uninitData.size = WordToHost(noffH->uninitData.size);
+    noffH->uninitData.virtualAddr = WordToHost(noffH->uninitData.virtualAddr);
+    noffH->uninitData.inFileAddr = WordToHost(noffH->uninitData.inFileAddr);
+
+#ifdef RDATA
+    DEBUG(dbgAddr, "code = " << noffH->code.size
+                             << " readonly = " << noffH->readonlyData.size
+                             << " init = " << noffH->initData.size
+                             << " uninit = " << noffH->uninitData.size << "\n");
+#endif
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::AddrSpace
+// 	Create an address space to run a user program.
+//	Set up the translation from program memory to physical
+//	memory.  For now, this is really simple (1:1), since we are
+//	only uniprogramming, and we have a single unsegmented page table
+//----------------------------------------------------------------------
+
+AddrSpace::AddrSpace() {
+    // pageTable = new TranslationEntry[NumPhysPages];
+    // for (int i = 0; i < NumPhysPages; i++) {
+    //     pageTable[i].virtualPage = i;  // for now, virt page # = phys page #
+    //     pageTable[i].physicalPage = i;
+    //     pageTable[i].valid = TRUE;
+    //     pageTable[i].use = FALSE;
+    //     pageTable[i].dirty = FALSE;
+    //     pageTable[i].readOnly = FALSE;
+    // }
+
+    // // zero out the entire address space
+    // bzero(kernel->machine->mainMemory, MemorySize);
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::~AddrSpace
+// 	Dealloate an address space.
+//----------------------------------------------------------------------
+
+AddrSpace::~AddrSpace() {
+    int i;
+    for (i = 0; i < numPages; i++) {
+        kernel->gPhysPageBitMap->Clear(pageTable[i].physicalPage);
+    }
+    delete[] pageTable;
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::Load
+// 	Load a user program into memory from a file.
+//
+//	Assumes that the page table has been initialized, and that
+//	the object code file is in NOFF format.
+//
+//	"fileName" is the file containing the object code to load into memory
+//----------------------------------------------------------------------
+
+AddrSpace::AddrSpace(char *fileName) {
+    OpenFile *executable = kernel->fileSystem->Open(fileName);
+    NoffHeader noffH;
+    unsigned int i, size, j, offset;
+    unsigned int numCodePage,
+        numDataPage;  // s trang cho phn code v phn initData
+    int lastCodePageSize, lastDataPageSize, firstDataPageSize,
+        tempDataSize;  // kch thc ghi vo trang cui Code, initData, v trang
+                       // u ca initData
+
+    if (executable == NULL) {
+        DEBUG(dbgFile, "\n Error opening file.");
+        return;
+    }
+    //c header ca file
+    executable->ReadAt((char *)&noffH, sizeof(noffH), 0);
+    if ((noffH.noffMagic != NOFFMAGIC) &&
+        (WordToHost(noffH.noffMagic) == NOFFMAGIC))
+        SwapHeader(&noffH);
+    ASSERT(noffH.noffMagic == NOFFMAGIC);
+    kernel->addrLock->P();
+    // how big is address space?
+    size = noffH.code.size + noffH.initData.size + noffH.uninitData.size +
+           UserStackSize;  // we need to increase the size
+                           // to leave room for the stack
+    numPages = divRoundUp(size, PageSize);
+    size = numPages * PageSize;
+
+    ASSERT(numPages <= NumPhysPages);  // check we're not trying
+                                       // to run anything too big --
+                                       // at least until we have
+                                       // virtual memory
+
+    // Check the available memory enough to load new process
+    // debug
+    if (numPages > kernel->gPhysPageBitMap->NumClear()) {
+        DEBUG(dbgAddr, "Not enough free space");
+        numPages = 0;
+        delete executable;
+        kernel->addrLock->V();
+        return;
+    }
+    DEBUG(dbgAddr, "Initializing address space: " << numPages << ", " << size);
+    // first, set up the translation
+    pageTable = new TranslationEntry[numPages];
+    for (i = 0; i < numPages; i++) {
+        pageTable[i].virtualPage = i;  // for now, virtual page # = phys page #
+        pageTable[i].physicalPage = kernel->gPhysPageBitMap->FindAndSet();
+        // cerr << pageTable[i].physicalPage << endl;
+        pageTable[i].valid = TRUE;
+        pageTable[i].use = FALSE;
+        pageTable[i].dirty = FALSE;
+        pageTable[i].readOnly = FALSE;  // if the code segment was entirely on
+        // a separate page, we could set its
+        // pages to be read-only
+        // xa cc trang ny trn memory
+        bzero(&(kernel->machine
+                    ->mainMemory[pageTable[i].physicalPage * PageSize]),
+              PageSize);
+        DEBUG(dbgAddr, "phyPage " << pageTable[i].physicalPage);
+    }
+
+    if (noffH.code.size > 0) {
+        for (i = 0; i < numPages; i++)
+            executable->ReadAt(
+                &(kernel->machine->mainMemory[noffH.code.virtualAddr]) +
+                    (pageTable[i].physicalPage * PageSize),
+                PageSize, noffH.code.inFileAddr + (i * PageSize));
+    }
+
+    if (noffH.initData.size > 0) {
+        for (i = 0; i < numPages; i++)
+            executable->ReadAt(
+                &(kernel->machine->mainMemory[noffH.initData.virtualAddr]) +
+                    (pageTable[i].physicalPage * PageSize),
+                PageSize, noffH.initData.inFileAddr + (i * PageSize));
+    }
+
+    kernel->addrLock->V();
+    delete executable;
+    return;
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::Execute
+// 	Run a user program using the current thread
+//
+//      The program is assumed to have already been loaded into
+//      the address space
+//
+//----------------------------------------------------------------------
+
+void AddrSpace::Execute() {
+    kernel->currentThread->space = this;
+
+    this->InitRegisters();  // set the initial register values
+    this->RestoreState();   // load page table register
+
+    kernel->machine->Run();  // jump to the user progam
+
+    ASSERTNOTREACHED();  // machine->Run never returns;
+                         // the address space exits
+                         // by doing the syscall "exit"
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::InitRegisters
+// 	Set the initial values for the user-level register set.
+//
+// 	We write these directly into the "machine" registers, so
+//	that we can immediately jump to user code.  Note that these
+//	will be saved/restored into the currentThread->userRegisters
+//	when this thread is context switched out.
+//----------------------------------------------------------------------
+
+void AddrSpace::InitRegisters() {
+    Machine *machine = kernel->machine;
+    int i;
+
+    for (i = 0; i < NumTotalRegs; i++) machine->WriteRegister(i, 0);
+
+    // Initial program counter -- must be location of "Start", which
+    //  is assumed to be virtual address zero
+    machine->WriteRegister(PCReg, 0);
+
+    // Need to also tell MIPS where next instruction is, because
+    // of branch delay possibility
+    // Since instructions occupy four bytes each, the next instruction
+    // after start will be at virtual address four.
+    machine->WriteRegister(NextPCReg, 4);
+
+    // Set the stack register to the end of the address space, where we
+    // allocated the stack; but subtract off a bit, to make sure we don't
+    // accidentally reference off the end!
+    machine->WriteRegister(StackReg, numPages * PageSize - 16);
+    DEBUG(dbgAddr, "Initializing stack pointer: " << numPages * PageSize - 16);
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::SaveState
+// 	On a context switch, save any machine state, specific
+//	to this address space, that needs saving.
+//
+//	For now, don't need to save anything!
+//----------------------------------------------------------------------
+
+void AddrSpace::SaveState() {}
+
+//----------------------------------------------------------------------
+// AddrSpace::RestoreState
+// 	On a context switch, restore the machine state so that
+//	this address space can run.
+//
+//      For now, tell the machine where to find the page table.
+//----------------------------------------------------------------------
+
+void AddrSpace::RestoreState() {
+    kernel->machine->pageTable = pageTable;
+    kernel->machine->pageTableSize = numPages;
+}
+
+//----------------------------------------------------------------------
+// AddrSpace::Translate
+//  Translate the virtual address in _vaddr_ to a physical address
+//  and store the physical address in _paddr_.
+//  The flag _isReadWrite_ is false (0) for read-only access; true (1)
+//  for read-write access.
+//  Return any exceptions caused by the address translation.
+//----------------------------------------------------------------------
+ExceptionType AddrSpace::Translate(unsigned int vaddr, unsigned int *paddr,
+                                   int isReadWrite) {
+    TranslationEntry *pte;
+    int pfn;
+    unsigned int vpn = vaddr / PageSize;
+    unsigned int offset = vaddr % PageSize;
+
+    if (vpn >= numPages) {
+        return AddressErrorException;
+    }
+
+    pte = &pageTable[vpn];
+
+    if (isReadWrite && pte->readOnly) {
+        return ReadOnlyException;
+    }
+
+    pfn = pte->physicalPage;
+
+    // if the pageFrame is too big, there is something really wrong!
+    // An invalid translation was loaded into the page table or TLB.
+    if (pfn >= NumPhysPages) {
+        DEBUG(dbgAddr, "Illegal physical page " << pfn);
+        return BusErrorException;
+    }
+
+    pte->use = TRUE;  // set the use, dirty bits
+
+    if (isReadWrite) pte->dirty = TRUE;
+
+    *paddr = pfn * PageSize + offset;
+
+    ASSERT((*paddr < MemorySize));
+
+    // cerr << " -- AddrSpace::Translate(): vaddr: " << vaddr <<
+    //  ", paddr: " << *paddr << "\n";
+
+    return NoException;
+}
diff --git a/code/userprog/addrspace.h b/code/userprog/addrspace.h
new file mode 100644
index 0000000..eb40a1a
--- /dev/null
+++ b/code/userprog/addrspace.h
@@ -0,0 +1,50 @@
+// addrspace.h
+//	Data structures to keep track of executing user programs
+//	(address spaces).
+//
+//	For now, we don't keep any information about address spaces.
+//	The user level CPU state is saved and restored in the thread
+//	executing the user program (see thread.h).
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef ADDRSPACE_H
+#define ADDRSPACE_H
+
+#include "copyright.h"
+#include "filesys.h"
+
+#define UserStackSize 1024  // increase this as necessary!
+
+class AddrSpace {
+   public:
+    AddrSpace();                // Create an address space.
+    AddrSpace(char *fileName);  // Load a program into addr space from
+                                // a file
+    ~AddrSpace();               // De-allocate an address space
+
+    void Execute();  // Run a program
+                     // assumes the program has already
+                     // been loaded
+
+    void SaveState();     // Save/restore address space-specific
+    void RestoreState();  // info on a context switch
+
+    // Translate virtual address _vaddr_
+    // to physical address _paddr_. _mode_
+    // is 0 for Read, 1 for Write.
+    ExceptionType Translate(unsigned int vaddr, unsigned int *paddr, int mode);
+    // void InitRegisters();
+   private:
+    TranslationEntry *pageTable;  // Assume linear page table translation
+                                  // for now!
+    unsigned int numPages;        // Number of pages in the virtual
+                                  // address space
+
+    void InitRegisters();  // Initialize user-level CPU registers,
+                           // before jumping to user code
+};
+
+#endif  // ADDRSPACE_H
diff --git a/code/userprog/errno.h b/code/userprog/errno.h
new file mode 100644
index 0000000..63bfc98
--- /dev/null
+++ b/code/userprog/errno.h
@@ -0,0 +1,84 @@
+/* errno.h
+ *	Error codes for system calls.
+ *
+ *	Do not modify the contents of this file.
+ *
+ *	Try to use the most descriptive error number for the error.
+ *      You may find it helpful to see what errors equivalent UNIX
+ *      system calls return under various error conditions.
+ *      For example the man page for the write system call "man 2 write"
+ *      provides a list of different error number values for different
+ *      conditions.
+ *      NOTE: there are way more errors here than you should be supporting
+ *            and many more error conditions listed in man pages than
+ *            Nachos can possibly generate. The list here is to give you
+ *            some ideas and to hopefully standardize on some error numbers.
+ *
+ *      ALSO NOTE: These definitions may not correspond to Solaris definitions
+ *      (for copyright reasons these are taken from Linux).
+ */
+
+#ifndef ERRNO_H
+#define ERRNO_H
+
+#include "copyright.h"
+
+#define EPERM -1           /* Operation not permitted */
+#define ENOENT -2          /* No such file or directory */
+#define ESRCH -3           /* No such process */
+#define EINTR -4           /* Interrupted system call */
+#define EIO -5             /* I/O error */
+#define ENXIO -6           /* No such device or address */
+#define E2BIG -7           /* Arg list too long */
+#define ENOEXEC -8         /* Exec format error */
+#define EBADF -9           /* Bad file number */
+#define ECHILD -10         /* No child processes */
+#define EAGAIN -11         /* Try again */
+#define ENOMEM -12         /* Out of memory */
+#define EACCES -13         /* Permission denied */
+#define EFAULT -14         /* Bad address */
+#define ENOTBLK -15        /* Block device required */
+#define EBUSY -16          /* Device or resource busy */
+#define EEXIST -17         /* File exists */
+#define EXDEV -18          /* Cross-device link */
+#define ENODEV -19         /* No such device */
+#define ENOTDIR -20        /* Not a directory */
+#define EISDIR -21         /* Is a directory */
+#define EINVAL -22         /* Invalid argument */
+#define ENFILE -23         /* File table overflow */
+#define EMFILE -24         /* Too many open files */
+#define ENOTTY -25         /* Not a typewriter */
+#define ETXTBSY -26        /* Text file busy */
+#define EFBIG -27          /* File too large */
+#define ENOSPC -28         /* No space left on device */
+#define ESPIPE -29         /* Illegal seek */
+#define EROFS -30          /* Read-only file system */
+#define EMLINK -31         /* Too many links */
+#define EPIPE -32          /* Broken pipe */
+#define EDOM -33           /* Math argument out of domain of func */
+#define ERANGE -34         /* Math result not representable */
+#define EDEADLK -35        /* Resource deadlock would occur */
+#define ENAMETOOLONG -36   /* File name too long */
+#define ENOLCK -37         /* No record locks available */
+#define ENOSYS -38         /* Function not implemented */
+#define ENOTEMPTY -39      /* Directory not empty */
+#define ELOOP -40          /* Too many symbolic links encountered */
+#define EWOULDBLOCK EAGAIN /* Operation would block */
+#define ENOMSG -42         /* No message of desired type */
+#define EIDRM -43          /* Identifier removed */
+#define ECHRNG -44         /* Channel number out of range */
+#define EL2NSYNC -45       /* Level 2 not synchronized */
+#define EL3HLT -46         /* Level 3 halted */
+#define EL3RST -47         /* Level 3 reset */
+#define ELNRNG -48         /* Link number out of range */
+#define EUNATCH -49        /* Protocol driver not attached */
+#define ENOCSI -50         /* No CSI structure available */
+#define EL2HLT -51         /* Level 2 halted */
+#define EBADE -52          /* Invalid exchange */
+#define EBADR -53          /* Invalid request descriptor */
+#define EXFULL -54         /* Exchange full */
+#define ENOANO -55         /* No anode */
+#define EBADRQC -56        /* Invalid request code */
+#define EBADSLT -57        /* Invalid slot */
+
+#endif  // ERRNO_H
diff --git a/code/userprog/exception.cc b/code/userprog/exception.cc
new file mode 100644
index 0000000..8514f06
--- /dev/null
+++ b/code/userprog/exception.cc
@@ -0,0 +1,508 @@
+// exception.cc
+//	Entry point into the Nachos kernel from user programs.
+//	There are two kinds of things that can cause control to
+//	transfer back to here from user code:
+//
+//	syscall -- The user code explicitly requests to call a procedure
+//	in the Nachos kernel.  Right now, the only function we support is
+//	"Halt".
+//
+//	exceptions -- The user code does something that the CPU can't handle.
+//	For instance, accessing memory that doesn't exist, arithmetic errors,
+//	etc.
+//
+//	Interrupts (which can also cause control to transfer from user
+//	code into the Nachos kernel) are handled elsewhere.
+//
+// For now, this only handles the Halt() system call.
+// Everything else core dumps.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "main.h"
+#include "syscall.h"
+#include "ksyscall.h"
+//----------------------------------------------------------------------
+// ExceptionHandler
+// 	Entry point into the Nachos kernel.  Called when a user program
+//	is executing, and either does a syscall, or generates an addressing
+//	or arithmetic exception.
+//
+// 	For system calls, the following is the calling convention:
+//
+// 	system call code -- r2
+//		arg1 -- r4
+//		arg2 -- r5
+//		arg3 -- r6
+//		arg4 -- r7
+//
+//	The result of the system call, if any, must be put back into r2.
+//
+// If you are handling a system call, don't forget to increment the pc
+// before returning (by calling move_program_counter()). (Or else you'll loop
+// making the same system call forever!)
+//
+//	"which" is the kind of exception.  The list of possible exceptions
+//	is in machine.h.
+//----------------------------------------------------------------------
+
+/**
+ * @brief Convert user string to system string
+ *
+ * @param addr addess of user string
+ * @param convert_length set max length of string to convert, leave
+ * blank to convert all characters of user string
+ * @return char*
+ */
+char* stringUser2System(int addr, int convert_length = -1) {
+    int length = 0;
+    bool stop = false;
+    char* str;
+
+    do {
+        int oneChar;
+        kernel->machine->ReadMem(addr + length, 1, &oneChar);
+        length++;
+        // if convert_length == -1, we use '\0' to terminate the process
+        // otherwise, we use convert_length to terminate the process
+        stop = ((oneChar == '\0' && convert_length == -1) ||
+                length == convert_length);
+    } while (!stop);
+
+    str = new char[length];
+    for (int i = 0; i < length; i++) {
+        int oneChar;
+        kernel->machine->ReadMem(addr + i, 1,
+                                 &oneChar);  // copy characters to kernel space
+        str[i] = (unsigned char)oneChar;
+    }
+    return str;
+}
+
+/**
+ * @brief Convert system string to user string
+ *
+ * @param str string to convert
+ * @param addr addess of user string
+ * @param convert_length set max length of string to convert, leave
+ * blank to convert all characters of system string
+ * @return void
+ */
+void StringSys2User(char* str, int addr, int convert_length = -1) {
+    int length = (convert_length == -1 ? strlen(str) : convert_length);
+    for (int i = 0; i < length; i++) {
+        kernel->machine->WriteMem(addr + i, 1,
+                                  str[i]);  // copy characters to user space
+    }
+    kernel->machine->WriteMem(addr + length, 1, '\0');
+}
+
+/**
+ * Modify program counter
+ * This code is adapted from `../machine/mipssim.cc`, line 667
+ **/
+void move_program_counter() {
+    /* set previous programm counter (debugging only)
+     * similar to: registers[PrevPCReg] = registers[PCReg];*/
+    kernel->machine->WriteRegister(PrevPCReg,
+                                   kernel->machine->ReadRegister(PCReg));
+
+    /* set programm counter to next instruction
+     * similar to: registers[PCReg] = registers[NextPCReg]*/
+    kernel->machine->WriteRegister(PCReg,
+                                   kernel->machine->ReadRegister(NextPCReg));
+
+    /* set next programm counter for brach execution
+     * similar to: registers[NextPCReg] = pcAfter;*/
+    kernel->machine->WriteRegister(
+        NextPCReg, kernel->machine->ReadRegister(NextPCReg) + 4);
+}
+
+/**
+ * Handle not implemented syscall
+ * This method will write the syscall to debug log and increase
+ * the program counter.
+ */
+void handle_not_implemented_SC(int type) {
+    DEBUG(dbgSys, "Not yet implemented syscall " << type << "\n");
+    return move_program_counter();
+}
+
+void handle_SC_Halt() {
+    DEBUG(dbgSys, "Shutdown, initiated by user program.\n");
+    SysHalt();
+    ASSERTNOTREACHED();
+}
+
+void handle_SC_Add() {
+    DEBUG(dbgSys, "Add " << kernel->machine->ReadRegister(4) << " + "
+                         << kernel->machine->ReadRegister(5) << "\n");
+
+    /* Process SysAdd Systemcall*/
+    int result;
+    result = SysAdd(
+        /* int op1 */ (int)kernel->machine->ReadRegister(4),
+        /* int op2 */ (int)kernel->machine->ReadRegister(5));
+
+    DEBUG(dbgSys, "Add returning with " << result << "\n");
+    /* Prepare Result */
+    kernel->machine->WriteRegister(2, (int)result);
+
+    return move_program_counter();
+}
+
+void handle_SC_Abs() {
+    DEBUG(dbgSys, "Abs " << kernel->machine->ReadRegister(4) << " + "
+                         << kernel->machine->ReadRegister(5) << "\n");
+
+    /* Process SysAdd Systemcall*/
+    int result;
+    result = SysAbs(
+        /* int op1 */ (int)kernel->machine->ReadRegister(4));
+
+    DEBUG(dbgSys, "Add returning with " << result << "\n");
+    /* Prepare Result */
+    kernel->machine->WriteRegister(2, (int)result);
+
+    return move_program_counter();
+}
+
+void handle_SC_ReadNum() {
+    int result = SysReadNum();
+    kernel->machine->WriteRegister(2, result);
+    return move_program_counter();
+}
+
+void handle_SC_PrintNum() {
+    int character = kernel->machine->ReadRegister(4);
+    SysPrintNum(character);
+    return move_program_counter();
+}
+
+void handle_SC_ReadChar() {
+    char result = SysReadChar();
+    kernel->machine->WriteRegister(2, (int)result);
+    return move_program_counter();
+}
+
+void handle_SC_PrintChar() {
+    char character = (char)kernel->machine->ReadRegister(4);
+    SysPrintChar(character);
+    return move_program_counter();
+}
+
+void handle_SC_RandomNum() {
+    int result;
+    result = SysRandomNum();
+    kernel->machine->WriteRegister(2, result);
+    return move_program_counter();
+}
+
+#define MAX_READ_STRING_LENGTH 255
+void handle_SC_ReadString() {
+    int memPtr = kernel->machine->ReadRegister(4);  // read address of C-string
+    int length = kernel->machine->ReadRegister(5);  // read length of C-string
+    if (length > MAX_READ_STRING_LENGTH) {  // avoid allocating large memory
+        DEBUG(dbgSys, "String length exceeds " << MAX_READ_STRING_LENGTH);
+        SysHalt();
+    }
+    char* buffer = SysReadString(length);
+    StringSys2User(buffer, memPtr);
+    delete[] buffer;
+    return move_program_counter();
+}
+
+void handle_SC_PrintString() {
+    int memPtr = kernel->machine->ReadRegister(4);  // read address of C-string
+    char* buffer = stringUser2System(memPtr);
+
+    SysPrintString(buffer, strlen(buffer));
+    delete[] buffer;
+    return move_program_counter();
+}
+
+void handle_SC_CreateFile() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+    char* fileName = stringUser2System(virtAddr);
+
+    if (SysCreateFile(fileName))
+        kernel->machine->WriteRegister(2, 0);
+    else
+        kernel->machine->WriteRegister(2, -1);
+
+    delete[] fileName;
+    return move_program_counter();
+}
+
+void handle_SC_Open() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+    char* fileName = stringUser2System(virtAddr);
+    int type = kernel->machine->ReadRegister(5);
+
+    kernel->machine->WriteRegister(2, SysOpen(fileName, type));
+
+    delete fileName;
+    return move_program_counter();
+}
+
+void handle_SC_Close() {
+    int id = kernel->machine->ReadRegister(4);
+    kernel->machine->WriteRegister(2, SysClose(id));
+
+    return move_program_counter();
+}
+
+void handle_SC_Read() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+    int charCount = kernel->machine->ReadRegister(5);
+    char* buffer = stringUser2System(virtAddr, charCount);
+    int fileId = kernel->machine->ReadRegister(6);
+
+    DEBUG(dbgFile,
+          "Read " << charCount << " chars from file " << fileId << "\n");
+
+    kernel->machine->WriteRegister(2, SysRead(buffer, charCount, fileId));
+    StringSys2User(buffer, virtAddr, charCount);
+
+    delete[] buffer;
+    return move_program_counter();
+}
+
+void handle_SC_Write() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+    int charCount = kernel->machine->ReadRegister(5);
+    char* buffer = stringUser2System(virtAddr, charCount);
+    int fileId = kernel->machine->ReadRegister(6);
+
+    DEBUG(dbgFile,
+          "Write " << charCount << " chars to file " << fileId << "\n");
+
+    kernel->machine->WriteRegister(2, SysWrite(buffer, charCount, fileId));
+    StringSys2User(buffer, virtAddr, charCount);
+
+    delete[] buffer;
+    return move_program_counter();
+}
+
+/**
+ * Handle SC_Seek
+ * This method will seek the file to the given position.
+ * @param seekPos: seek position (use -1 to seek to end of file) (get from R4)
+ * @param fileId: file descriptor (get from R5)
+ * @return -1 if failed to seek, otherwise return the new position
+ */
+void handle_SC_Seek() {
+    int seekPos = kernel->machine->ReadRegister(4);
+    int fileId = kernel->machine->ReadRegister(5);
+
+    kernel->machine->WriteRegister(2, SysSeek(seekPos, fileId));
+
+    return move_program_counter();
+}
+
+/**
+ * @brief handle System Call Exec
+ * @param virtAddr: virtual address of user string name (get from R4)
+ * @return -1 if failed to Exec, otherwise return id of new process
+ * (write result to R2)
+ */
+void handle_SC_Exec() {
+    int virtAddr;
+    virtAddr = kernel->machine->ReadRegister(
+        4);  // doc dia chi ten chuong trinh tu thanh ghi r4
+    char* name;
+    name = stringUser2System(virtAddr);  // Lay ten chuong trinh, nap vao kernel
+    if (name == NULL) {
+        DEBUG(dbgSys, "\n Not enough memory in System");
+        ASSERT(false);
+        kernel->machine->WriteRegister(2, -1);
+        return move_program_counter();
+    }
+
+    kernel->machine->WriteRegister(2, SysExec(name));
+    // DO NOT DELETE NAME, THE THEARD WILL DELETE IT LATER
+    // delete[] name;
+
+    return move_program_counter();
+}
+
+/**
+ * @brief handle System Call Join
+ * @param id: thread id (get from R4)
+ * @return -1 if failed to join, otherwise return exit code of
+ * the thread. (write result to R2)
+ */
+void handle_SC_Join() {
+    int id = kernel->machine->ReadRegister(4);
+    kernel->machine->WriteRegister(2, SysJoin(id));
+    return move_program_counter();
+}
+
+/**
+ * @brief handle System Call Exit
+ * @param id: thread id (get from R4)
+ * @return -1 if failed to exit, otherwise return exit code of
+ * the thread. (write result to R2)
+ */
+void handle_SC_Exit() {
+    int id = kernel->machine->ReadRegister(4);
+    kernel->machine->WriteRegister(2, SysExit(id));
+    return move_program_counter();
+}
+
+void handle_SC_CreateSemaphore() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+    int semval = kernel->machine->ReadRegister(5);
+
+    char* name = stringUser2System(virtAddr);
+    if (name == NULL) {
+        DEBUG(dbgSys, "\n Not enough memory in System");
+        ASSERT(false);
+        kernel->machine->WriteRegister(2, -1);
+        delete[] name;
+        return move_program_counter();
+    }
+
+    kernel->machine->WriteRegister(2, SysCreateSemaphore(name, semval));
+    delete[] name;
+    return move_program_counter();
+}
+
+void handle_SC_Wait() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+
+    char* name = stringUser2System(virtAddr);
+    if (name == NULL) {
+        DEBUG(dbgSys, "\n Not enough memory in System");
+        ASSERT(false);
+        kernel->machine->WriteRegister(2, -1);
+        delete[] name;
+        return move_program_counter();
+    }
+
+    kernel->machine->WriteRegister(2, SysWait(name));
+    delete[] name;
+    return move_program_counter();
+}
+
+void handle_SC_Signal() {
+    int virtAddr = kernel->machine->ReadRegister(4);
+
+    char* name = stringUser2System(virtAddr);
+    if (name == NULL) {
+        DEBUG(dbgSys, "\n Not enough memory in System");
+        ASSERT(false);
+        kernel->machine->WriteRegister(2, -1);
+        delete[] name;
+        return move_program_counter();
+    }
+
+    kernel->machine->WriteRegister(2, SysSignal(name));
+    delete[] name;
+    return move_program_counter();
+}
+
+void handle_SC_GetPid() {
+    kernel->machine->WriteRegister(2, SysGetPid());
+    return move_program_counter();
+}
+
+void ExceptionHandler(ExceptionType which) {
+    int type = kernel->machine->ReadRegister(2);
+
+    DEBUG(dbgSys, "Received Exception " << which << " type: " << type << "\n");
+
+    switch (which) {
+        case NoException:  // return control to kernel
+            kernel->interrupt->setStatus(SystemMode);
+            DEBUG(dbgSys, "Switch to system mode\n");
+            break;
+        case PageFaultException:
+        case ReadOnlyException:
+        case BusErrorException:
+        case AddressErrorException:
+        case OverflowException:
+        case IllegalInstrException:
+        case NumExceptionTypes:
+            cerr << "Error " << which << " occurs\n";
+            SysHalt();
+            ASSERTNOTREACHED();
+
+        case SyscallException:
+            switch (type) {
+                case SC_Halt:
+                    return handle_SC_Halt();
+                case SC_Add:
+                    return handle_SC_Add();
+		case SC_Abs:
+                    return handle_SC_Abs();
+                case SC_ReadNum:
+                    return handle_SC_ReadNum();
+                case SC_PrintNum:
+                    return handle_SC_PrintNum();
+                case SC_ReadChar:
+                    return handle_SC_ReadChar();
+                case SC_PrintChar:
+                    return handle_SC_PrintChar();
+                case SC_RandomNum:
+                    return handle_SC_RandomNum();
+                case SC_ReadString:
+                    return handle_SC_ReadString();
+                case SC_PrintString:
+                    return handle_SC_PrintString();
+                case SC_CreateFile:
+                    return handle_SC_CreateFile();
+                case SC_Open:
+                    return handle_SC_Open();
+                case SC_Close:
+                    return handle_SC_Close();
+                case SC_Read:
+                    return handle_SC_Read();
+                case SC_Write:
+                    return handle_SC_Write();
+                case SC_Seek:
+                    return handle_SC_Seek();
+                case SC_Exec:
+                    return handle_SC_Exec();
+                case SC_Join:
+                    return handle_SC_Join();
+                case SC_Exit:
+                    return handle_SC_Exit();
+                case SC_CreateSemaphore:
+                    return handle_SC_CreateSemaphore();
+                case SC_Wait:
+                    return handle_SC_Wait();
+                case SC_Signal:
+                    return handle_SC_Signal();
+                case SC_GetPid:
+                    return handle_SC_GetPid();
+                /**
+                 * Handle all not implemented syscalls
+                 * If you want to write a new handler for syscall:
+                 * - Remove it from this list below
+                 * - Write handle_SC_name()
+                 * - Add new case for SC_name
+                 */
+                case SC_Create:
+                case SC_Remove:
+                case SC_ThreadFork:
+                case SC_ThreadYield:
+                case SC_ExecV:
+                case SC_ThreadExit:
+                case SC_ThreadJoin:
+                    return handle_not_implemented_SC(type);
+
+                default:
+                    cerr << "Unexpected system call " << type << "\n";
+                    break;
+            }
+            break;
+        default:
+            cerr << "Unexpected user mode exception" << (int)which << "\n";
+            break;
+    }
+    ASSERTNOTREACHED();
+}
diff --git a/code/userprog/ksyscall.h b/code/userprog/ksyscall.h
new file mode 100644
index 0000000..4401314
--- /dev/null
+++ b/code/userprog/ksyscall.h
@@ -0,0 +1,252 @@
+/**************************************************************
+ *
+ * userprog/ksyscall.h
+ *
+ * Kernel interface for systemcalls
+ *
+ * by Marcus Voelp  (c) Universitaet Karlsruhe
+ *
+ **************************************************************/
+
+#ifndef __USERPROG_KSYSCALL_H__
+#define __USERPROG_KSYSCALL_H__
+
+#include "kernel.h"
+#include "synchconsole.h"
+#include "ksyscallhelper.h"
+#include <stdlib.h>
+
+#define INT32_MIN 0
+
+void SysHalt() { kernel->interrupt->Halt(); }
+
+int SysAdd(int op1, int op2) { return op1 + op2; }
+int SysAbs(int op1) { return (op1 >0 ? op1 : -op1); }
+
+int SysReadNum() {
+    readUntilBlank();
+
+    int len = strlen(_numberBuffer);
+    // Read nothing -> return 0
+    if (len == 0) return 0;
+
+    // Check comment below to understand this line of code
+    if (strcmp(_numberBuffer, "-2147483648") == 0) return INT32_MIN;
+
+    bool nega = (_numberBuffer[0] == '-');
+    int zeros = 0;
+    bool is_leading = true;
+    int num = 0;
+    for (int i = nega; i < len; ++i) {
+        char c = _numberBuffer[i];
+        if (c == '0' && is_leading)
+            ++zeros;
+        else
+            is_leading = false;
+        if (c < '0' || c > '9') {
+            DEBUG(dbgSys, "Expected number but " << _numberBuffer << " found");
+            return 0;
+        }
+        num = num * 10 + (c - '0');
+    }
+
+    // 00            01 or -0
+    if (zeros > 1 || (zeros && (num || nega))) {
+        DEBUG(dbgSys, "Expected number but " << _numberBuffer << " found");
+        return 0;
+    }
+
+    if (nega)
+        /**
+         * This is why we need to handle -2147483648 individually:
+         * 2147483648 is larger than the range of int32
+         */
+        num = -num;
+
+    // It's safe to return directly if the number is small
+    if (len <= MAX_NUM_LENGTH - 2) return num;
+
+    /**
+     * We need to make sure that number is equal to the number in the buffer.
+     *
+     * Ask: Why do we need that?
+     * Answer: Because it's impossible to tell whether the number is bigger
+     * than INT32_MAX or smaller than INT32_MIN if it has the same length.
+     *
+     * For example: 3 000 000 000.
+     *
+     * In that case, that number will cause an overflow. However, C++
+     * doens't raise interger overflow, so we need to make sure that the input
+     * string and the output number is equal.
+     *
+     */
+    if (compareNumAndString(num, _numberBuffer))
+        return num;
+    else
+        DEBUG(dbgSys,
+              "Expected int32 number but " << _numberBuffer << " found");
+
+    return 0;
+}
+
+void SysPrintNum(int num) {
+    if (num == 0) return kernel->synchConsoleOut->PutChar('0');
+
+    if (num == INT32_MIN) {
+        kernel->synchConsoleOut->PutChar('-');
+        for (int i = 0; i < 10; ++i)
+            kernel->synchConsoleOut->PutChar("2147483648"[i]);
+        return;
+    }
+
+    if (num < 0) {
+        kernel->synchConsoleOut->PutChar('-');
+        num = -num;
+    }
+    int n = 0;
+    while (num) {
+        _numberBuffer[n++] = num % 10;
+        num /= 10;
+    }
+    for (int i = n - 1; i >= 0; --i)
+        kernel->synchConsoleOut->PutChar(_numberBuffer[i] + '0');
+}
+
+char SysReadChar() { return kernel->synchConsoleIn->GetChar(); }
+
+void SysPrintChar(char character) {
+    kernel->synchConsoleOut->PutChar(character);
+}
+
+int SysRandomNum() { return random(); }
+
+char* SysReadString(int length) {
+    char* buffer = new char[length + 1];
+    for (int i = 0; i < length; i++) {
+        buffer[i] = SysReadChar();
+    }
+    buffer[length] = '\0';
+    return buffer;
+}
+
+void SysPrintString(char* buffer, int length) {
+    for (int i = 0; i < length; i++) {
+        kernel->synchConsoleOut->PutChar(buffer[i]);
+    }
+}
+
+bool SysCreateFile(char* fileName) {
+    bool success;
+    int fileNameLength = strlen(fileName);
+
+    if (fileNameLength == 0) {
+        DEBUG(dbgSys, "\nFile name can't be empty");
+        success = false;
+
+    } else if (fileName == NULL) {
+        DEBUG(dbgSys, "\nNot enough memory in system");
+        success = false;
+
+    } else {
+        DEBUG(dbgSys, "\nFile's name read successfully");
+        if (!kernel->fileSystem->Create(fileName)) {
+            DEBUG(dbgSys, "\nError creating file");
+            success = false;
+        } else {
+            success = true;
+        }
+    }
+
+    return success;
+}
+
+int SysOpen(char* fileName, int type) {
+    if (type != 0 && type != 1) return -1;
+
+    int id = kernel->fileSystem->Open(fileName, type);
+    if (id == -1) return -1;
+    DEBUG(dbgSys, "\nOpened file");
+    return id;
+}
+
+int SysClose(int id) { return kernel->fileSystem->Close(id); }
+
+int SysRead(char* buffer, int charCount, int fileId) {
+    if (fileId == 0) {
+        return kernel->synchConsoleIn->GetString(buffer, charCount);
+    }
+    return kernel->fileSystem->Read(buffer, charCount, fileId);
+}
+
+int SysWrite(char* buffer, int charCount, int fileId) {
+    if (fileId == 1) {
+        return kernel->synchConsoleOut->PutString(buffer, charCount);
+    }
+    return kernel->fileSystem->Write(buffer, charCount, fileId);
+}
+
+int SysSeek(int seekPos, int fileId) {
+    if (fileId <= 1) {
+        DEBUG(dbgSys, "\nCan't seek in console");
+        return -1;
+    }
+    return kernel->fileSystem->Seek(seekPos, fileId);
+}
+
+int SysExec(char* name) {
+    // cerr << "call: `" << name  << "`"<< endl;
+    OpenFile* oFile = kernel->fileSystem->Open(name);
+    if (oFile == NULL) {
+        DEBUG(dbgSys, "\nExec:: Can't open this file.");
+        return -1;
+    }
+
+    delete oFile;
+
+    // Return child process id
+    return kernel->pTab->ExecUpdate(name);
+}
+
+int SysJoin(int id) { return kernel->pTab->JoinUpdate(id); }
+
+int SysExit(int id) { return kernel->pTab->ExitUpdate(id); }
+
+int SysCreateSemaphore(char* name, int initialValue) {
+    int res = kernel->semTab->Create(name, initialValue);
+
+    if (res == -1) {
+        DEBUG('a', "\nError creating semaphore");
+        delete[] name;
+        return -1;
+    }
+
+    return 0;
+}
+
+int SysWait(char* name) {
+    int res = kernel->semTab->Wait(name);
+
+    if (res == -1) {
+        DEBUG('a', "\nSemaphore not found");
+        delete[] name;
+        return -1;
+    }
+
+    return 0;
+}
+
+int SysSignal(char* name) {
+    int res = kernel->semTab->Signal(name);
+
+    if (res == -1) {
+        DEBUG('a', "\nSemaphore not found");
+        delete[] name;
+        return -1;
+    }
+
+    return 0;
+}
+
+int SysGetPid() { return kernel->currentThread->processID; }
+
+#endif /* ! __USERPROG_KSYSCALL_H__ */
diff --git a/code/userprog/ksyscallhelper.h b/code/userprog/ksyscallhelper.h
new file mode 100644
index 0000000..5f40360
--- /dev/null
+++ b/code/userprog/ksyscallhelper.h
@@ -0,0 +1,86 @@
+/**************************************************************
+ *
+ * userprog/ksyscallhelper.h
+ *
+ * Helper function for ksyscall.h
+ *
+ * by Thuc Le.
+ *
+ **************************************************************/
+
+#ifndef __USERPROG_KSYSCALLHELPER_H__
+#define __USERPROG_KSYSCALLHELPER_H__
+
+#include "kernel.h"
+#include "synchconsole.h"
+
+#define LF ((char)10)
+#define CR ((char)13)
+#define TAB ((char)9)
+#define SPACE ((char)' ')
+
+/* maximum length of an interger (included the minus sign) */
+#define MAX_NUM_LENGTH 11
+/* A buffer to read and write number */
+char _numberBuffer[MAX_NUM_LENGTH + 2];
+
+char isBlank(char c) { return c == LF || c == CR || c == TAB || c == SPACE; }
+
+/**
+ * Read and store characters in the _numberBuffer until blank
+ * or end of file
+ *
+ * It will read at most MAX_NUM_LENGTH + 1 character
+ **/
+void readUntilBlank() {
+    memset(_numberBuffer, 0, sizeof(_numberBuffer));
+    char c = kernel->synchConsoleIn->GetChar();
+
+    if (c == EOF) {
+        DEBUG(dbgSys, "Unexpected end of file - number expected");
+        return;
+    }
+
+    if (isBlank(c)) {
+        DEBUG(dbgSys, "Unexpected white-space - number expected");
+        return;
+    }
+
+    int n = 0;
+
+    while (!(isBlank(c) || c == EOF)) {
+        _numberBuffer[n++] = c;
+        if (n > MAX_NUM_LENGTH) {
+            DEBUG(dbgSys, "Number is too long");
+            return;
+        }
+        c = kernel->synchConsoleIn->GetChar();
+    }
+}
+
+/**
+ * Return true of the interger equals to the
+ * interger stored in the string
+ **/
+bool compareNumAndString(int integer, const char *s) {
+    if (integer == 0) return strcmp(s, "0") == 0;
+
+    int len = strlen(s);
+
+    if (integer < 0 && s[0] != '-') return false;
+
+    if (integer < 0) s++, --len, integer = -integer;
+
+    while (integer > 0) {
+        int digit = integer % 10;
+
+        if (s[len - 1] - '0' != digit) return false;
+
+        --len;
+        integer /= 10;
+    }
+
+    return len == 0;
+}
+
+#endif /* ! __USERPROG_KSYSCALLHELPER_H__ */
diff --git a/code/userprog/noff.h b/code/userprog/noff.h
new file mode 100644
index 0000000..817e506
--- /dev/null
+++ b/code/userprog/noff.h
@@ -0,0 +1,29 @@
+/* noff.h
+ *     Data structures defining the Nachos Object Code Format
+ *
+ *     Basically, we only know about three types of segments:
+ *	code (read-only), initialized data, and unitialized data
+ */
+
+#define NOFFMAGIC                            \
+    0xbadfad /* magic number denoting Nachos \
+              * object code file             \
+              */
+
+typedef struct segment {
+    int virtualAddr; /* location of segment in virt addr space */
+    int inFileAddr;  /* location of segment in this file */
+    int size;        /* size of segment */
+} Segment;
+
+typedef struct noffHeader {
+    int noffMagic;    /* should be NOFFMAGIC */
+    Segment code;     /* executable code segment */
+    Segment initData; /* initialized data segment */
+#ifdef RDATA
+    Segment readonlyData; /* read only data */
+#endif
+    Segment uninitData; /* uninitialized data segment --
+                         * should be zero'ed before use
+                         */
+} NoffHeader;
diff --git a/code/userprog/synchconsole.cc b/code/userprog/synchconsole.cc
new file mode 100644
index 0000000..b3447c5
--- /dev/null
+++ b/code/userprog/synchconsole.cc
@@ -0,0 +1,130 @@
+// synchconsole.cc
+//	Routines providing synchronized access to the keyboard
+//	and console display hardware devices.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#include "copyright.h"
+#include "synchconsole.h"
+
+//----------------------------------------------------------------------
+// SynchConsoleInput::SynchConsoleInput
+//      Initialize synchronized access to the keyboard
+//
+//      "inputFile" -- if NULL, use stdin as console device
+//              otherwise, read from this file
+//----------------------------------------------------------------------
+
+SynchConsoleInput::SynchConsoleInput(char *inputFile) {
+    consoleInput = new ConsoleInput(inputFile, this);
+    lock = new Lock("console in");
+    waitFor = new Semaphore("console in", 0);
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleInput::~SynchConsoleInput
+//      Deallocate data structures for synchronized access to the keyboard
+//----------------------------------------------------------------------
+
+SynchConsoleInput::~SynchConsoleInput() {
+    delete consoleInput;
+    delete lock;
+    delete waitFor;
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleInput::GetChar
+//      Read a character typed at the keyboard, waiting if necessary.
+//----------------------------------------------------------------------
+
+char SynchConsoleInput::GetChar() {
+    char ch;
+
+    lock->Acquire();
+    waitFor->P();  // wait for EOF or a char to be available.
+    ch = consoleInput->GetChar();
+    lock->Release();
+    return ch;
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleInput::GetString
+//      Read a string from keyboard to buffer, return number of read characters.
+//----------------------------------------------------------------------
+
+int SynchConsoleInput::GetString(char *buffer, int size) {
+    for (int i = 0; i < size; ++i) {
+        buffer[i] = GetChar();
+        if (buffer[i] == EOF) {
+            buffer[i] = 0;
+            return -2;
+        }
+    }
+    return size;
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleInput::CallBack
+//      Interrupt handler called when keystroke is hit; wake up
+//	anyone waiting.
+//----------------------------------------------------------------------
+
+void SynchConsoleInput::CallBack() { waitFor->V(); }
+
+//----------------------------------------------------------------------
+// SynchConsoleOutput::SynchConsoleOutput
+//      Initialize synchronized access to the console display
+//
+//      "outputFile" -- if NULL, use stdout as console device
+//              otherwise, read from this file
+//----------------------------------------------------------------------
+
+SynchConsoleOutput::SynchConsoleOutput(char *outputFile) {
+    consoleOutput = new ConsoleOutput(outputFile, this);
+    lock = new Lock("console out");
+    waitFor = new Semaphore("console out", 0);
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleOutput::~SynchConsoleOutput
+//      Deallocate data structures for synchronized access to the keyboard
+//----------------------------------------------------------------------
+
+SynchConsoleOutput::~SynchConsoleOutput() {
+    delete consoleOutput;
+    delete lock;
+    delete waitFor;
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleOutput::PutChar
+//      Write a character to the console display, waiting if necessary.
+//----------------------------------------------------------------------
+
+void SynchConsoleOutput::PutChar(char ch) {
+    lock->Acquire();
+    consoleOutput->PutChar(ch);
+    waitFor->P();
+    lock->Release();
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleOutput::PutString
+//      Write a string to the console display, return number of written
+//      charaters.
+//----------------------------------------------------------------------
+
+int SynchConsoleOutput::PutString(char *buffer, int size) {
+    for (int i = 0; i < size; ++i) PutChar(buffer[i]);
+    return size;
+}
+
+//----------------------------------------------------------------------
+// SynchConsoleOutput::CallBack
+//      Interrupt handler called when it's safe to send the next
+//	character can be sent to the display.
+//----------------------------------------------------------------------
+
+void SynchConsoleOutput::CallBack() { waitFor->V(); }
diff --git a/code/userprog/synchconsole.h b/code/userprog/synchconsole.h
new file mode 100644
index 0000000..4faf8a2
--- /dev/null
+++ b/code/userprog/synchconsole.h
@@ -0,0 +1,55 @@
+// synchconsole.h
+//	Data structures for synchronized access to the keyboard
+//	and console display devices.
+//
+//	NOTE: this abstraction is not completely implemented.
+//
+// Copyright (c) 1992-1996 The Regents of the University of California.
+// All rights reserved.  See copyright.h for copyright notice and limitation
+// of liability and disclaimer of warranty provisions.
+
+#ifndef SYNCHCONSOLE_H
+#define SYNCHCONSOLE_H
+
+#include "copyright.h"
+#include "utility.h"
+#include "callback.h"
+#include "console.h"
+#include "synch.h"
+
+// The following two classes define synchronized input and output to
+// a console device
+
+class SynchConsoleInput : public CallBackObj {
+   public:
+    SynchConsoleInput(char *inputFile);  // Initialize the console device
+    ~SynchConsoleInput();                // Deallocate console device
+
+    char GetChar();  // Read a character, waiting if necessary
+    int GetString(char *buffer, int size);  // Read characters into buffer
+
+   private:
+    ConsoleInput *consoleInput;  // the hardware keyboard
+    Lock *lock;                  // only one reader at a time
+    Semaphore *waitFor;          // wait for callBack
+
+    void CallBack();  // called when a keystroke is available
+};
+
+class SynchConsoleOutput : public CallBackObj {
+   public:
+    SynchConsoleOutput(char *outputFile);  // Initialize the console device
+    ~SynchConsoleOutput();
+
+    void PutChar(char ch);  // Write a character, waiting if necessary
+    int PutString(char *buffer, int size);  // Write characters from buffer
+
+   private:
+    ConsoleOutput *consoleOutput;  // the hardware display
+    Lock *lock;                    // only one writer at a time
+    Semaphore *waitFor;            // wait for callBack
+
+    void CallBack();  // called when more data can be written
+};
+
+#endif  // SYNCHCONSOLE_H
diff --git a/code/userprog/syscall.h b/code/userprog/syscall.h
new file mode 100644
index 0000000..6b97db7
--- /dev/null
+++ b/code/userprog/syscall.h
@@ -0,0 +1,217 @@
+/* syscalls.h
+ * 	Nachos system call interface.  These are Nachos kernel operations
+ * 	that can be invoked from user programs, by trapping to the kernel
+ *	via the "syscall" instruction.
+ *
+ *	This file is included by user programs and by the Nachos kernel.
+ *
+ * Copyright (c) 1992-1993 The Regents of the University of California.
+ * All rights reserved.  See copyright.h for copyright notice and limitation
+ * of liability and disclaimer of warranty provisions.
+ */
+
+#ifndef SYSCALLS_H
+#define SYSCALLS_H
+
+#include "copyright.h"
+#include "errno.h"
+/* system call codes -- used by the stubs to tell the kernel which system call
+ * is being asked for
+ */
+#define SC_Halt 0
+#define SC_Exit 1
+#define SC_Exec 2
+#define SC_Join 3
+#define SC_Create 4
+#define SC_Remove 5
+#define SC_Open 6
+#define SC_Read 7
+#define SC_Write 8
+#define SC_Seek 9
+#define SC_Close 10
+#define SC_ThreadFork 11
+#define SC_ThreadYield 12
+#define SC_ExecV 13
+#define SC_ThreadExit 14
+#define SC_ThreadJoin 15
+
+#define SC_Add 42
+#define SC_ReadNum 43
+#define SC_PrintNum 44
+#define SC_ReadChar 45
+#define SC_PrintChar 46
+#define SC_RandomNum 47
+#define SC_ReadString 48
+#define SC_PrintString 49
+#define SC_CreateFile 50
+#define SC_CreateSemaphore 51
+#define SC_Wait 52
+#define SC_Signal 53
+#define SC_GetPid 54
+#define SC_Abs 55
+
+#ifndef IN_ASM
+
+/* The system call interface.  These are the operations the Nachos
+ * kernel needs to support, to be able to run user programs.
+ *
+ * Each of these is invoked by a user program by simply calling the
+ * procedure; an assembly language stub stuffs the system call code
+ * into a register, and traps to the kernel.  The kernel procedures
+ * are then invoked in the Nachos kernel, after appropriate error checking,
+ * from the system call entry point in exception.cc.
+ */
+
+/* Stop Nachos, and print out performance stats */
+void Halt();
+
+/*
+ * Add the two operants and return the result
+ */
+
+int Add(int op1, int op2);
+
+int ReadNum();
+
+void PrintNum(int num);
+
+char ReadChar();
+
+void PrintChar(char character);
+
+int RandomNum();
+
+void ReadString(char *buffer, int length);
+
+void PrintString(char *buffer);
+
+/* Address space control operations: Exit, Exec, Execv, and Join */
+
+/* This user program is done (status = 0 means exited normally). */
+void Exit(int status);
+
+/* A unique identifier for an executing user program (address space) */
+typedef int SpaceId;
+
+/* A unique identifier for a thread within a task */
+typedef int ThreadId;
+
+/* Run the specified executable, with no args */
+/* This can be implemented as a call to ExecV.
+ */
+SpaceId Exec(char *exec_name);
+
+/* Run the executable, stored in the Nachos file "argv[0]", with
+ * parameters stored in argv[1..argc-1] and return the
+ * address space identifier
+ */
+SpaceId ExecV(int argc, char *argv[]);
+
+/* Only return once the user program "id" has finished.
+ * Return the exit status.
+ */
+int Join(SpaceId id);
+
+/* File system operations: Create, Remove, Open, Read, Write, Close
+ * These functions are patterned after UNIX -- files represent
+ * both files *and* hardware I/O devices.
+ *
+ * Note that the Nachos file system has a stub implementation, which
+ * can be used to support these system calls if the regular Nachos
+ * file system has not been implemented.
+ */
+
+/* A unique identifier for an open Nachos file. */
+typedef int OpenFileId;
+
+/* when an address space starts up, it has two open files, representing
+ * keyboard input and display output (in UNIX terms, stdin and stdout).
+ * Read and Write can be used directly on these, without first opening
+ * the console device.
+ */
+
+#define _ConsoleInput 0   // Change define name to avoid duplication
+#define _ConsoleOutput 1  // Same as above
+
+/* Create a Nachos file, with name "name" */
+/* Note: Create does not open the file.   */
+/* Return 1 on success, negative error code on failure */
+int Create(char *name);
+
+int CreateFile(char *name);
+
+/* Remove a Nachos file, with name "name" */
+int Remove(char *name);
+
+/* Open the Nachos file "name", and return an "OpenFileId" that can
+ * be used to read and write to the file.
+ */
+// OpenFileId Open(char *name);
+
+OpenFileId Open(char *name, int type);
+
+/* Write "size" bytes from "buffer" to the open file.
+ * Return the number of bytes actually read on success.
+ * On failure, a negative error code is returned.
+ */
+int Write(char *buffer, int size, OpenFileId id);
+
+/* Read "size" bytes from the open file into "buffer".
+ * Return the number of bytes actually read -- if the open file isn't
+ * long enough, or if it is an I/O device, and there aren't enough
+ * characters to read, return whatever is available (for I/O devices,
+ * you should always wait until you can return at least one character).
+ */
+int Read(char *buffer, int size, OpenFileId id);
+
+/* Set the seek position of the open file "id"
+ * to the byte "position".
+ */
+int Seek(int position, OpenFileId id);
+
+/* Close the file, we're done reading and writing to it.
+ * Return 1 on success, negative error code on failure
+ */
+int Close(OpenFileId id);
+
+// Ham cho semaphore
+// Success: 0 - Failed: -1
+// Ham tao 1 semaphore voi ten semaphore
+int CreateSemaphore(char *name, int semval);
+
+int Wait(char *name);
+
+int Signal(char *name);
+
+/* User-level thread operations: Fork and Yield.  To allow multiple
+ * threads to run within a user program.
+ *
+ * Could define other operations, such as LockAcquire, LockRelease, etc.
+ */
+
+/* Fork a thread to run a procedure ("func") in the *same* address space
+ * as the current thread.
+ * Return a positive ThreadId on success, negative error code on failure
+ */
+ThreadId ThreadFork(void (*func)());
+
+/* Yield the CPU to another runnable thread, whether in this address space
+ * or not.
+ */
+void ThreadYield();
+
+/*
+ * Blocks current thread until lokal thread ThreadID exits with ThreadExit.
+ * Function returns the ExitCode of ThreadExit() of the exiting thread.
+ */
+int ThreadJoin(ThreadId id);
+
+/*
+ * Deletes current thread and returns ExitCode to every waiting lokal thread.
+ */
+void ThreadExit(int ExitCode);
+int Abs(int op1);
+
+#endif /* IN_ASM */
+
+#endif /* SYSCALL_H */
diff --git a/coff2noff.sh b/coff2noff.sh
new file mode 100644
index 0000000..24510fe
--- /dev/null
+++ b/coff2noff.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+set -e
+
+cd coff2noff
+make
diff --git a/coff2noff/Makefile b/coff2noff/Makefile
new file mode 100644
index 0000000..5ab69d4
--- /dev/null
+++ b/coff2noff/Makefile
@@ -0,0 +1,63 @@
+# Makefile for:
+#	coff2noff -- converts a normal MIPS executable into a Nachos executable
+#
+# This is a GNU Makefile.  It must be used with the GNU make program.
+# At UW, the GNU make program is /software/gnu/bin/make.
+# In many other places it is known as "gmake".
+# You may wish to include /software/gnu/bin/ early in your command
+# search path, so that you will be using GNU make when you type "make".
+#
+#  Use "make" to build the executable(s)
+#  Use "make clean" to remove .o files
+#  Use "make distclean" to remove all files produced by make, including
+#     the executable
+#
+#
+# Copyright (c) 1992-1996 The Regents of the University of California.
+# All rights reserved.  See copyright.h for copyright notice and limitation 
+# of liability and disclaimer of warranty provisions.
+#
+#  This file has been modified for use at Waterloo
+#
+#############################################################################
+# Makefile.dep contains all machine-dependent definitions
+# If you are trying to build coff2noff somewhere outside
+# of the MFCF environment, you will almost certainly want
+# to visit and edit Makefile.dep before doing so
+#############################################################################
+include Makefile.dep
+
+CC=gcc
+CFLAGS= $(HOSTCFLAGS) -DRDATA -m32
+LD=gcc -m32
+RM = /bin/rm
+MV = /bin/mv
+
+ifeq ($(hosttype),unknown)
+buildtargets = unknownhost
+else
+buildtargets = coff2noff.$(hosttype)
+endif
+
+all: $(buildtargets)
+
+# converts a COFF file to Nachos object format
+coff2noff.$(hosttype): coff2noff.o
+	$(LD) coff2noff.o -o coff2noff.$(hosttype)
+	strip coff2noff.$(hosttype)
+
+clean:
+	$(RM) -f coff2noff.o
+
+distclean: clean
+	$(MV) coff2noff.c temp.c
+	$(RM) -f coff2noff.*
+	$(MV) temp.c coff2noff.c
+
+
+unknownhost:
+	@echo Host type could not be determined.
+	@echo make is terminating
+	@echo If you are on an MFCF machine, contact the instructor
+	@echo to report this problem
+	@echo Otherwise, edit Makefile.dep and try again.
diff --git a/coff2noff/Makefile.dep b/coff2noff/Makefile.dep
new file mode 100644
index 0000000..b523c5b
--- /dev/null
+++ b/coff2noff/Makefile.dep
@@ -0,0 +1,91 @@
+#############################################################################
+# Machine-specific definitions
+#
+# In the MFCF environment, this attempts to determine automatically
+#  the machine type and OS type.  If it cannot, it gives up and
+#  prints a message.
+#
+# If you are not in the MFCF environment, you can either add a new
+# automatic test for your machine/OS type, or you can set the
+# necessary variables "manually" here
+#############################################################################
+
+# unfortunately, command line arguments to uname are not
+# very consistent across UNIX flavours.  However, the following
+# seem to work almost everywhere in MFCF land
+
+osname = $(shell uname -s)
+osrelease = $(shell uname -r)
+
+hosttype = unknown
+
+# Test for Solaris (5.6)
+# At Waterloo: agnesi,bacon,fenchel,fitch,lassar,magnus,merrill
+# If Solaris, we assume we are on a SPARC, which is not necessarily
+#  a good assumption outside of MFCF
+ifeq ($(osname),SunOS)
+ifeq ($(osrelease),5.6)
+HOSTCFLAGS = -DHOST_IS_BIG_ENDIAN
+hosttype = sparcSolaris
+endif
+endif
+
+# Test for Solaris (5.5)
+# At Waterloo: hermite.math,markov.math,picard.math,wronski.math,...
+# If Solaris, we assume we are on a SPARC, which is not necessarily
+#  a good assumption outside of MFCF
+ifeq ($(osname),SunOS)
+ifeq ($(osrelease),5.5)
+HOSTCFLAGS = -DHOST_IS_BIG_ENDIAN
+hosttype = sparcSolaris
+endif
+endif
+
+# Test for Solaris (5.4)
+# At Waterloo: hume.math, hypatia.math,...
+# This is the same setup as Solaris 5.5
+# If Solaris, we assume we are on a SPARC, which is not necessarily
+#  a good assumption outside of MFCF
+ifeq ($(osname),SunOS)
+ifeq ($(osrelease),5.4)
+HOSTCFLAGS = -DHOST_IS_BIG_ENDIAN
+hosttype = sparcSolaris
+endif
+endif
+
+# Test for SunOS 4.xx
+# At Waterloo:  descartes,cayley,napier,....
+# If SunOS, we assume we are on a SPARC, which is not necessarily
+#  a good assumption outside of MFCF
+ifeq ($(osname),SunOS)
+ifeq ($(osrelease),4.1.3_U1)
+HOSTCFLAGS = -DHOST_IS_BIG_ENDIAN
+hosttype = sparcSunOS
+endif
+endif
+
+# Test for ULTRIX
+# At Waterloo: cantor.math,noether.math
+# Assume ULTRIX on a MIPS architecture
+ifeq ($(osname),ULTRIX)
+HOSTCFLAGS = 
+hosttype = mipsUltrix
+endif
+
+# Note:
+# If you are trying to build on Linux on an x86
+# try something like this, substituting whatever
+# uname -s returns on your machine for the XXX
+#
+ifeq ($(osname),Linux)
+HOSTCFLAGS =
+hosttype = x86Linux
+endif
+
+ifeq ($(osname),CYGWIN_NT-5.1)
+HOSTCFLAGS =
+hosttype = x86Linux
+endif
+
+
+
diff --git a/coff2noff/coff.h b/coff2noff/coff.h
new file mode 100644
index 0000000..a7cf79d
--- /dev/null
+++ b/coff2noff/coff.h
@@ -0,0 +1,49 @@
+/* coff.h
+ *   Data structures that describe the MIPS COFF format.
+ */
+
+struct filehdr {
+        unsigned short  f_magic;        /* magic number */
+        unsigned short  f_nscns;        /* number of sections */
+        long            f_timdat;       /* time & date stamp */
+        long            f_symptr;       /* file pointer to symbolic header */
+        long            f_nsyms;        /* sizeof(symbolic hdr) */
+        unsigned short  f_opthdr;       /* sizeof(optional hdr) */
+        unsigned short  f_flags;        /* flags */
+      };
+
+#define  MIPSELMAGIC    0x0162
+
+#define OMAGIC  0407
+#define SOMAGIC 0x0701
+
+typedef struct aouthdr {
+        short   magic;          /* see above                            */
+        short   vstamp;         /* version stamp                        */
+        long    tsize;          /* text size in bytes, padded to DW bdry*/
+        long    dsize;          /* initialized data "  "                */
+        long    bsize;          /* uninitialized data "   "             */
+        long    entry;          /* entry pt.                            */
+        long    text_start;     /* base of text used for this file      */
+        long    data_start;     /* base of data used for this file      */
+        long    bss_start;      /* base of bss used for this file       */
+        long    gprmask;        /* general purpose register mask        */
+        long    cprmask[4];     /* co-processor register masks          */
+        long    gp_value;       /* the gp value used for this object    */
+      } AOUTHDR;
+#define AOUTHSZ sizeof(AOUTHDR)
+ 
+
+struct scnhdr {
+        char            s_name[8];      /* section name */
+        long            s_paddr;        /* physical address, aliased s_nlib */
+        long            s_vaddr;        /* virtual address */
+        long            s_size;         /* section size */
+        long            s_scnptr;       /* file ptr to raw data for section */
+        long            s_relptr;       /* file ptr to relocation */
+        long            s_lnnoptr;      /* file ptr to gp histogram */
+        unsigned short  s_nreloc;       /* number of relocation entries */
+        unsigned short  s_nlnno;        /* number of gp histogram entries */
+        long            s_flags;        /* flags */
+      };
+ 
diff --git a/coff2noff/coff2noff.c b/coff2noff/coff2noff.c
new file mode 100644
index 0000000..1d9b7cb
--- /dev/null
+++ b/coff2noff/coff2noff.c
@@ -0,0 +1,300 @@
+/* coff2noff.c 
+ *
+ * This program reads in a COFF format file, and outputs a NOFF format file.
+ * The NOFF format is essentially just a simpler version of the COFF file,
+ * recording where each segment is in the NOFF file, and where it is to
+ * go in the virtual address space.
+ * 
+ * Assumes coff file is linked with either
+ *	gld with -N -Ttext 0 
+ * 	ld with  -N -T 0
+ * to make sure the object file has no shared text.
+ *
+ * Also assumes that the COFF file has at most 3 segments:
+ *	.text	-- read-only executable instructions 
+ *	.data	-- initialized data
+ *	.bss/.sbss -- uninitialized data (should be zero'd on program startup)
+#ifdef RDATA
+ *      .rdata  -- read-only data (e.g., string literals).
+ *                 mark this segment readonly to prevent it from being modified
+#endif
+ *
+ *
+ * Copyright (c) 1992-1993 The Regents of the University of California.
+ * All rights reserved.  See copyright.h for copyright notice and limitation 
+ * of liability and disclaimer of warranty provisions.
+ */
+
+/* 
+ * Modified at UW by KMS, August, 1997
+ *   The modified program always writes the NOFF header in little-endian
+ *    format, rather than host format.  This is to avoid the problem
+ *    that user programs run through coff2noff on a big-endian host
+ *    would not run properly on Nachos machines running on little-endian
+ *    hosts.
+ *
+ *    Note that the Nachos address space loading code
+ *    (in AddrSpace::Load) on big-endian hosts converts the header
+ *    to big-endian format when it is read in.
+ *    Thus, the little-endian header NOFF
+ *    header should work OK whether Nachos is running on a little-endian
+ *    host or a big-endian host.
+ */
+
+#define MAIN
+#include "copyright.h" 
+#undef MAIN
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "coff.h"
+#include "noff.h"
+
+/****************************************************************/
+/* Routines for converting words and short words to and from the
+ * simulated machine's format of little endian.  These end up
+ * being NOPs when the host machine is little endian.
+ */
+
+unsigned int
+WordToHost(unsigned int word) {
+#ifdef HOST_IS_BIG_ENDIAN
+	 register unsigned long result;
+	 result = (word >> 24) & 0x000000ff;
+	 result |= (word >> 8) & 0x0000ff00;
+	 result |= (word << 8) & 0x00ff0000;
+	 result |= (word << 24) & 0xff000000;
+	 return result;
+#else 
+	 return word;
+#endif /* HOST_IS_BIG_ENDIAN */
+}
+
+unsigned short
+ShortToHost(unsigned short shortword) {
+#if HOST_IS_BIG_ENDIAN
+	 register unsigned short result;
+	 result = (shortword << 8) & 0xff00;
+	 result |= (shortword >> 8) & 0x00ff;
+	 return result;
+#else 
+	 return shortword;
+#endif /* HOST_IS_BIG_ENDIAN */
+}
+
+unsigned int
+WordToMachine(unsigned int word) { return WordToHost(word); }
+
+unsigned short
+ShortToMachine(unsigned short shortword) { return ShortToHost(shortword); }
+
+// this routine was borrowed from userprog/addrspace.cc
+// on a big-endian machine, it converts all fields of
+// the NOFF header to little-endian format
+// on a little-endian machine, where the header is already
+// in little-endian format, it does nothing
+static void 
+SwapHeader (NoffHeader *noffH)
+{
+    noffH->noffMagic = WordToHost(noffH->noffMagic);
+    noffH->code.size = WordToHost(noffH->code.size);
+    noffH->code.virtualAddr = WordToHost(noffH->code.virtualAddr);
+    noffH->code.inFileAddr = WordToHost(noffH->code.inFileAddr);
+#ifdef RDATA
+    noffH->readonlyData.size = WordToHost(noffH->readonlyData.size);
+    noffH->readonlyData.virtualAddr = 
+           WordToHost(noffH->readonlyData.virtualAddr);
+    noffH->readonlyData.inFileAddr = 
+           WordToHost(noffH->readonlyData.inFileAddr);
+#endif
+    noffH->initData.size = WordToHost(noffH->initData.size);
+    noffH->initData.virtualAddr = WordToHost(noffH->initData.virtualAddr);
+    noffH->initData.inFileAddr = WordToHost(noffH->initData.inFileAddr);
+    noffH->uninitData.size = WordToHost(noffH->uninitData.size);
+    noffH->uninitData.virtualAddr = WordToHost(noffH->uninitData.virtualAddr);
+    noffH->uninitData.inFileAddr = WordToHost(noffH->uninitData.inFileAddr);
+}
+
+/****************************************************************/
+
+#define ReadStruct(f,s) 	Read(f,(char *)&s,sizeof(s))
+
+char *noffFileName = NULL;
+
+/* read and check for error */
+void Read(int fd, char *buf, int nBytes)
+{
+    if (read(fd, buf, nBytes) != nBytes) {
+        fprintf(stderr, "File is too short\n");
+	unlink(noffFileName);
+	exit(1);
+    }
+}
+
+/* write and check for error */
+void Write(int fd, char *buf, int nBytes)
+{
+    if (write(fd, buf, nBytes) != nBytes) {
+	fprintf(stderr, "Unable to write file\n");
+	unlink(noffFileName);
+	exit(1);
+    }
+}
+
+int main(int argc, char **argv)
+{
+    int fdIn, fdOut, numsections, i, inNoffFile;
+    struct filehdr fileh;
+    struct aouthdr systemh;
+    struct scnhdr *sections;
+    char *buffer;
+    NoffHeader noffH;
+
+    if (argc < 2) {
+	fprintf(stderr, "Usage: %s <coffFileName> <noffFileName>\n", argv[0]);
+	exit(1);
+    }
+    
+/* open the COFF file (input) */
+    fdIn = open(argv[1], O_RDONLY, 0);
+    if (fdIn == -1) {
+	perror(argv[1]);
+	exit(1);
+    }
+
+/* open the NOFF file (output) */
+    fdOut = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC , 0666);
+    if (fdIn == -1) {
+	perror(argv[2]);
+	exit(1);
+    }
+    noffFileName = argv[2];
+    
+/* Read in the file header and check the magic number. */
+    ReadStruct(fdIn,fileh);
+    fileh.f_magic = ShortToHost(fileh.f_magic);
+    fileh.f_nscns = ShortToHost(fileh.f_nscns); 
+    if (fileh.f_magic != MIPSELMAGIC) {
+	fprintf(stderr, "File is not a MIPSEL COFF file\n");
+        unlink(noffFileName);
+	exit(1);
+    }
+    
+/* Read in the system header and check the magic number */
+    ReadStruct(fdIn,systemh);
+    systemh.magic = ShortToHost(systemh.magic);
+    if (systemh.magic != OMAGIC) {
+	fprintf(stderr, "File is not a OMAGIC file\n");
+        unlink(noffFileName);
+	exit(1);
+    }
+    
+/* Read in the section headers. */
+    numsections = fileh.f_nscns;
+    printf("numsections %d \n",numsections);
+    sections = (struct scnhdr *)malloc(numsections * sizeof(struct scnhdr));
+    Read(fdIn, (char *) sections, numsections * sizeof(struct scnhdr));
+
+   for (i = 0; i < numsections; i++) {
+     sections[i].s_paddr =  WordToHost(sections[i].s_paddr);
+     sections[i].s_size = WordToHost(sections[i].s_size);
+     sections[i].s_scnptr = WordToHost(sections[i].s_scnptr);
+   }
+
+ /* initialize the NOFF header, in case not all the segments are defined
+  * in the COFF file
+  */
+    noffH.noffMagic = NOFFMAGIC;
+    noffH.code.size = 0;
+    noffH.initData.size = 0;
+    noffH.uninitData.size = 0;
+#ifdef RDATA
+    noffH.readonlyData.size = 0;
+#endif
+
+
+ /* Copy the segments in */
+    inNoffFile = sizeof(NoffHeader);
+    lseek(fdOut, inNoffFile, 0);
+    printf("Loading %d sections:\n", numsections);
+    for (i = 0; i < numsections; i++) {
+	printf("\t\"%s\", filepos 0x%x, mempos 0x%x, size 0x%x\n",
+	      sections[i].s_name, (unsigned int)sections[i].s_scnptr,
+	      (unsigned int)sections[i].s_paddr, (unsigned int)sections[i].s_size);
+	if (sections[i].s_size == 0) {
+		/* do nothing! */	
+	} else if (!strcmp(sections[i].s_name, ".text")) {
+	    noffH.code.virtualAddr = sections[i].s_paddr;
+	    noffH.code.inFileAddr = inNoffFile;
+	    noffH.code.size = sections[i].s_size;
+    	    lseek(fdIn, sections[i].s_scnptr, 0);
+    	    buffer = malloc(sections[i].s_size);
+    	    Read(fdIn, buffer, sections[i].s_size);
+    	    Write(fdOut, buffer, sections[i].s_size);
+    	    free(buffer);
+	    inNoffFile += sections[i].s_size;
+ 	} else if (!strcmp(sections[i].s_name, ".data")){
+
+	    noffH.initData.virtualAddr = sections[i].s_paddr;
+	    noffH.initData.inFileAddr = inNoffFile;
+	    noffH.initData.size = sections[i].s_size;
+	    lseek(fdIn, sections[i].s_scnptr, 0);
+	    buffer = malloc(sections[i].s_size);
+	    Read(fdIn, buffer, sections[i].s_size);
+	    Write(fdOut, buffer, sections[i].s_size);
+	    free(buffer);
+	    inNoffFile += sections[i].s_size;
+#ifdef RDATA
+	} else if (!strcmp(sections[i].s_name, ".rdata")){
+
+	    noffH.readonlyData.virtualAddr = sections[i].s_paddr;
+	    noffH.readonlyData.inFileAddr = inNoffFile;
+	    noffH.readonlyData.size = sections[i].s_size;
+	    lseek(fdIn, sections[i].s_scnptr, 0);
+	    buffer = malloc(sections[i].s_size);
+	    Read(fdIn, buffer, sections[i].s_size);
+	    Write(fdOut, buffer, sections[i].s_size);
+	    free(buffer);
+	    inNoffFile += sections[i].s_size;
+#endif
+	} else if (!strcmp(sections[i].s_name, ".bss")){
+  	    /* need to check if we have both .bss and .sbss -- make sure they 
+	     * are contiguous
+	     */
+	    if (noffH.uninitData.size != 0) {
+	        if (sections[i].s_paddr == (noffH.uninitData.virtualAddr +
+	        				noffH.uninitData.size)) {
+		    fprintf(stderr, "Can't handle both bss and sbss\n");
+		    unlink(noffFileName);
+		    exit(1);
+		}
+	        noffH.uninitData.size += sections[i].s_size;
+	    } else {
+	        noffH.uninitData.virtualAddr = sections[i].s_paddr;
+	        noffH.uninitData.size = sections[i].s_size;
+	    }
+	    /* we don't need to copy the uninitialized data! */
+	} else {
+	    fprintf(stderr, "Unknown segment type: %s\n", sections[i].s_name);
+            unlink(noffFileName);
+	    exit(1);
+	}
+    }
+    lseek(fdOut, 0, 0);
+
+    // convert the NOFF header to little-endian before
+    // writing it to the file
+    SwapHeader(&noffH);
+    
+    Write(fdOut, (char *)&noffH, sizeof(NoffHeader));
+    close(fdIn);
+    close(fdOut);
+    exit(0);
+}
diff --git a/coff2noff/copyright.h b/coff2noff/copyright.h
new file mode 100644
index 0000000..b2fa8a8
--- /dev/null
+++ b/coff2noff/copyright.h
@@ -0,0 +1,24 @@
+/*
+Copyright (c) 1992-1996 The Regents of the University of California.
+All rights reserved.
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose, without fee, and without written agreement is
+hereby granted, provided that the above copyright notice and the following
+two paragraphs appear in all copies of this software.
+
+IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
+OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
+CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
+PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+*/
+
+#ifdef MAIN	/* include the copyright message in every executable */
+static char *copyright = "Copyright (c) 1992-1993 The Regents of the University of California.  All rights reserved.";
+#endif // MAIN
diff --git a/coff2noff/noff.h b/coff2noff/noff.h
new file mode 100644
index 0000000..a8b5551
--- /dev/null
+++ b/coff2noff/noff.h
@@ -0,0 +1,28 @@
+/* noff.h 
+ *     Data structures defining the Nachos Object Code Format
+ *
+ *     Basically, we only know about three types of segments:
+ *	code (read-only), initialized data, and unitialized data
+ */
+
+#define NOFFMAGIC	0xbadfad 	/* magic number denoting Nachos 
+					 * object code file 
+					 */
+
+typedef struct segment {
+  int virtualAddr;		/* location of segment in virt addr space */
+  int inFileAddr;		/* location of segment in this file */
+  int size;			/* size of segment */
+} Segment;
+
+typedef struct noffHeader {
+   int noffMagic;		/* should be NOFFMAGIC */
+   Segment code;		/* executable code segment */ 
+   Segment initData;		/* initialized data segment */
+#ifdef RDATA
+   Segment readonlyData;	/* read only data */
+#endif
+   Segment uninitData;		/* uninitialized data segment --
+				 * should be zero'ed before use 
+				 */
+} NoffHeader;
diff --git a/full_install.sh b/full_install.sh
new file mode 100755
index 0000000..2d9f53e
--- /dev/null
+++ b/full_install.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+set -e
+
+bash install_building_tools.sh
+
+bash build_nachos.sh
+
+bash coff2noff.sh
+
+bash build_test.sh
diff --git a/install_building_tools.sh b/install_building_tools.sh
new file mode 100755
index 0000000..df3ff0d
--- /dev/null
+++ b/install_building_tools.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+set -e
+
+sudo apt-get install gcc g++ gcc-multilib g++-multilib make
+
+cd ..
+wget https://www.fit.hcmus.edu.vn/~ntquan/os/assignment/mips-decstation.linux-xgcc.gz
+tar zxvf mips-decstation.linux-xgcc.gz
diff --git a/lint.sh b/lint.sh
new file mode 100644
index 0000000..3a31868
--- /dev/null
+++ b/lint.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+set -e
+
+find code/ -iname *.h -o -iname *.cc -o -iname *.c | xargs clang-format -i
